<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NVA Network</title>
    <!-- Google Fonts - Bebas Neue for title, Inter for body -->
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- PWA Enhancements START -->
    <link rel="manifest" href="/manifest.json">
    <link rel="apple-touch-icon" href="/icon-192x192.png">
    <meta name="theme-color" content="#0A0A0A">
    <!-- PWA Enhancements END -->
    <style>
        *, *::before, *::after {
            box-sizing: border-box;
        }
        html {
            overflow-y: scroll; /* This is the definitive fix. It prevents layout shift. */
        }
        html {
            overflow-y: scroll; /* This is the definitive fix. It prevents layout shift. */
        }
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            background-color: #0A0A0A; /* Set the body background to match the app */
        }
        body {
            font-family: 'Inter', sans-serif;
            color: #FFF;
            display: flex;
            justify-content: center; /* This centers the app on larger screens */
            -webkit-overflow-scrolling: touch;
        }
        
        .loading-video-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: #0A0A0A;
            z-index: 9999;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .loading-video {
            width: 100%;
            height: 100%;
            object-fit: cover; /* This makes the video cover the screen without stretching */
        }

        #root {
            width: 100%; /* Ensure root takes full width of the centered body */
            min-height: 100vh;
            background-color: #0A0A0A;
            display: flex;
            flex-direction: column;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            max-width: 1200px; /* This now becomes the effective width on large screens */
        }
        .container {
            flex: 1; /* This makes the container grow to fill available space */
            background-color: #0A0A0A; /* Dark background */
            overflow-y: auto; /* The content inside this container will scroll */
            display: flex;
            flex-direction: column;
        }
        .header {
            position: relative; /* Keep for absolute positioning of logo */
            height: 150px;
            padding: 0 15px; /* Add padding for spacing */
            background-color: #0A0A0A;
            border-bottom: 1px solid #333;
            border-radius: 15px 15px 0 0;
            display: flex; /* Use flexbox to align items */
            justify-content: space-between; /* Space between left content and logo */
            align-items: center; /* Vertically center items */
        }

        /* New container for the text and button on the left */
        .header-content-left {
            display: flex;
            flex-direction: column;
            justify-content: space-around; /* This will space out the three items */
            height: 100%; /* Take full height of the header */
            padding: 10px 0; /* Add some vertical padding */
            z-index: 3;
        }
        
        .headerTitle {
            /* Remove absolute positioning */
            font-size: 38px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.7);
            font-family: 'Bebas Neue', sans-serif;
            margin: 0; /* Remove default margins */
            line-height: 1.1; /* Adjust line height */
            text-align: left; /* Ensure text is left aligned */
        }
        .tagline {
            /* Remove absolute positioning */
            font-size: 14px;
            color: #AAA;
            font-weight: normal;
            text-align: left;
            margin: 0; /* Remove default margins */
        }
    
        /* NEW CONTAINER for the right side of the header */
         .header-right-group {
            display: flex;
            align-items: center; /* Vertically aligns the logo and button */
            gap: 15px; /* Creates space between the logo and the button */
        }
        .headerLogo {
            height: 135px; /* Makes the logo larger to fill more of the header space */
            width: auto;   /* Maintains the correct aspect ratio */
            object-fit: contain;
        }
        .navigationBar {
            display: flex;
            flex-wrap: wrap; /* The key property to allow wrapping */
            justify-content: center; /* Centers the buttons as a group */
            gap: 15px; /* Creates perfect 15px spacing between all items */
            padding: 15px; /* Provides breathing room around the buttons */
            background-color: #1A1A1A;
            border-top: 1px solid #333;
            border-radius: 0 0 15px 15px;
        }
        .navButton {
            padding: 8px 15px;
            border-radius: 25px; /* Adjusted for consistency with other buttons */
            cursor: pointer;
            transition: background-color 0.3s ease;
            background-color: #FFD700; /* Changed to gold for visibility */
            box-shadow: 0 4px 5px rgba(0, 0, 0, 0.3);
            border: none; /* Removed border */
        }
        .navButton:hover {
            background-color: #FFC400;
        }
        .navButtonText {
            color: #0A0A0A; /* Changed to black for visibility */
            font-size: 14px;
            font-weight: 600;
        }
        .activeNavButtonText {
            color: #0A0A0A; /* Changed to black for visibility on gold background */
        }
        .screenContainer {
            flex: 1;
            padding: 15px;
            /* Removed overflow-y: auto; here as body will handle overall scrolling */
            position: relative; /* Added for positioning the new support button */
        }
        .sectionTitle {
            font-size: 20px;
            font-weight: bold;
            color: #FFF;
            margin-bottom: 15px;
            margin-top: 20px;
        }
        .contentGrid {
            display: grid;
            gap: 15px;
            /* Mobile First: Default to a strict 2-column layout */
            grid-template-columns: repeat(2, 1fr);
        }

        /* Tablet & Desktop: Switch to a responsive multi-column layout on larger screens */
        @media (min-width: 768px) {
            .contentGrid {
                /* By increasing the minimum, we encourage a 3-column layout on standard desktops. */
                grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
                justify-content: start; /* THIS IS THE FIX */
            }
        }
        .contentCard {
            /* The width is now controlled by the parent grid. */
            /* We remove margin-bottom because the parent's 'gap' property handles all spacing. */
            background-color: #2A2A2A;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.8);
            cursor: pointer;
            transition: transform 0.2s ease;
        }
        .contentCard:hover {
            transform: translateY(-3px);
        }
        .thumbnailPlaceholder {
            width: 100%;
            height: 100px;
            background-color: #444;
            display: flex;
            flex-direction: column; /* To stack text and icon */
            justify-content: center;
            align-items: center;
            position: relative; /* For play icon positioning */
        }
        .thumbnailText {
            color: #FFF;
            font-size: 12px;
            margin-bottom: 5px; /* Space between text and icon */
        }
        .playIcon {
            width: 30px;
            height: 30px;
            fill: #FFD700; /* Gold color for play icon */
            opacity: 0.8;
        }
        .contentTitle {
            font-size: 14px;
            font-weight: bold;
            color: #FFF;
            padding: 10px;
        }
        .more-content-button {
            position: relative;
        }
        .more-content-dropdown {
            position: absolute;
            top: 100%;
            left: 0; /* This is the key change for alignment */
            width: 100%; /* Make the dropdown match the button's width */
            margin-top: 5px;
            background-color: #2A2A2A;
            border: 1px solid #444;
            border-radius: 8px;
            z-index: 100;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }
        .more-content-dropdown .categoryTab {
            width: 100%;
            margin-right: 0;
            margin-bottom: 5px;
            justify-content: center; /* This is the fix */
        }
        .more-content-dropdown .categoryTab:last-child {
            margin-bottom: 0;
        }
        .categoryTabs {
            margin-bottom: 15px;
            height: 40px;
            display: flex;
            /* This property is key for equal spacing of the visible buttons */
            justify-content: space-around;
            align-items: center;
            position: relative; /* Crucial for positioning the dropdown */
        }
        .moreCategoriesMenu {
            position: absolute;
            top: 100%; /* Position it right below the tabs bar */
            right: 0; /* Align to the right side */
            background-color: #1A1A1A;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.7);
            border: 1px solid #333;
            z-index: 100; /* Ensure it appears above other content */
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 200px; /* Give the menu a fixed width */
        }
        .moreMenuItem {
            width: 100%; /* Make each button take the full width of the menu */
            margin-right: 0; /* Override the default margin */
        }

        .categoryTab {
            padding: 8px 15px;
            border-radius: 20px;
            background-color: #3A3A3A;
            margin-right: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 0; /* Prevent tabs from shrinking */
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .categoryTab:hover {
            background-color: #4A4A4A;
        }

        .activeCategoryTab {
            background-color: #FFD700; /* Gold highlight for active category */
        }

        .categoryTabText {
            color: #FFF;
            font-weight: 600;
            white-space: nowrap; /* Prevent text from wrapping inside the button */
        }
        .activeCategoryTabText {
            color: #0A0A0A; /* Dark text on gold background */
        }
        .categoryContent {
            flex: 1;
            /* Removed overflow-y: auto; here as body will handle overall scrolling */
        }
        /* Horizontal Carousel Styles (Featured Highlights) */
        .horizontal-carousel-container {
            width: 100%;
            overflow-x: hidden; /* Hide scrollbar, manage scrolling with JS */
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
            scroll-snap-type: x mandatory; /* Snap to items */
            scroll-behavior: smooth; /* Smooth scrolling animation */
            display: flex; /* Arrange items in a row */
            padding-bottom: 10px; /* Space for scrollbar */
            margin-bottom: 20px; /* Space below carousel */
        }

        .horizontal-carousel-item {
            flex: 0 0 calc(33.33% - 10px); /* Show 3 items, account for margin */
            margin-right: 15px; /* Spacing between items */
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.8);
            scroll-snap-align: start; /* Snap to the start of each item */
            background-color: #2A2A2A; /* Placeholder background */
            display: flex;
            justify-content: center;
            align-items: center;
            color: #FFF;
            font-size: 12px;
            height: 100px; /* Fixed height for carousel images */
        }
        .horizontal-carousel-item:last-child {
            margin-right: 0; /* No margin on the last item */
        }
        .carousel-image {
            width: 100%;
            height: 100%;
            object-fit: cover; /* Cover the item area */
            border-radius: 10px; /* Inherit border-radius */
        }

        /* Vertical Carousel Styles (Live Feed) */
        .vertical-carousel-container {
            width: 100%;
            height: 250px; /* Fixed height for vertical carousel to show ~2 items */
            overflow-y: hidden; /* Hide scrollbar, manage scrolling with JS */
            -webkit-overflow-scrolling: touch; /* Enable touch scrolling */
            scroll-snap-type: y mandatory; /* Snap to items */
            scroll-behavior: smooth; /* Smooth scrolling animation */
            display: flex;
            flex-direction: column; /* Arrange items in a column */
            margin-bottom: 20px;
            background-color: #1A1A1A;
            border-radius: 10px;
            padding: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.8);
        }

        .vertical-carousel-item {
            flex: 0 0 calc(50% - 10px); /* Show 2 items per view, with a gap */
            margin-bottom: 15px; /* Space between items */
            background-color: #2A2A2A;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
            scroll-snap-align: start; /* Snap to the start of each item */
            display: flex;
            align-items: center;
            padding: 10px;
        }

        .vertical-carousel-item:last-child {
            margin-bottom: 0;
        }

        .liveFeedThumbnail {
            width: 80px; /* Fixed width for live feed thumbnails */
            height: 60px; /* Fixed height for live feed thumbnails (16:9 aspect ratio) */
            object-fit: cover;
            border-radius: 8px;
            margin-right: 10px;
        }

        .liveFeedContent {
            flex-grow: 1;
        }

        .liveFeedTitle {
            font-size: 14px;
            font-weight: bold;
            color: #FFF;
            margin-bottom: 5px;
        }

        .liveFeedCreator {
            font-size: 12px;
            color: #AAA;
        }

        .heading {
            font-size: 24px;
            font-weight: bold;
            color: #FFD700;
            margin-bottom: 10px;
            text-align: center;
        }
        .subHeading {
            font-size: 16px;
            color: #FFF;
            margin-bottom: 20px;
            text-align: center;
        }
        .paragraph {
            font-size: 14px;
            color: #CCC;
            margin-bottom: 10px;
            line-height: 20px;
        }
        .button {
            background-color: #FFD700;
            padding: 12px 25px;
            border-radius: 25px;
            align-self: center;
            margin-top: 20px;
            margin-bottom: 10px;
            box-shadow: 0 4px 5px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            border: none;
            transition: background-color 0.3s ease;
        }
        .button:hover {
            background-color: #FFC400;
        }
        .buttonText {
            color: #0A0A0A;
            font-size: 16px;
            font-weight: bold;
            text-align: center;
        }
        .buttonText.light {
            color: #E0E0E0; /* Light grey, near-white text */
        }   
        .smallText {
            font-size: 12px;
            color: #888;
            text-align: center;
            margin-bottom: 10px;
        }
        .listItem {
            font-size: 14px;
            color: #CCC;
            margin-left: 15px;
            margin-bottom: 5px;
        }
        .premiumFeatureCard {
            background-color: #2A2A2A;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
        }
        .premiumFeatureTitle {
            font-size: 18px;
            font-weight: bold;
            color: #FFD700;
            margin-bottom: 5px;
        }
        .premiumFeatureDescription {
            font-size: 14px;
            color: #CCC;
            line-height: 20px;
        }
        .pricingTable {
            background-color: #2A2A2A;
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
        }
        .pricingRow {
            display: flex;
            justify-content: space-between;
            padding-top: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid #333;
        }
        .pricingRow:last-child {
            border-bottom: none; /* No border for the last row */
        }
        .pricingTier {
            font-size: 16px;
            font-weight: bold;
            color: #FFD700;
            flex: 1;
        }
        .pricingFeatures {
            font-size: 14px;
            color: #CCC;
            flex: 2;
            text-align: left;
            margin-left: 10px;
        }
        .pricingPrice {
            font-size: 16px;
            font-weight: bold;
            color: #FFF;
            flex: 1;
            text-align: right;
        }
        .contactInfo {
            font-size: 14px;
            color: #CCC;
            margin-bottom: 5px;
        }
        .messageBox {
            position: fixed; /* Use fixed for overlay */
            bottom: 100px; /* Above navigation bar */
            left: 50%;
            transform: translateX(-50%); /* Center horizontally */
            background-color: rgba(0, 0, 0, 0.8);
            padding: 12px 20px;
            border-radius: 8px;
            z-index: 4000; /* THIS IS THE FIX: Ensures it appears above all modals */
            opacity: 1;
            transition: opacity 0.3s ease-in-out;
            pointer-events: none; /* Allow clicks to pass through */
            max-width: 90%;
        }
        .messageBox.hidden {
            opacity: 0;
        }
        .messageText {
            color: #FFF;
            text-align: center;
            font-size: 14px;
        }
        /* Video Modal Styles */
        .videoModalOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .videoModalContent {
            background-color: #1A1A1A;
            border-radius: 0; /* Removed for full screen effect */
            width: 100vw; /* Make it take 100% of viewport width */
            height: 100vh; /* Make it take 100% of viewport height */
            max-width: 1200px; /* Cap maximum width for very large screens */
            max-height: 800px; /* Cap maximum height for very large screens to maintain aspect ratio */
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
            position: relative;
            display: flex; /* Enable flex for vertical centering of iframe */
            flex-direction: column;
            justify-content: center; /* Center content vertically */
            align-items: center; /* Center content horizontally */
        }
        .videoIframeContainer {
            position: relative;
            width: 100%;
            padding-bottom: 56.25%; /* 16:9 Aspect Ratio (height relative to width) */
            height: 0; /* Important for padding-bottom trick */
            overflow: hidden;
        }
        .videoIframeContainer iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
        }
        .videoModalContent.vertical {
            max-width: 450px; /* Optimal width for phone-like vertical view */
            height: 100vh;
            max-height: 100vh; /* Ensure it takes full viewport height */
            justify-content: center; /* Center the iframe vertically */
        }

        .videoIframeContainer.vertical {
            padding-bottom: 177.77%; /* 9:16 aspect ratio (16 / 9 * 100) */
        }
        .closeButton {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(255, 255, 255, 0.2);
            color: #FFF;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 10; /* Ensure it's above the iframe */
        }

        /* Styles for buttons at the top of the Home screen */
        .topRightButtonContainer {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            gap: 10px; /* Space between buttons */
            z-index: 10;
        }

        .topButton {
            background-color: #FFD700; /* Gold color */
            color: #0A0A0A; /* Dark text */
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px; /* Smaller font for a compact button */
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            border: none;
            transition: background-color 0.3s ease;
        }
        .topButton:hover {
            background-color: #FFC400;
        }


        /* Styles for Creator Campaign Cards */
        .campaignCard {
            background-color: #2A2A2A;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
        }
        .campaignTitle {
            font-size: 18px;
            font-weight: bold;
            color: #FFD700;
            margin-bottom: 5px;
        }
        .campaignCreator {
            font-size: 14px;
            color: #CCC;
            margin-bottom: 10px;
        }
        .campaignDescription {
            font-size: 14px;
            color: #AAA;
            line-height: 1.5;
            margin-bottom: 10px;
        }
        .campaignProgressContainer {
            width: 100%;
            background-color: #444;
            border-radius: 5px;
            height: 10px;
            margin-bottom: 5px;
            overflow: hidden; /* Ensure progress bar stays within bounds */
        }
        .campaignProgressBar {
            height: 100%;
            background-color: #FFD700;
            border-radius: 5px;
            transition: width 0.5s ease-in-out;
        }
        .campaignStats {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #CCC;
            width: 100%;
        }
        .campaignGoal, .campaignRaised {
            font-weight: bold;
            color: #FFF;
        }
        .campaignButton {
            background-color: #FFD700;
            padding: 10px 15px;
            border-radius: 20px;
            color: #0A0A0A;
            font-weight: bold;
            text-align: center;
            cursor: pointer;
            border: none;
            transition: background-color 0.3s ease;
        }
        .campaignButton:hover {
            background-color: #FFC400;
        }

        /* Styles for Creator Sign Up Form */
        .formGroup {
            margin-bottom: 15px;
        }
        .formLabel {
            display: block;
            font-size: 14px;
            color: #FFF;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .formInput, .formTextarea {
            width: calc(100% - 20px); /* Account for padding */
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #555;
            background-color: #333;
            color: #FFF;
            font-size: 14px;
        }
        .formTextarea {
            resize: vertical; /* Allow vertical resizing */
            min-height: 80px;
        }
        .checkboxGroup {
            margin-bottom: 15px;
        }
        .checkboxLabel {
            display: block;
            font-size: 14px;
            color: #FFF;
            margin-bottom: 8px;
            font-weight: bold;
        }
        .checkboxItem {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .checkboxItem input[type="checkbox"] {
            margin-right: 8px;
            width: 18px; /* Larger checkbox for touch */
            height: 18px;
            accent-color: #FFD700; /* Highlight checkbox */
        }
        .termsText {
            font-size: 12px;
            color: #AAA;
            margin-top: 10px;
            line-height: 1.4;
        }
        .termsLink {
            color: #FFD700;
            text-decoration: none;
            font-weight: bold;
        }
        .termsLink:hover {
            text-decoration: underline;
        }

        /* Styles for Creator Dashboard */
        .dashboardSection {
            background-color: #2A2A2A;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
        }
        .dashboardSectionTitle {
            font-size: 18px;
            font-weight: bold;
            color: #FFD700;
            margin-bottom: 10px;
        }
        .dashboardItem {
            font-size: 14px;
            color: #CCC;
            margin-bottom: 8px;
            line-height: 1.4;
        }
        .dashboardButton {
            background-color: #0A0A0A; /* Changed to black */
            padding: 8px 15px;
            border-radius: 20px;
            color: #FFD700; /* Changed to gold */
            font-weight: bold;
            cursor: pointer;
            border: 1px solid #FFD700; /* Added a gold border for definition */
            transition: background-color 0.3s ease, color 0.3s ease;
            margin-top: 10px;
            margin-right: 10px;
        }
        .dashboardButton:hover {
            background-color: #FFD700; /* Gold background on hover */
            color: #0A0A0A; /* Black text on hover */
        }
        .dashboardContentList {
            margin-top: 10px;
            padding-left: 0; /* Remove default ul padding */
            list-style: none; /* Remove bullet points */
        }
        .dashboardContentListItem {
            background-color: #3A3A3A;
            padding: 8px 12px;
            border-radius: 8px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
            color: #FFF;
        }
        .dashboardContentListItem span {
            flex-grow: 1;
        }
        .dashboardContentListItem .actionButton {
            background-color: #555;
            color: #FFF;
            border: none;
            padding: 5px 10px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 12px;
            margin-left: 10px;
            transition: background-color 0.2s ease;
        }
        .dashboardContentListItem .actionButton:hover {
            background-color: #777;
        }

        /* New styles for video link sections in dashboard */
        .videoLinkSection {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #333;
        }
        .videoLinkSection:last-child {
            border-bottom: none;
            padding-bottom: 0;
        }
        .videoLinkSection .formLabel {
            margin-bottom: 10px;
            font-size: 16px;
            color: #FFD700;
        }
        .videoInputContainer {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        .videoInputContainer .formInput {
            flex-grow: 1;
        }
        .videoThumbnailContainer {
            position: relative;
            width: 100%;
            height: 150px; /* Fixed height for thumbnails */
            background-color: #444;
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 10px;
            cursor: pointer; /* Indicate clickable */
        }
        .videoThumbnail {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .videoThumbnailOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.4);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .thumbnailPlayIcon {
            width: 40px;
            height: 40px;
            fill: #FFF;
            opacity: 0.9;
        }
        .videoActions {
            display: flex;
            justify-content: flex-end; /* Align buttons to the right */
            gap: 10px;
        }
        .videoActions .actionButton {
            background-color: #FFD700;
            color: #0A0A0A;
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: bold;
            cursor: pointer;
            border: none;
            transition: background-color 0.3s ease;
        }
        .videoActions .actionButton.remove {
            background-color: #DC3545; /* Red for remove */
            color: #FFF;
        }
        .videoActions .actionButton:hover {
            background-color: #FFC400;
        }
        .videoActions .actionButton.remove:hover {
            background-color: #C82333;
        }
        /* New styles for login form */
        .loginForm {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .loginForm .button {
            width: 100%;
        }
        /* New styling for section title with aligned button */
        .sectionHeaderWithButton {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px; /* Space below the header container */
            margin-top: 20px;
        }
        .sectionHeaderWithButton .sectionTitle {
            margin: 0; /* Remove default margins from p tag when in flex container */
        }
        /* Adjust .topButton styles for this context if needed, or create a new class */
        .sectionHeaderButton {
            background-color: #FFD700; /* Gold color */
            color: #0A0A0A; /* Dark text */
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px; /* Smaller font for a compact button */
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            border: none;
            transition: background-color 0.3s ease;
        }
        .sectionHeaderButton:hover {
            background-color: #FFC400;
        }

        .imageAdjustModalOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95); /* More opaque */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000; /* Higher z-index than video modal */
            flex-direction: column;
            gap: 20px;
        }

        .imageAdjustModalContent {
            background-color: #1A1A1A;
            border-radius: 15px;
            padding: 20px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .canvasContainer {
            position: relative;
            width: 200px; /* Fixed size for the canvas view */
            height: 200px;
            border-radius: 50%;
            overflow: hidden;
            border: 2px solid #FFD700;
            background-color: #333;
            margin-bottom: 20px;
            cursor: grab;
        }

        .canvasContainer.dragging {
            cursor: grabbing;
        }

        canvas {
            display: block;
            touch-action: none;
        }

        .modalButtons {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }

        .modalButton {
            background-color: #FFD700;
            color: #0A0A0A;
            padding: 10px 20px;
            border-radius: 25px;
            font-weight: bold;
            cursor: pointer;
            border: none;
            transition: background-color 0.3s ease;
        }

        .modalButton:hover {
            background-color: #FFC400;
        }

        .modalButton.cancel {
            background-color: #555;
            color: #FFF;
        }

        .modalButton.cancel:hover {
            background-color: #777;
        }

        /* Styles for Zoom Controls (We will add these later if needed) */
        .zoomControls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            align-items: center;
        }
        .zoomButton {
            background-color: #3A3A3A;
            color: #FFD700;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 1px solid #FFD700;
            font-size: 24px;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .zoomButton:hover {
            background-color: #4A4A4A;
        }

        /* Profile Picture Adjustment Modal Styles */
        .imageAdjustModalOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95); /* More opaque */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000; /* Higher z-index than video modal */
            flex-direction: column;
            gap: 20px;
        }

        .imageAdjustModalContent {
            background-color: #1A1A1A;
            border-radius: 15px;
            padding: 20px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .canvasContainer {
            position: relative;
            width: 200px; /* Fixed size for the canvas view */
            height: 200px;
            border-radius: 50%;
            overflow: hidden;
            border: 2px solid #FFD700;
            background-color: #333;
            margin-bottom: 20px;
            cursor: grab;
        }

        .canvasContainer.dragging {
            cursor: grabbing;
        }

        canvas {
            display: block;
            touch-action: none;
        }

        .modalButtons {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }

        .modalButton {
            background-color: #FFD700;
            color: #0A0A0A;
            padding: 10px 20px;
            border-radius: 25px;
            font-weight: bold;
            cursor: pointer;
            border: none;
            transition: background-color 0.3s ease;
        }

        .modalButton:hover {
            background-color: #FFC400;
        }

        .modalButton.cancel {
            background-color: #555;
            color: #FFF;
        }

        .modalButton.cancel:hover {
            background-color: #777;
        }

        /* Styles for Zoom Controls */
        .zoomControls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            align-items: center;
        }
        .zoomButton {
            background-color: #3A3A3A;
            color: #FFD700;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 1px solid #FFD700;
            font-size: 24px;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .zoomButton:hover {
            background-color: #4A4A4A;
        }

        /* New styles for all campaigns list */
        .allCampaignsList {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 20px;
        }
        .allCampaignsListItem {
            background-color: #2A2A2A;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: flex-start; /* Align items to the top */
            cursor: pointer; /* Pointer to indicate clickable for the whole card */
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .allCampaignsListItem:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.7);
        }
        .campaignListImagePlaceholder { /* New class for the image/button container */
            width: 80px;
            height: 80px;
            object-fit: cover;
            border-radius: 8px;
            margin-right: 15px;
            flex-shrink: 0;
            background-color: #3A3A3A; /* Background for the placeholder/button */
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative; /* For the button text */
            overflow: hidden; /* To handle background image overflow if it's large */
            background-size: cover; /* Make background image cover the area */
            background-position: center; /* Center the background image */
            box-shadow: inset 0 0 5px rgba(0,0,0,0.5); /* Subtle inner shadow */
        }
        .campaignListProjectButton { /* New class for the actual clickable button inside */
            background-color: rgba(255, 215, 0, 0.8); /* Semi-transparent gold */
            color: #0A0A0A;
            padding: 5px 8px;
            border-radius: 5px;
            font-size: 10px;
            font-weight: bold;
            text-align: center;
            cursor: pointer;
            border: none;
            transition: background-color 0.2s ease;
            position: absolute; /* Position over the background image */
            bottom: 5px; /* Place it at the bottom */
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap; /* Prevent text wrapping */
            text-shadow: 0 0 3px rgba(0,0,0,0.5);
            line-height: 1; /* Adjust line height for smaller button */
        }
        .campaignListProjectButton:hover {
            background-color: #FFC400; /* Solid gold on hover */
        }

        .campaignListContent {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        .campaignListTitle {
            font-size: 16px;
            font-weight: bold;
            color: #FFD700;
            margin-bottom: 5px;
        }
        .campaignListCreator {
            display: flex;
            align-items: center;
            font-size: 12px;
            color: #CCC;
            margin-bottom: 8px;
        }
        .campaignListCreatorProfilePic {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            object-fit: cover;
            margin-right: 8px;
            border: 1px solid #FFD700; /* Small border for visibility */
        }
        .campaignListDescription {
            font-size: 13px;
            color: #AAA;
            line-height: 1.4;
            display: -webkit-box;
            -webkit-line-clamp: 2; /* Show only 2 lines */
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 10px;
        }
        .campaignListStats {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #CCC;
            width: 100%;
        }
        .campaignListGoal, .campaignListRaised {
            font-weight: bold;
            color: #FFF;
        }
        .fee-info-container {
            position: relative;
            display: inline-flex; /* To keep icon next to text */
            align-items: center;
            margin-left: 5px; /* Space from the "Raised" text */
        }
        .fee-info-icon {
            font-size: 10px; /* Smaller icon */
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background-color: #FFD700;
            color: #0A0A0A;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            cursor: pointer;
        }
        .fee-info-tooltip {
            position: absolute;
            bottom: 100%; /* Position above the icon */
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.9);
            color: #FFF;
            padding: 8px;
            border-radius: 5px;
            font-size: 10px;
            white-space: normal; /* Allow text to wrap */
            width: 180px; /* Fixed width for tooltip */
            text-align: left;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
            pointer-events: none; /* Allow clicks to pass through */
            z-index: 10; /* Ensure it's above other elements */
            margin-bottom: 5px; /* Space between icon and tooltip */
        }
        .fee-info-container:hover .fee-info-tooltip {
            opacity: 1;
            visibility: visible;
        }


        /* Campaign Details Screen Specific Styles */
         .campaignDetailHeader {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 20px;
        }
        .campaignDetailImage {
            width: 100%;
            max-width: 350px; /* Max width for images */
            height: 200px;
            /* --- START: CORRECTED IMAGE FIT --- */
            object-fit: contain;
            background-color: #1A1A1A; /* Fills letterbox space with a dark color */
            /* --- END: CORRECTED IMAGE FIT --- */
            border-radius: 10px;
            margin-bottom: 15px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
        }
        /* Style to hide image if it fails to load */
        .campaignDetailImage.hidden {
            display: none;
        }

        .campaignDetailTitle {
            font-size: 22px;
            font-weight: bold;
            color: #FFD700;
            text-align: center;
            margin-bottom: 10px;
        }
        .campaignDetailCreator {
            display: flex;
            align-items: center;
            font-size: 15px;
            color: #CCC;
            margin-bottom: 15px;
        }
        .campaignDetailCreatorProfilePic {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            object-fit: cover;
            margin-right: 10px;
            border: 2px solid #FFD700;
        }
        .campaignDetailDescription {
            font-size: 14px;
            color: #AAA;
            line-height: 1.6;
            margin-bottom: 20px;
            background-color: #1A1A1A;
            padding: 15px;
            border-radius: 10px;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.3);
        }
        .campaignDetailStats {
            display: flex;
            justify-content: space-around;
            width: 100%;
            margin-bottom: 20px;
            padding: 10px 0;
            border-top: 1px solid #333;
            border-bottom: 1px solid #333;
        }
        .campaignDetailStatItem {
            text-align: center;
            font-size: 14px;
            color: #CCC;
        }
        .campaignDetailStatValue {
            font-size: 18px;
            font-weight: bold;
            color: #FFF;
        }
        .campaignDetailProgressBarContainer {
            width: 80%;
            background-color: #444;
            border-radius: 5px;
            height: 12px;
            margin-bottom: 10px;
            overflow: hidden;
            align-self: center; /* Center the progress bar */
        }
        .campaignDetailProgressBar {
            height: 100%;
            background-color: #FFD700;
            border-radius: 5px;
        }

        /* Admin Dashboard Specific Styles */
        .adminActionButton {
            background-color: #FFD700;
            color: #0A0A0A;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            border: none;
            margin-left: 10px;
            transition: background-color 0.2s ease;
        }
        .adminActionButton.approve {
            background-color: #008000; /* Green for approve */
            color: #FFF;
        }
        .adminActionButton.reject {
            background-color: #DC3545; /* Red for reject */
            color: #FFF;
        }
        .adminActionButton:hover {
            filter: brightness(1.1);
        }
        .adminActionButton.approve:hover {
            background-color: #006400;
        }
        .adminActionButton.reject:hover {
            background-color: #C82333;
        }
        .adminDashboardItem {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: #3A3A3A;
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            color: #FFF;
            font-size: 14px;
        }
        .adminDashboardItemTitle {
            flex-grow: 1;
            font-weight: bold;
        }
        .adminDashboardItemStatus {
            font-size: 12px;
            margin-left: 10px;
            color: #FFD700; /* Default for pending */
        }
        .adminDashboardItemStatus.active {
            color: #00FF00;
        }
        .adminDashboardItemStatus.rejected {
            color: #DC3545;
        }
.admin-nav-button {
    background-color: #3A3A3A;
    color: #E0E0E0;
    padding: 8px 18px;
    border-radius: 20px;
    font-weight: bold;
    font-size: 14px;
    cursor: pointer;
    border: 1px solid #555;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    transition: all 0.2s ease-in-out;
    margin: 0 !important; /* Override any lingering margin from other button classes */
}

.admin-nav-button:hover {
    background-color: #4A4A4A;
    border-color: #777;
    transform: scale(1.05);
}

.admin-nav-button.active {
    background-color: #FFD700;
    color: #0A0A0A;
    border-color: #FFD700;
    transform: translateY(-2px);
    box-shadow: 0 4px 15px rgba(255, 215, 0, 0.2);
}

.admin-nav-label {
    font-size: 14px;
    margin: 0;
    color: #AAA;
    font-weight: bold;
    flex-shrink: 0;
    width: 70px; /* Aligns the button groups neatly */
    text-align: right;
    margin-right: 5px;
}

        /* --- START: New Donation Ticker Styles --- */
        .donationTickerContainer {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 1500; /* Above most content, below modals */
            background-color: rgba(10, 10, 10, 0.85);
            border: 1px solid #FFD700;
            border-radius: 10px;
            padding: 12px 18px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            max-width: 300px;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.5s ease-in-out, transform 0.5s ease-in-out;
            pointer-events: none; /* Make it non-interactive */
        }

        .donationTickerContainer.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .tickerIcon {
            width: 20px;
            height: 20px;
            fill: #FFD700;
            margin-right: 10px;
            vertical-align: middle;
        }

        .tickerText {
            color: #FFF;
            font-size: 14px;
            line-height: 1.4;
            display: inline-block;
            vertical-align: middle;
        }

        .tickerText strong {
            color: #FFD700;
            font-weight: bold;
        }
        /* --- END: New Donation Ticker Styles --- */
        /* Confirmation Modal Styles */
        .confirmationModalOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000; /* Higher than any other modal */
        }

        .confirmationModalContent {
            background-color: #1A1A1A;
            border-radius: 15px;
            padding: 25px;
            width: 90%;
            max-width: 350px;
            box-shadow: 0 0 25px rgba(0, 0, 0, 0.7);
            text-align: center;
            color: #FFF;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .confirmationModalTitle {
            font-size: 20px;
            font-weight: bold;
            color: #FFD700;
            margin-bottom: 10px;
        }

        .confirmationModalMessage {
            font-size: 15px;
            color: #CCC;
            line-height: 1.5;
        }

        .confirmationModalButtons {
            display: flex;
            justify-content: space-around;
            gap: 15px;
            margin-top: 15px;
        }

        .confirmationButton {
            padding: 10px 20px;
            border-radius: 20px;
            font-weight: bold;
            cursor: pointer;
            border: none;
            transition: background-color 0.3s ease;
            flex-grow: 1;
        }

        .confirmationButton.confirm {
            background-color: #008000; /* Green for confirm */
            color: #FFF;
        }

        .confirmationButton.confirm:hover {
            background-color: #006400;
        }

        .confirmationButton.cancel {
            background-color: #DC3545; /* Red for cancel */
            color: #FFF;
        }

        .confirmationButton.cancel:hover {
            background-color: #C82333;
        }

        .admin-toggle-button:hover {
            background-color: #FFC400; /* Slightly darker gold on hover */
            transform: scale(1.05); /* Slight scale effect on hover */
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.5); /* Enhanced shadow on hover */
        }

        /* --- START: Definitive Button Text Color Fix --- */
        .buttonText.light {
            color: #E0E0E0; /* Light grey, near-white text */
        }
        /* --- END: Definitive Button Text Color Fix --- */
        .button[style*="#3A3A3A"], /* Targets inline style for #3A3A3A */
        .button[style*="#555"],    /* Targets inline style for #555 */
        .modalButton.cancel {
            color: #E0E0E0 !important; /* !important ensures this overrides other color rules */
        }

        .dashboardContentListItem .actionButton {
             background-color: #555;
             color: #E0E0E0; /* Set default text color */
        }

        .dashboardContentListItem .actionButton:hover {
            background-color: #777;
            color: #FFF !important; /* Ensure hover text is bright white */
        }
        /* --- END: Consolidated Grey Button Text Color Fix --- */
        /* New styles for Upload Progress Bar */
        .uploadProgressContainer {
            width: 100%;
            background-color: #444;
            border-radius: 5px;
            height: 12px;
            margin-top: 15px;
            overflow: hidden;
        }
        .uploadProgressBar {
            height: 100%;
            background-color: #008000; /* Green for progress */
            border-radius: 5px;
            transition: width 0.2s ease-in-out;
            text-align: center;
            line-height: 12px;
            font-size: 10px;
            color: #FFF;
            font-weight: bold;
        }


                /* NEW STYLES for User Search Screen */
        .user-search-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 20px;
        }
        .user-search-item {
            background-color: #2A2A2A;
            border-radius: 10px;
            padding: 15px;
            display: flex;
            align-items: center;
            gap: 15px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.5);
        }
        .user-search-pfp {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid #FFD700;
        }
        .user-search-info {
            flex-grow: 1;
        }
        .user-search-name {
            font-size: 16px;
            font-weight: bold;
            color: #FFF;
        }
        .user-search-role {
            font-size: 12px;
            color: #AAA;
        }
        .user-search-campaign-badge {
            background-color: #00FF00;
            color: #0A0A0A;
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: bold;
            margin-left: 10px;
        }
        
            /* ====================================================================== */
        /* ============ START: ADD THIS NEW CSS FOR LIBRARY CONTROLS ============ */
        /* ====================================================================== */

        .library-item-card {
            display: flex;
            flex-direction: column; /* Stacks content and actions */
            align-items: stretch;
            background-color: #3A3A3A;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 10px;
            position: relative; /* Crucial for positioning the pin icon */
        }

        .library-item-content {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .library-item-thumbnail {
            width: 120px;
            height: 68px;
            object-fit: cover;
            border-radius: 5px;
            cursor: pointer;
            flex-shrink: 0; /* Prevents image from shrinking */
        }

        .library-item-info {
            flex-grow: 1;
            min-width: 0; /* Prevents text overflow issues in flexbox */
        }
        
        .library-item-title {
            font-size: 14px;
            font-weight: bold;
            color: #FFF;
            /* Truncate long titles */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .library-item-status {
            font-size: 12px;
            color: #CCC;
        }

        .pin-icon-button {
            position: absolute;
            top: 5px;
            right: 5px;
            background-color: rgba(10, 10, 10, 0.6);
            border: 1px solid #888;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s, transform 0.2s;
            z-index: 5; /* Ensures it's above the image */
        }
        
        .pin-icon-button:hover {
            transform: scale(1.1);
            background-color: rgba(10, 10, 10, 0.8);
        }

        .pin-icon-button svg {
            width: 20px;
            height: 20px;
            transition: fill 0.2s;
        }

        .pin-icon-button .pin-svg {
            fill: #AAA;
        }
        
        .pin-icon-button.pinned .pin-svg {
            fill: #FFD700; /* Gold when pinned */
        }
        
        .pin-icon-button.pinned {
             border-color: #FFD700;
        }

        /* ====================================================================== */
        /* ============= END: ADD THIS NEW CSS FOR LIBRARY CONTROLS ============= */
        /* ====================================================================== */
        
        /* NEW STYLES for Creator Dashboard Campaign List */
        .creator-campaign-list-item {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 10px;
            background-color: #3A3A3A;
            border-radius: 8px;
            margin-bottom: 10px;
        }
        .creator-campaign-thumbnail {
            width: 80px;
            height: 50px;
            object-fit: cover;
            border-radius: 5px;
        }
        .creator-campaign-info {
            flex-grow: 1;
        }
        .creator-campaign-title {
            font-size: 14px;
            font-weight: bold;
            color: #FFF;
        }
        .creator-campaign-status {
            font-size: 12px;
        }
        .status-pending { color: #FFD700; }
        .status-active { color: #00FF00; }
        .status-rejected { color: #DC3545; }
        .status-ended { color: #888; }
        .status-cancelled { color: #AAA; }

         /* START: New Carousel Navigation Button Styles */
            .carousel-wrapper {
            position: relative; /* Establishes a positioning context for the buttons */
            width: 100%;
        }

            /* ====================================================================== */
        /* ======== START: ADD THIS NEW CSS FOR PUBLIC PROFILE LIBRARY ======== */
        /* ====================================================================== */

        .profile-content-section {
            margin-top: 25px;
        }

        .pinned-item-card {
            background-color: #3A3A3A; /* Slightly lighter to stand out */
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 10px rgba(0,0,0,0.7);
            border: 1px solid #FFD700; /* Gold border for pinned items */
            position: relative; /* For the pin icon */
            grid-column: span 2; /* Pinned items take full width on mobile */
        }
        
        /* On larger screens, allow 2 or 3 pinned items per row */
        @media (min-width: 768px) {
             .pinned-item-card {
                grid-column: span 1;
            }
        }


        .pinned-item-thumbnail {
            width: 100%;
            height: 150px; /* Taller thumbnail for featured items */
            object-fit: cover;
            display: block;
        }
        
        .pinned-indicator-icon {
            position: absolute;
            top: 8px;
            left: 8px;
            background-color: rgba(255, 215, 0, 0.8);
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(2px);
        }

        .pinned-indicator-icon svg {
            width: 16px;
            height: 16px;
            fill: #0A0A0A;
        }
        
        /* Re-using .contentGrid for the "All Content" section */
        /* Re-using .contentCard for the items within it */
        
        .load-more-container {
            display: flex;
            justify-content: center;
            padding: 20px 0;
        }

        /* ====================================================================== */
        /* ========= END: ADD THIS NEW CSS FOR PUBLIC PROFILE LIBRARY ========= */
        /* ====================================================================== */

        .carousel-nav-btn {
            position: absolute;
            z-index: 10;
            background-color: rgba(10, 10, 10, 0.6); /* Semi-transparent dark background */
            color: #FFD700; /* Gold icon color */
            border: 1px solid #FFD700;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            font-size: 20px; /* Adjust size of arrow characters */
            line-height: 1; /* Ensure vertical centering of arrows */
        }

        .carousel-nav-btn:hover {
            background-color: rgba(255, 215, 0, 0.8); /* Semi-transparent gold on hover */
            color: #0A0A0A; /* Dark icon color on hover */
            transform: scale(1.1);
        }

        /* Positioning for Horizontal Carousel Buttons */
        .carousel-nav-btn.prev-horizontal {
            top: 50%;
            left: 5px;
            transform: translateY(-50%);
        }

        .carousel-nav-btn.next-horizontal {
            top: 50%;
            right: 5px;
            transform: translateY(-50%);
        }

        /* Positioning for Vertical Carousel Buttons */
        .carousel-nav-btn.prev-vertical {
            left: 50%;
            top: 5px;
            transform: translateX(-50%);
        }

        .carousel-nav-btn.next-vertical {
            left: 50%;
            bottom: 5px;
            transform: translateX(-50%);
        }

        .header-live-button {
    padding: 6px 12px;
    border-radius: 20px;
    font-weight: bold;
    font-size: 14px;
    cursor: pointer;
    border: none;
    box-shadow: 0 2px 8px rgba(0,0,0,0.5);
    display: inline-flex; /* Allows it to sit nicely with text */
    align-items: center;
    gap: 8px;
    transition: background-color 0.3s, transform 0.2s;
    margin-top: 10px; /* Gives space below the tagline */
}
.header-live-button:hover {
    transform: scale(1.05); /* Simpler hover effect */
}
.header-live-button.countdown {
    background-color: #008000; /* Green */
    color: #FFF;
}
.header-live-button.live {
    background-color: #DC3545; /* Red */
    color: #FFF;
    animation: pulse 1.5s infinite;
}
@keyframes pulse {
    0% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7); }
    70% { box-shadow: 0 0 10px 10px rgba(220, 53, 69, 0); }
    100% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0); }
}
       /* START: New Leaderboard Styles */
        .leaderboard-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 20px;
        }
        .leaderboard-item {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 10px;
            background-color: #2A2A2A;
            border-radius: 10px;
            border-left: 5px solid transparent;
            transition: background-color 0.3s;
        }
        .leaderboard-item.rank-1 {
            background-color: rgba(255, 215, 0, 0.15);
            border-left-color: #FFD700;
        }
        .leaderboard-item.rank-2 {
            background-color: rgba(192, 192, 192, 0.15);
            border-left-color: #C0C0C0;
        }
        .leaderboard-item.rank-3 {
            background-color: rgba(205, 127, 50, 0.15);
            border-left-color: #CD7F32;
        }
        .leaderboard-rank {
            font-size: 20px;
            font-weight: bold;
            color: #FFF;
            width: 40px;
            text-align: center;
            flex-shrink: 0;
        }
        .leaderboard-pfp {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid #555;
        }
        .leaderboard-info {
            flex-grow: 1;
        }
        .leaderboard-name {
            font-size: 16px;
            font-weight: bold;
            color: #FFF;
        }
        .leaderboard-clicks-container {
            text-align: right;
        }
        .leaderboard-clicks {
            font-size: 20px;
            font-weight: bold;
            color: #FFD700;
        }
        .leaderboard-clicks-label {
            font-size: 12px;
            color: #AAA;
        }
        .leaderboard-tabs {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
        }
        /* END: New Leaderboard Styles */
        /* START: New Follow System Styles */
        .follow-button {
            padding: 8px 20px;
            border-radius: 20px;
            font-weight: bold;
            cursor: pointer;
            border: 2px solid #FFD700;
            transition: background-color 0.2s, color 0.2s;
        }
        .follow-button.following {
            background-color: transparent;
            color: #FFD700;
        }
        .follow-button.not-following {
            background-color: #FFD700;
            color: #0A0A0A;
        }
        .follow-stats {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 10px;
        }
        .follow-stat-item {
            text-align: center;
        }
        .follow-stat-value {
            font-size: 16px;
            font-weight: bold;
            color: #FFF;
        }
        .follow-stat-label {
            font-size: 12px;
            color: #AAA;
        }
        /* END: New Follow System Styles */
        
            /* ====================================================================== */
        /* ============ START: ADD THIS ENTIRE NEW CSS BLOCK ==================== */
        /* ====================================================================== */

        /* Custom Scrollbar Styles for a more integrated look */
        ::-webkit-scrollbar {
            width: 8px; /* Makes the scrollbar slimmer */
        }

        ::-webkit-scrollbar-track {
            background: #1A1A1A; /* Sets the track color to match our theme */
        }

        ::-webkit-scrollbar-thumb {
            background-color: #4A4A4A; /* A subtle, darker grey for the scrollbar itself */
            border-radius: 4px;      /* Rounded corners for the scrollbar */
            border: 2px solid #1A1A1A; /* Creates a padding effect around the thumb */
        }

        ::-webkit-scrollbar-thumb:hover {
            background-color: #FFD700; /* On hover, the scrollbar turns gold */
        }
        
        /* ====================================================================== */
        /* =========== START: ADD THIS ENTIRE NEW CSS BLOCK FOR PFP MODAL ========= */
        /* ====================================================================== */

        .pfpModalOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85); /* Dark, focused background */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2500; /* Above other content, below confirmation modals */
        }

        .pfpModalContent {
            position: relative;
            max-width: 90vw;   /* Ensures image is not too wide on desktop */
            max-height: 80vh;  /* Ensures image is not too tall on any screen */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .pfpModalImage {
            max-width: 100%;
            max-height: 100%;
            display: block;
            border-radius: 10px; /* Soft rounded corners for the image */
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.5); /* A nice shadow for depth */
        }
            .likesModalOverlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.85);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 2600; /* Above PFP modal */
}

.likesModalContent {
    background-color: #1A1A1A;
    border-radius: 15px;
    padding: 20px;
    width: 90%;
    max-width: 400px;
    max-height: 70vh;
    box-shadow: 0 0 25px rgba(0, 0, 0, 0.7);
    display: flex;
    flex-direction: column;
}

.likesModalHeader {
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid #333;
    padding-bottom: 10px;
    margin-bottom: 15px;
}

.likesModalTitle {
    font-size: 18px;
    font-weight: bold;
    color: #FFF;
}

.likesList {
    flex-grow: 1;
    overflow-y: auto;
    padding-right: 10px; /* Space for scrollbar */
}

.likeItem {
    display: flex;
    align-items: center;
    gap: 15px;
    padding: 10px 5px;
    cursor: pointer;
    border-radius: 8px;
    transition: background-color 0.2s ease;
}

.likeItem:hover {
    background-color: #2A2A2A;
}

.likeItemPfp {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    object-fit: cover;
    border: 1px solid #FFD700;
}

.likeItemName {
    font-size: 15px;
    font-weight: 600;
    color: #E0E0E0;
}
    .commentsModalContent {
    background-color: #1A1A1A;
    border-radius: 15px;
    padding: 20px;
    width: 90%;
    max-width: 500px;
    max-height: 85vh; /* Taller than likes modal */
    box-shadow: 0 0 25px rgba(0, 0, 0, 0.7);
    display: flex;
    flex-direction: column;
}

.commentsList {
    flex-grow: 1;
    overflow-y: auto;
    padding-right: 10px;
}

.commentItem {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
}

.commentPfp {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    object-fit: cover;
    flex-shrink: 0;
    cursor: pointer;
}

.commentContent {
    flex-grow: 1;
    background-color: #2A2A2A;
    border-radius: 10px;
    padding: 8px 12px;
}

.commentHeader {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 4px;
}

.commentAuthor {
    font-size: 13px;
    font-weight: bold;
    color: #FFD700;
    cursor: pointer;
}

.commentTimestamp {
    font-size: 11px;
    color: #888;
}

.commentText {
    font-size: 14px;
    color: #E0E0E0;
    white-space: pre-wrap; /* Respects line breaks */
    word-wrap: break-word; /* Prevents long words from overflowing */
}

.commentActions {
    margin-top: 5px;
    text-align: right;
}

.replyButton {
    background: none;
    border: none;
    color: #AAA;
    font-size: 12px;
    font-weight: bold;
    cursor: pointer;
}
.replyButton:hover {
    color: #FFF;
}

.commentInputContainer {
    flex-shrink: 0;
    padding-top: 15px;
    border-top: 1px solid #333;
    margin-top: 10px;
}

.commentTextarea {
    width: 100%;
    min-height: 60px;
    padding: 10px;
    border-radius: 8px;
    border: 1px solid #555;
    background-color: #333;
    color: #FFF;
    font-size: 14px;
    resize: vertical;
}

.commentSubmitBar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 10px;
}

.emojiPicker {
    display: flex;
    gap: 8px;
}

.emojiButton {
    background: none;
    border: none;
    font-size: 20px;
    cursor: pointer;
    transition: transform 0.2s;
}

.emojiButton:hover {
    transform: scale(1.2);
}

.replyingToBanner {
    background-color: rgba(255, 215, 0, 0.1);
    border-left: 3px solid #FFD700;
    padding: 5px 10px;
    margin-bottom: 10px;
    border-radius: 4px;
    font-size: 12px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

        /* We can reuse the existing .closeButton style for consistency! */

        /* ====================================================================== */
        /* ============ END: ADD THIS ENTIRE NEW CSS BLOCK FOR PFP MODAL ========== */
        /* ====================================================================== */

    </style>
</head>
<body>
    <div id="root"></div>

    <!-- 1. Initialize Firebase SDKs (module type) - Must be loaded before React components that use them -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, onAuthStateChanged, signInWithCustomToken, signInAnonymously, sendEmailVerification, sendPasswordResetEmail } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, updateDoc, collection, addDoc, query, orderBy, onSnapshot, where, getDocs, deleteDoc, limit, increment, runTransaction } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getStorage, ref, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-storage.js";
        import { getAnalytics, logEvent, setUserId, setUserProperties } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-analytics.js";
        import { getFunctions, httpsCallable } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-functions.js";
        
        // Global Firebase variables (provided by Canvas environment)
         const appId = 'production-app-id'; // Use a consistent, hardcoded ID to stabilize database paths.
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Your web app's Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBo3DM-4ZwrZdzcYQAMWAVHu70vWUdB7J4",
            authDomain: "nvanetworkapp.firebaseapp.com",
            projectId: "nvanetworkapp",
            storageBucket: "nvanetworkapp.firebasestorage.app",
            messagingSenderId: "122220543439",
            appId: "1:122220543439:web:e36ccce435463b7939a6ba",
            measurementId: "G-6RNS6DH3G0"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
         const storage = getStorage(app); // Initialize Storage
        const analytics = getAnalytics(app);
        const functions = getFunctions(app); // <-- ADD THIS LINE TO CREATE THE SERVICE
        window.firebaseAnalytics = analytics; // Export the instance
        window.logEvent = logEvent; // Export the function
        window.setUserId = setUserId; // Export the function
        window.setUserProperties = setUserProperties; // Export the function

        // Export for use in React component
        window.firebaseApp = app;
        window.firebaseAuth = auth;
        window.firebaseFunctions = functions;
        window.firebaseDb = db;
        window.firebaseStorage = storage;
        window.initialAuthToken = initialAuthToken;
        window.createUserWithEmailAndPassword = createUserWithEmailAndPassword;
        window.signInWithEmailAndPassword = signInWithEmailAndPassword;
        window.signOut = signOut;
        window.onAuthStateChanged = onAuthStateChanged;
        window.signInWithCustomToken = signInWithCustomToken;
        window.signInAnonymously = signInAnonymously;
        window.sendEmailVerification = sendEmailVerification;
        window.sendPasswordResetEmail = sendPasswordResetEmail;
        window.doc = doc;
        window.setDoc = setDoc;
        window.getDoc = getDoc;
        window.updateDoc = updateDoc;
        window.collection = collection;
        window.addDoc = addDoc;
        window.query = query;
        window.orderBy = orderBy;
        window.onSnapshot = onSnapshot;
        window.where = where;
        window.getDocs = getDocs;
        window.deleteDoc = deleteDoc;
        window.increment = increment;
        window.runTransaction = runTransaction;
        window.limit = limit;
        window.ref = ref;
        window.uploadBytes = uploadBytes;
        window.getDownloadURL = getDownloadURL;
        window.appId = appId;
        window.httpsCallable = httpsCallable;
    </script>

    <!-- 2. Load React and ReactDOM (synchronously, no defer) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- 3. Load Babel (synchronously, to process JSX from the next script) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- 4. Define your React App component (JSX content here) -->
    <script type="text/babel">
         const { useState, useEffect, useRef, useCallback, useMemo } = React;

                // ======================= START: FINAL NOTIFICATION HOOK =======================
        const useNotifications = (currentUser) => {
            const [notifications, setNotifications] = useState([]);
            const [isLoading, setIsLoading] = useState(true);
            const [pendingDeletes, setPendingDeletes] = useState(new Set());

            const dismissNotification = useCallback((notificationId) => {
                setPendingDeletes(prev => new Set(prev).add(notificationId));
                const functions = getFunctions(window.firebaseApp);
                const deleteNotificationCallable = httpsCallable(functions, 'deleteNotification');
                
                deleteNotificationCallable({ notificationId })
                    .catch(error => {
                        console.error("Failed to dismiss notification:", error);
                        setPendingDeletes(prev => {
                            const newSet = new Set(prev);
                            newSet.delete(notificationId);
                            return newSet;
                        });
                    });
            }, []);

            // Expose a helper function to be called by the App component
            const markBroadcastAsSeen = useCallback(async (notificationId) => {
                if (!currentUser) return;
                try {
                    const seenRef = doc(db, "creators", currentUser.uid, "seenNotifications", notificationId);
                    await setDoc(seenRef, { seenAt: new Date() });
                } catch (error) {
                    console.error("Failed to mark broadcast as seen:", error);
                }
            }, [currentUser]);

            
            const markNotificationAsRead = useCallback(async (notificationId) => {
                if (!currentUser) return;
                try {
                    const notifRef = doc(db, "notifications", notificationId);
                    await updateDoc(notifRef, { isRead: true });
                } catch (error) {
                    console.error("Failed to mark notification as read:", error);
                }
            }, [currentUser]);
            
            useEffect(() => {
                if (!currentUser) {
                    setNotifications([]);
                    setIsLoading(false);
                    return () => {};
                }

                setIsLoading(true);
                let privateNotifications = [];
                let broadcastNotifications = [];

                const mergeAndSetNotifications = async () => {
                    const seenRef = collection(db, "creators", currentUser.uid, "seenNotifications");
                    const seenSnapshot = await getDocs(seenRef);
                    const seenIds = new Set(seenSnapshot.docs.map(doc => doc.id));
                    
                    // The hook now ONLY filters based on what's already in the database.
                    const unseenBroadcasts = broadcastNotifications.filter(b => !seenIds.has(b.id));
                    
                    const combined = [...privateNotifications, ...unseenBroadcasts];
                    const filtered = combined.filter(n => !pendingDeletes.has(n.id));
                    const unique = Array.from(new Map(filtered.map(item => [item.id, item])).values());
                    
                    unique.sort((a, b) => b.timestamp.toDate().getTime() - a.timestamp.toDate().getTime());
                    
                    setNotifications(unique);
                    setIsLoading(false);
                };

                const privateNotifRef = collection(db, "notifications");
                const privateQuery = query(privateNotifRef, where("userId", "==", currentUser.uid), orderBy("timestamp", "desc"), limit(20));
                const unsubscribePrivate = onSnapshot(privateQuery, (snapshot) => {
                    privateNotifications = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data(), isBroadcast: false }));
                    mergeAndSetNotifications();
                });

                const broadcastNotifRef = collection(db, "broadcast_notifications");
                const fiveDaysAgo = new Date(Date.now() - 5 * 24 * 60 * 60 * 1000);
                const broadcastQuery = query(broadcastNotifRef, where("timestamp", ">", fiveDaysAgo), orderBy("timestamp", "desc"));
                const unsubscribeBroadcast = onSnapshot(broadcastQuery, (snapshot) => {
                    broadcastNotifications = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data(), isBroadcast: true }));
                    mergeAndSetNotifications();
                });

                return () => {
                    unsubscribePrivate();
                    unsubscribeBroadcast();
                };

            }, [currentUser, pendingDeletes]);

            return { notifications, isLoading, dismissNotification, markBroadcastAsSeen, markNotificationAsRead };
        };

        // --- NEW CURRENCY FORMATTING HELPER FUNCTION ---
        const formatCurrency = (usdAmount, selectedCurrency, currencyRates) => {
            const amount = parseFloat(usdAmount);
            if (isNaN(amount) || !currencyRates) {
                return `$${(usdAmount || 0).toFixed(2)} USD`;
            }
            if (selectedCurrency === 'USD') {
                return `$${amount.toFixed(2)} USD`;
            }
            const rate = currencyRates[selectedCurrency];
            if (!rate) {
                return `$${amount.toFixed(2)} USD`;
            }
            const convertedAmount = amount * rate;
            // Basic formatting for GYD, can be expanded for others
            if (selectedCurrency === 'GYD') {
                return `$${amount.toFixed(2)} USD (~$${convertedAmount.toLocaleString(undefined, { maximumFractionDigits: 0 })} GYD)`;
            }
            // Default formatting for other currencies
            return `$${amount.toFixed(2)} USD (~${convertedAmount.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })} ${selectedCurrency})`;
        };

        // --- NEW CURRENCY SELECTOR COMPONENT ---
        const CurrencySelector = ({ currencyRates, selectedCurrency, onCurrencyChange }) => {
            if (!currencyRates) {
                return null; // Don't render if rates haven't loaded
            }

            // We can define a smaller, more relevant list of currencies to offer.
            const supportedCurrencies = ['USD', 'GYD', 'CAD', 'GBP', 'EUR'];
            const availableCurrencies = supportedCurrencies.filter(c => currencyRates[c]);

            return (
                <select
                    value={selectedCurrency}
                    onChange={(e) => onCurrencyChange(e.target.value)}
                    style={{
                        backgroundColor: '#FFD700',
                        color: '#0A0A0A',
                        padding: '8px 12px',
                        borderRadius: '25px',
                        border: 'none',
                        fontWeight: '600',
                        fontSize: '14px',
                        cursor: 'pointer',
                        boxShadow: '0 4px 5px rgba(0, 0, 0, 0.3)',
                        appearance: 'none', // Removes default dropdown arrow on some systems
                        textAlign: 'center'
                    }}
                >
                    {availableCurrencies.map(currency => (
                        <option key={currency} value={currency}>
                            {currency}
                        </option>
                    ))}
                </select>
            );
        };
// END of REPLACEMENT Block

        const NotificationBell = ({ count, onClick }) => {
            return (
                <button className="navButton" onClick={onClick} style={{ position: 'relative', backgroundColor: '#0A0A0A', border: '1px solid #FFD700' }}>
                    <span className="navButtonText" style={{ color: '#FFD700' }}>
                        <svg viewBox="0 0 24 24" style={{ width: '24px', height: '24px', fill: 'currentColor' }}>
                            <path d="M12 22c1.1 0 2-.9 2-2h-4c0 1.1.9 2 2 2zm6-6v-5c0-3.07-1.63-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68C7.64 5.36 6 7.92 6 11v5l-2 2v1h16v-1l-2-2z"/>
                        </svg>
                    </span>
                    {count > 0 && (
                        <div style={{
                            position: 'absolute',
                            top: '-5px',
                            right: '-5px',
                            backgroundColor: '#DC3545',
                            color: '#FFF',
                            borderRadius: '50%',
                            width: '20px',
                            height: '20px',
                            display: 'flex',
                            justifyContent: 'center',
                            alignItems: 'center',
                            fontSize: '12px',
                            fontWeight: 'bold'
                        }}>
                            {count}
                        </div>
                    )}
                </button>
            );
        };

        const NotificationToast = ({ notification, onClick, onTimeout }) => {
            useEffect(() => {
                const timer = setTimeout(() => {
                    onTimeout(); 
                }, 6000); 

                return () => clearTimeout(timer);
            }, [notification, onTimeout]);

            if (!notification) return null;

            // Check for the special donation broadcast type
            if (notification.broadcastType === 'DONATION') {
                return (
                     <div className="donationTickerContainer visible">
                        <svg className="tickerIcon" viewBox="0 0 24 24"><path d="M12,2A10,10,0,1,0,22,12,10,10,0,0,0,12,2Zm3.71,9.71-4,4a1,1,0,0,1-1.42,0l-2-2a1,1,0,1,1,1.42-1.42L11,13.59l3.29-3.3a1,1,0,0,1,1.42,1.42Z"></path></svg>
                        <div className="tickerText">
                            <strong>{notification.userName}</strong> just donated <strong>${notification.amount.toFixed(2)}</strong> to "{notification.targetCampaignTitle}"!
                        </div>
                    </div>
                );
            }

            // Fallback to the standard notification toast
            return (
                <div className="donationTickerContainer visible" style={{cursor: 'pointer'}} onClick={onClick}>
                    <svg className="tickerIcon" viewBox="0 0 24 24"><path d="M12,2A10,10,0,1,0,22,12,10,10,0,0,0,12,2Zm3.71,9.71-4,4a1,1,0,0,1-1.42,0l-2-2a1,1,0,1,1,1.42-1.42L11,13.59l3.29-3.3a1,1,0,0,1,1.42,1.42Z"></path></svg>
                    <div className="tickerText">
                        {notification.message}
                    </div>
                </div>
            );
        };

        const NotificationInboxScreen = ({ notifications, setActiveScreen, dismissNotification }) => {
            // This local state is the key. It gives this component direct, instant control over the UI.
            const [localNotifications, setLocalNotifications] = useState(notifications);

            // This effect synchronizes the local list with the master list from the hook
            // when the component first loads or when a new notification arrives from the server.
            useEffect(() => {
                setLocalNotifications(notifications);
            }, [notifications]);

            const markAsRead = async (notification) => {
                // Mark private notifications as read
                if (!notification.isBroadcast && !notification.isRead) {
                    const notifRef = doc(db, "notifications", notification.id);
                    try {
                        await updateDoc(notifRef, { isRead: true });
                    } catch (error) {
                        console.error("Failed to mark notification as read:", error);
                    }
                }
                // Always mark broadcasts as seen, as their read state isn't tracked in the doc itself
                if (notification.isBroadcast) {
                    const seenRef = doc(db, "creators", window.firebaseAuth.currentUser.uid, "seenNotifications", notification.id);
                    try {
                         await setDoc(seenRef, { seenAt: new Date() });
                    } catch (error) {
                         console.error("Failed to mark broadcast as seen:", error);
                    }
                }
            };

            const handleNotificationClick = (notification) => {
                markAsRead(notification);
                if (notification.link) {
                    const screen = notification.link.replace('/', '');
                    setActiveScreen(screen);
                }
            };

            const handleDismiss = (notificationId, event) => {
                event.stopPropagation(); // Prevents the card's main click action

                // 1. INSTANTLY update the local UI state. This is the fix.
                setLocalNotifications(prev => prev.filter(n => n.id !== notificationId));

                // 2. Call the function from the hook to handle the backend deletion.
                dismissNotification(notificationId);
            };

            return (
                <div className="screenContainer">
                    <p className="heading">Notifications</p>
                    <div className="dashboardContentList">
                        {localNotifications.length === 0 ? (
                            <p className="dashboardItem" style={{textAlign: 'center'}}>You have no new notifications.</p>
                        ) : (
                            localNotifications.map(item => (
                                <div
                                    key={item.id}
                                    className="adminDashboardItem"
                                    style={{
                                        cursor: 'pointer',
                                        borderLeft: (item.isBroadcast || item.isRead === true) ? '4px solid transparent' : '4px solid #FFD700',
                                        flexDirection: 'column',
                                        alignItems: 'flex-start'
                                    }}
                                    onClick={() => handleNotificationClick(item)}
                                >
                                    <div style={{ display: 'flex', justifyContent: 'space-between', width: '100%', alignItems: 'center' }}>
                                        <p className="adminDashboardItemTitle" style={{fontWeight: 'normal', flexGrow: 1}}>{item.message}</p>
                                        {!item.isBroadcast && (
                                            <button 
                                                className="adminActionButton reject" // Use 'reject' class for red styling
                                                style={{ marginLeft: '15px' }} 
                                                onClick={(e) => handleDismiss(item.id, e)}
                                            >
                                                Dismiss
                                            </button>
                                        )}
                                    </div>
                                    <p style={{fontSize: '12px', color: '#AAA'}}>{new Date(item.timestamp.toDate()).toLocaleString()}</p>
                                </div>
                            ))
                        )}
                    </div>
                </div>
            );
        };
        // ======================= END: UNIFIED NOTIFICATION CODE BLOCK =======================

          // --- START: MASTER REPLACEMENT FOR extractVideoInfo ---
       const GENERIC_THUMBNAIL_PLACEHOLDER = 'https://placehold.co/300x200/2A2A2A/FFF?text=NVA';
      
    const extractVideoInfo = (url) => {
        if (!url || typeof url !== 'string') {
            return { videoId: null, thumbnailUrl: GENERIC_THUMBNAIL_PLACEHOLDER, embedUrl: null, platform: 'unknown', isVertical: false };
        }

        // 1. YouTube (Now detects Shorts)
        const youtubeRegex = /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/|youtube\.com\/shorts\/)([^"&?\/ ]{11})/;
        const youtubeMatch = url.match(youtubeRegex);
        if (youtubeMatch && youtubeMatch[1]) {
            const videoId = youtubeMatch[1];
            const thumbnailUrl = `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`;
            const embedUrl = `https://www.youtube.com/embed/${videoId}?autoplay=1&rel=0`;
            const isVertical = url.includes('/shorts/'); // This is the key addition
            return { videoId, thumbnailUrl, embedUrl, platform: 'youtube', isVertical };
        }

        // ... (The rest of the function for Vimeo, TikTok, etc., remains unchanged) ...
        // 2. Vimeo
        const vimeoRegex = /vimeo\.com\/(?:video\/)?(\d+)/;
        const vimeoMatch = url.match(vimeoRegex);
        if (vimeoMatch && vimeoMatch[1]) {
            const videoId = vimeoMatch[1];
            const embedUrl = `https://player.vimeo.com/video/${videoId}?autoplay=1`;
            return { videoId, thumbnailUrl: GENERIC_THUMBNAIL_PLACEHOLDER, embedUrl, platform: 'vimeo', isVertical: false };
        }

        // 3. TikTok
        const tiktokRegex = /tiktok\.com\/.*\/video\/(\d+)/;
        const tiktokMatch = url.match(tiktokRegex);
        if (tiktokMatch && tiktokMatch[1]) {
            const videoId = tiktokMatch[1];
            const embedUrl = `https://www.tiktok.com/embed/v2/${videoId}`;
            return { videoId, thumbnailUrl: GENERIC_THUMBNAIL_PLACEHOLDER, embedUrl, platform: 'tiktok', isVertical: true };
        }
        
        // 4. Facebook (Reels & Videos)
        const facebookRegex = /facebook\.com\/(?:watch\/?\?v=|.*\/videos\/|.*\/reel\/)(\d+)/;
        const facebookMatch = url.match(facebookRegex);
        if(facebookMatch && facebookMatch[1]) {
            const videoId = facebookMatch[1];
            const embedUrl = `https://www.facebook.com/plugins/video.php?href=${encodeURIComponent(url)}&show_text=false&autoplay=true`;
            return { videoId, thumbnailUrl: GENERIC_THUMBNAIL_PLACEHOLDER, embedUrl, platform: 'facebook', isVertical: url.includes('/reel/') };
        }

        // 5. Generic Fallback for all other links
        return {
            videoId: null,
            thumbnailUrl: GENERIC_THUMBNAIL_PLACEHOLDER,
            embedUrl: url,
            platform: 'generic',
            isVertical: false
        };
    };
        // --- END: MASTER REPLACEMENT FOR extractVideoInfo ---

              // --- START: NEW DynamicThumbnail Component ---
        const DynamicThumbnail = ({ item, onClick }) => {
            const [thumbnailSrc, setThumbnailSrc] = useState(GENERIC_THUMBNAIL_PLACEHOLDER);
            
            useEffect(() => {
                let isCancelled = false;

                const getThumbnail = async () => {
                    // Priority 1: Always use an explicit image URL if provided.
                    if (item.customThumbnailUrl || item.imageUrl) {
                        if (!isCancelled) {
                            setThumbnailSrc(item.customThumbnailUrl || item.imageUrl);
                        }
                        return;
                    }

                    const info = extractVideoInfo(item.mainUrl || item.externalLink);

                    // Priority 2: Use YouTube's reliable direct link.
                    if (info.platform === 'youtube') {
                        if (!isCancelled) {
                            setThumbnailSrc(info.thumbnailUrl);
                        }
                        return;
                    }

                    // Priority 3: For platforms that need it, call our secure proxy.
                    if (info.platform === 'tiktok' || info.platform === 'vimeo') {
                        try {
                            const functions = getFunctions(window.firebaseApp);
                            const oEmbedProxyCallable = httpsCallable(functions, 'oEmbedProxy');
                            
                            let oEmbedUrl = '';
                            if (info.platform === 'tiktok') {
                                oEmbedUrl = `https://www.tiktok.com/oembed?url=${encodeURIComponent(item.mainUrl || item.externalLink)}`;
                            }
                            if (info.platform === 'vimeo') {
                                oEmbedUrl = `https://vimeo.com/api/oembed.json?url=${encodeURIComponent(item.mainUrl || item.externalLink)}`;
                            }

                            const result = await oEmbedProxyCallable({ url: oEmbedUrl });

                            if (!isCancelled && result.data && result.data.thumbnail_url) {
                                setThumbnailSrc(result.data.thumbnail_url);
                            }
                        } catch (error) {
                            console.error("oEmbed fetch failed for", info.platform, error);
                            // If proxy fails, we will fall back to the placeholder below.
                        }
                        return;
                    }
                    
                    // If none of the above worked, do nothing, the placeholder will remain.
                };

                getThumbnail();

                return () => {
                    isCancelled = true;
                };
            }, [item.id]); // Re-run only when the item itself changes.

            return (
                 <div className="thumbnailPlaceholder" style={{backgroundImage: `url(${thumbnailSrc})`, backgroundSize: 'cover', backgroundPosition: 'center', position: 'relative'}} onClick={onClick}>
                    <svg className="playIcon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"></path></svg>
                </div>
            );
        };
        // --- END: NEW DynamicThumbnail Component ---
              
                // --- CORRECTED AND CONSOLIDATED CONSTANTS ---
                
        const auth = window.firebaseAuth;
        const db = window.firebaseDb;
        const functions = window.firebaseFunctions; // <-- ADD THIS LINE
        const increment = window.increment;
        const storage = window.firebaseStorage;
        const analytics = window.firebaseAnalytics; // Get analytics instance
        const createUserWithEmailAndPassword = window.createUserWithEmailAndPassword;
        const signInWithEmailAndPassword = window.signInWithEmailAndPassword;
        const signOut = window.signOut;
        const onAuthStateChanged = window.onAuthStateChanged;
        const doc = window.doc;
        const setDoc = window.setDoc;
        const getDoc = window.getDoc;
        const updateDoc = window.updateDoc;
        const collection = window.collection;
        const addDoc = window.addDoc;
        const query = window.query;
        const orderBy = window.orderBy;
        const onSnapshot = window.onSnapshot;
        const where = window.where;
        const getDocs = window.getDocs;
        const deleteDoc = window.deleteDoc;
        const runTransaction = window.runTransaction;
        const ref = window.ref;
        const getFunctions = window.getFunctions;
        const httpsCallable = window.httpsCallable;
        const uploadBytes = window.uploadBytes;
        const getDownloadURL = window.getDownloadURL;
        const appId = window.appId;
        const signInAnonymously = window.signInAnonymously;
        const sendEmailVerification = window.sendEmailVerification;
        const limit = window.limit;
        const sendPasswordResetEmail = window.sendPasswordResetEmail;
        // --- Get the Analytics functions we exposed in Step 1 ---
        
        const logEvent = window.logEvent;
        const setUserId = window.setUserId;
        const setUserProperties = window.setUserProperties;


        // --- NEW: Analytics Helper Function ---
        /**
         * Logs a click on a creator's featured link to Firebase Analytics.
         * @param {string} creatorId - The UID of the creator whose link was clicked.
         * @param {string} creatorName - The name of the creator.
         */
        const logFeaturedLinkClick = (creatorId, creatorName) => {
            // Check if analytics and logEvent are available before using them
            if (analytics && logEvent) {
                logEvent(analytics, 'featured_link_click', {
                    content_creator_id: creatorId,
                    content_creator_name: creatorName,
                });
            } else {
                console.log("Analytics not ready, click was not logged.");
            }
        };
        

        // Hardcoded content - these will eventually be replaced by dynamic data from Firestore
        const featuredContent = [
            { id: '1', title: 'Guyanese Comedy Special', type: 'skit', url: 'https://www.youtube.com/embed/dQw4w9WgXcQ?autoplay=1', creator: 'Comedy Crew' },
            { id: '2', title: 'Top Guyanese Skits: Best of 2024', type: 'skit', url: 'https://www.youtube.com/embed/oHg5SJYRHA0?autoplay=1', creator: 'Laugh Central' },
            { id: '3', title: 'Indie Film: "Georgetown Dreams"', type: 'short-film', url: 'https://www.youtube.com/embed/34Na4j8AVgA?autoplay=1', creator: 'Indie Films GY' },
            { id: '4', title: 'Live Concert Replay: Mashramani', type: 'live-premiere', url: 'https://www.youtube.com/embed/example4?autoplay=1', creator: 'Vibes Ent.' },
            { id: '5', title: 'Creator Interview: Rise of Talent', type: 'interview', url: 'https://www.youtube.com/embed/example5?autoplay=1', creator: 'NVA Insights' },
            { id: '6', title: 'Short Film: "The Golden Arrowhead"', type: 'short-film', url: 'https://www.youtube.com/embed/example6?autoplay=1', creator: 'Heritage Films' },
            { id: '7', title: 'New Skit Series: "Life in GT"', type: 'skit', url: 'https://www.youtube.com/embed/skit7?autoplay=1', creator: 'GT Daily' },
            { id: '8', title: 'Cooking Show: Guyanese Delights', type: 'skit', url: 'https://www.youtube.com/embed/skit8?autoplay=1', creator: 'Chef Roti' },
            { id: '9', title: 'Poetry Slam Live: Best of Season', type: 'live-premiere', url: 'https://www.youtube.com/embed/live9?autoplay=1', creator: 'Wordsmiths GY' },
            { id: '10', title: 'Wildlife Doc: Amazonian Secrets', type: 'documentary', url: 'https://www.youtube.com/embed/doc1?autoplay=1', creator: 'Nature Watch' },
            { id: '11', title: 'Guyanese Music Spotlight', type: 'music', url: 'https://www.youtube.com/embed/music1?autoplay=1', creator: 'Riddim Connect' },
            { id: '12', title: 'Interview: Young Entrepreneurs', type: 'interview', url: 'https://www.youtube.com/embed/int1?autoplay=1', creator: 'Business Buzz GY' },
        ];


 

        const getYouTubeEmbedUrl = (youtubeUrl) => {
            const videoIdMatch = youtubeUrl.match(/(?:youtu\.be\/|youtube\.com\/(?:watch\?v=|embed\/||shorts\/))([^&?#]+)/);
            if (videoIdMatch && videoIdMatch[1]) {
                return `https://www.youtube.com/embed/${videoIdMatch[1]}?autoplay=1&rel=0`;
            }
            return youtubeUrl;
        };

         const VideoPlayerModal = ({ videoUrl, onClose, contentItem, currentUser, showMessage }) => {
    // --- START: FIX #1 - ADD STATE FOR REAL-TIME DATA ---
    const [liveContentItem, setLiveContentItem] = useState(contentItem);
    const viewCountedRef = useRef(false);

    // --- START: FIX #2 - ADD REAL-TIME LISTENER ---
    useEffect(() => {
        if (!contentItem?.id) return;
        const contentDocId = contentItem.originalContentId || contentItem.id;
        const unsub = onSnapshot(doc(db, `artifacts/${appId}/public/data/content_items/${contentDocId}`), (doc) => {
            if (doc.exists()) {
                setLiveContentItem({ id: doc.id, ...doc.data() });
            }
        });
        return () => unsub();
    }, [contentItem]);
    // --- END: FIX #2 ---

    useEffect(() => {
        if (!liveContentItem || !currentUser || viewCountedRef.current) { return; }
        const authorId = liveContentItem.creatorId || liveContentItem.createdBy;
        const contentDocId = liveContentItem.originalContentId || liveContentItem.id;
        if (currentUser.uid === authorId) { return; }
        const timer = setTimeout(async () => {
            if (viewCountedRef.current) return;
            viewCountedRef.current = true;
            try {
                const incrementViewFunction = httpsCallable(functions, 'incrementViewCount');
                await incrementViewFunction({ contentId: contentDocId, appId: appId });
            } catch (error) { console.error("Error calling incrementViewCount function:", error); }
        }, 10000);
        return () => { clearTimeout(timer); };
    }, [liveContentItem, currentUser]);

    if (!videoUrl) return null;

    const { embedUrl, isVertical } = extractVideoInfo(videoUrl);

    return (
        <div className="videoModalOverlay">
            <div className={`videoModalContent ${isVertical ? 'vertical' : ''}`}>
                <button className="closeButton" onClick={onClose}>×</button>
                <div className={`videoIframeContainer ${isVertical ? 'vertical' : ''}`}>
                    <iframe src={embedUrl} allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowFullScreen title="Embedded Video Content"></iframe>
                </div>
                
                <div 
                    onClick={() => {
                        if (liveContentItem?.likeCount > 0) {
                            const event = new CustomEvent('openLikesModal', { detail: { contentItem: liveContentItem } });
                            window.dispatchEvent(event);
                        } else {
                            showMessage("No likes to display yet.");
                        }
                    }}
                    style={{
                        position: 'absolute', bottom: '20px', left: '15px', backgroundColor: 'rgba(10, 10, 10, 0.7)',
                        border: '1px solid #FFD700', borderRadius: '50px', padding: '0 10px', height: '32px',
                        display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '6px',
                        cursor: liveContentItem?.likeCount > 0 ? 'pointer' : 'default'
                    }}>
                    <div style={{ display: 'flex', alignItems: 'center', gap: '4px' }} title="Views">
                        <svg viewBox="0 0 24 24" style={{ width: '18px', height: '18px', fill: '#FFF' }}><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5C21.27 7.61 17 4.5 12 4.5zm0 10c-2.48 0-4.5-2.02-4.5-4.5S9.52 5.5 12 5.5s4.5 2.02 4.5 4.5-2.02 4.5-4.5 4.5zM12 8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"></path></svg>
                        {/* --- USE THE LIVE STATE VARIABLE --- */}
                        <span style={{ color: '#FFF', fontSize: '12px', fontWeight: 'bold' }}>{(liveContentItem?.viewCount || 0).toLocaleString()}</span>
                    </div>
                    <div style={{width: '1px', height: '16px', backgroundColor: '#555'}}></div>
                    <div style={{ display: 'flex', alignItems: 'center', gap: '4px' }} title="View who liked this">
                        <svg viewBox="0 0 24 24" style={{ width: '18px', height: '18px', fill: '#FFD700' }}><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"></path></svg>
                        {/* --- USE THE LIVE STATE VARIABLE --- */}
                        <span style={{ color: '#FFF', fontSize: '12px', fontWeight: 'bold' }}>{(liveContentItem?.likeCount || 0).toLocaleString()}</span>
                    </div>
                </div>

                {currentUser && liveContentItem && liveContentItem.id && (
                    <div style={{ position: 'absolute', bottom: '20px', right: '15px', display: 'flex', gap: '10px' }}>
                        <LikeButton contentItem={liveContentItem} currentUser={currentUser} showMessage={showMessage} />
                        
                        {/* START: ADDED COMMENT BUTTON */}
                        <button
                            onClick={() => window.dispatchEvent(new CustomEvent('openCommentsModal', { detail: { item: liveContentItem, itemType: 'content' } }))}
                            title="View comments"
                            style={{
                                backgroundColor: 'rgba(10, 10, 10, 0.7)', border: '1px solid #FFD700', borderRadius: '50%',
                                width: '32px', height: '32px', display: 'flex', alignItems: 'center', justifyContent: 'center',
                                cursor: 'pointer', color: '#FFF'
                            }}
                        >
                            <svg viewBox="0 0 24 24" style={{ width: '18px', height: '18px', fill: 'currentColor' }}><path d="M21.99 4c0-1.1-.89-2-1.99-2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h14l4 4-.01-18zM18 14H6v-2h12v2zm0-3H6V9h12v2zm0-3H6V6h12v2z"></path></svg>
                        </button>
                        {/* END: ADDED COMMENT BUTTON */}

                        <button
                            onClick={(e) => { e.stopPropagation(); window.dispatchEvent(new CustomEvent('openReportModal', { detail: liveContentItem })); }}
                            title="More options"
                            style={{
                                backgroundColor: 'rgba(10, 10, 10, 0.7)', border: '1px solid #FFD700', borderRadius: '50%',
                                width: '32px', height: '32px', display: 'flex', alignItems: 'center', justifyContent: 'center',
                                cursor: 'pointer', color: '#FFF'
                            }}
                        ><svg viewBox="0 0 24 24" style={{ width: '18px', height: '18px', fill: 'currentColor' }}><path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"></path></svg>
                        </button>
                    </div>
                )}
            </div>
        </div>
    );
};


       const LikeButton = ({ contentItem, currentUser, showMessage }) => {
    const [isLiked, setIsLiked] = useState(false);
    const [likeCount, setLikeCount] = useState(contentItem.likeCount || 0);
    const [isLoading, setIsLoading] = useState(true);
    const [isProcessing, setIsProcessing] = useState(false);

    const contentDocId = contentItem.originalContentId || contentItem.id;
    
    useEffect(() => {
        if (!currentUser || !contentDocId) { setIsLoading(false); return; }
        const likeRef = doc(db, `artifacts/${appId}/public/data/content_items/${contentDocId}/likes`, currentUser.uid);
        const unsubscribeLike = onSnapshot(likeRef, (docSnap) => { setIsLiked(docSnap.exists()); setIsLoading(false); });
        const contentRef = doc(db, `artifacts/${appId}/public/data/content_items/${contentDocId}`);
        const unsubscribeContent = onSnapshot(contentRef, (docSnap) => { if (docSnap.exists()) { setLikeCount(docSnap.data().likeCount || 0); } });
        return () => { unsubscribeLike(); unsubscribeContent(); };
    }, [contentDocId, currentUser]);

    const handleLike = async (e) => {
        e.stopPropagation();
        if (!currentUser) { showMessage("Please log in to like content."); return; }
        if (isLoading || isProcessing) return;
        setIsProcessing(true);
        const newLikedState = !isLiked;
        setIsLiked(newLikedState);
        setLikeCount(prevCount => newLikedState ? prevCount + 1 : prevCount - 1);
        try {
            const updateLikeFunction = httpsCallable(functions, 'updateLikeCount');
            await updateLikeFunction({ contentId: contentDocId, appId: appId, isLiking: newLikedState });
        } catch (error) {
            showMessage("An error occurred. Please try again.");
            setIsLiked(!newLikedState);
            setLikeCount(prevCount => newLikedState ? prevCount - 1 : prevCount + 1);
        } finally { setIsProcessing(false); }
    };

    const heartIconPath = "M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z";

    return (
        <button
            onClick={handleLike}
            disabled={isLoading || isProcessing}
            style={{
                backgroundColor: 'rgba(10, 10, 10, 0.7)',
                border: '1px solid #FFD700',
                borderRadius: '50%',
                width: 'auto',
                minWidth: '32px',
                height: '32px',
                padding: '0 5px 0 10px',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                cursor: 'pointer',
                gap: '4px',
                transition: 'transform 0.2s'
            }}
        >
            <svg viewBox="0 0 24 24" style={{ width: '18px', height: '18px', fill: isLiked ? '#FFD700' : '#FFF' }}>
                <path d={heartIconPath}></path>
            </svg>
            <div 
                onClick={(e) => {
                    e.stopPropagation();
                    if (likeCount > 0) {
                         const event = new CustomEvent('openLikesModal', { detail: { contentItem } });
                         window.dispatchEvent(event);
                    } else {
                        showMessage("No likes to display yet.");
                    }
                }}
                title="View who liked this"
                style={{ padding: '0 5px', cursor: likeCount > 0 ? 'pointer' : 'default' }}
            >
                <span style={{ color: '#FFF', fontSize: '12px', fontWeight: 'bold' }}>{likeCount}</span>
            </div>
        </button>
    );
};


                // --- START OF NEW COMPONENT ---
        // --- START: REPLACEMENT FOR DiscoverUsersScreen ---
        const DiscoverUsersScreen = ({ showMessage, setActiveScreen, setSelectedCampaignId, creatorProfile, setSelectedUserId }) => {
            const [searchTerm, setSearchTerm] = useState('');
            const [searchResults, setSearchResults] = useState([]);
            const [isLoading, setIsLoading] = useState(false);
            const [hasSearched, setHasSearched] = useState(false);
            
            const viewProfile = (userId) => {
                setSelectedUserId(userId);
                setActiveScreen('UserProfile');
            };

            const handleSearch = async (e) => {
                e.preventDefault();
                if (!searchTerm.trim()) { setSearchResults([]); return; }
                setIsLoading(true);
                setHasSearched(true);
                
                try {
                    const usersRef = collection(db, "creators");
                    let q;

                    if (creatorProfile && (creatorProfile.role === 'admin' || creatorProfile.role === 'authority')) {
                        q = query(usersRef);
                    } else {
                        q = query(usersRef, where('role', 'in', ['user', 'creator']));
                    }
                    
                    const querySnapshot = await getDocs(q);
                    const users = querySnapshot.docs
                        .map(doc => ({ id: doc.id, ...doc.data() }))
                        .filter(user => user.creatorName && user.creatorName.toLowerCase().includes(searchTerm.toLowerCase()));

                    const usersWithCampaignStatus = await Promise.all(
                        users.map(async (user) => {
                            const campaignsRef = collection(db, `artifacts/${appId}/public/data/campaigns`);
                            const campaignQuery = query(campaignsRef, where('creatorId', '==', user.id), where('status', '==', 'active'));
                            const campaignSnapshot = await getDocs(campaignQuery);
                            return {
                                ...user,
                                hasActiveCampaign: !campaignSnapshot.empty,
                                activeCampaignId: !campaignSnapshot.empty ? campaignSnapshot.docs[0].id : null
                            };
                        })
                    );
                    setSearchResults(usersWithCampaignStatus);
                } catch (error) {
                    console.error("Error searching users:", error);
                    showMessage("Failed to search for users. Please try again.");
                } finally {
                    setIsLoading(false);
                }
            };
            
            return (
                <div className="screenContainer">
                    <p className="heading">Discover Creators</p>
                    <form onSubmit={handleSearch}>
                        <div className="formGroup">
                            <label htmlFor="userSearch" className="formLabel">Creator Name:</label>
                            <input type="text" id="userSearch" className="formInput" value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} placeholder="Enter a creator's name..."/>
                        </div>
                        <button type="submit" className="button" disabled={isLoading}><span className="buttonText">{isLoading ? 'Searching...' : 'Search'}</span></button>
                    </form>
                    <div className="user-search-list">
                        {isLoading && <p>Searching...</p>}
                        {!isLoading && hasSearched && searchResults.length === 0 && <p>No users found matching "{searchTerm}".</p>}
                        {!isLoading && searchResults.map(user => (
                            <div key={user.id} className="user-search-item" style={{cursor: 'pointer'}} onClick={() => viewProfile(user.id)}>
                                <img src={user.profilePictureUrl || 'https://placehold.co/100x100/555/FFF?text=P'} alt={user.creatorName} className="user-search-pfp"/>
                                <div className="user-search-info">
                                    <p className="user-search-name">
                                        {user.creatorName}
                                        {user.hasActiveCampaign && <span className="user-search-campaign-badge">Active Campaign</span>}
                                    </p>
                                    <p className="user-search-role">Role: {user.role}</p>
                                </div>
                            </div>
                        ))}
                    </div>
                </div>
            );
        };
        // --- END OF REPLACEMENT ---


        const UserProfileScreen = ({ selectedUserId, setActiveScreen, setSelectedCampaignId, showMessage, currentUser, creatorProfile }) => {
    const [profile, setProfile] = useState(null);
    const [loadingProfile, setLoadingProfile] = useState(true);
    const [isFollowing, setIsFollowing] = useState(false);
    const [isFollowLoading, setIsFollowLoading] = useState(true);
    const [showPfpModal, setShowPfpModal] = useState(false);
    const [isUpdatingRole, setIsUpdatingRole] = useState(false);
    const [isTogglingBan, setIsTogglingBan] = useState(false);
    const [pinnedContent, setPinnedContent] = useState([]);
    const [allContent, setAllContent] = useState([]);
    const [loadingContent, setLoadingContent] = useState(true);

    useEffect(() => {
        if (!selectedUserId) { setActiveScreen('DiscoverUsers'); return; }
        setLoadingProfile(true);
        setIsFollowLoading(true);
        setLoadingContent(true);

        const userDocRef = doc(db, "creators", selectedUserId);
        const unsubscribeProfile = onSnapshot(userDocRef, (userDocSnap) => {
            if (userDocSnap.exists()) {
                const profileData = userDocSnap.data();
                setProfile({ id: userDocSnap.id, ...profileData });
                fetchContentLibrary(selectedUserId, profileData.pinnedContent || []);
            } else {
                showMessage("This user profile could not be found.");
                setActiveScreen('DiscoverUsers');
            }
            setLoadingProfile(false);
        });

        let unsubscribeFollow = () => {};
        if (currentUser) {
            const followDocRef = doc(db, "creators", selectedUserId, "followers", currentUser.uid);
            unsubscribeFollow = onSnapshot(followDocRef, (followDocSnap) => setIsFollowing(followDocSnap.exists()));
            setIsFollowLoading(false);
        } else {
            setIsFollowLoading(false);
        }

        return () => { unsubscribeProfile(); unsubscribeFollow(); };
    }, [selectedUserId, currentUser]);

    const fetchContentLibrary = async (userId, pinnedIds) => {
        try {
            const contentRef = collection(db, `artifacts/${appId}/public/data/content_items`);
            if (pinnedIds && pinnedIds.length > 0) {
                const pinnedQuery = query(contentRef, where("__name__", "in", pinnedIds));
                const pinnedSnapshot = await getDocs(pinnedQuery);
                const pinnedData = pinnedSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                pinnedData.sort((a, b) => pinnedIds.indexOf(a.id) - pinnedIds.indexOf(b.id));
                setPinnedContent(pinnedData);
            } else {
                setPinnedContent([]);
            }
            const allContentQuery = query(contentRef, where("creatorId", "==", userId), orderBy("createdAt", "desc"));
            const allContentSnapshot = await getDocs(allContentQuery);
            const allContentData = allContentSnapshot.docs
                .map(doc => ({ id: doc.id, ...doc.data() }))
                .filter(item => !(pinnedIds && pinnedIds.includes(item.id)));
            setAllContent(allContentData);
        } catch (error) { showMessage("Could not load the creator's content library.");
        } finally { setLoadingContent(false); }
    };
    
    const handleFollowToggle = async () => {
        if (!currentUser) { showMessage("Please log in to follow creators."); setActiveScreen('Login'); return; }
        if (currentUser.uid === selectedUserId) { showMessage("You cannot follow yourself."); return; }
        if (isFollowLoading) return;
        setIsFollowLoading(true);
        const newFollowState = !isFollowing;
        try {
            const toggleFollowFunction = httpsCallable(functions, 'toggleFollow');
            await toggleFollowFunction({ targetUserId: selectedUserId, isFollowing: newFollowState });
        } catch (error) { showMessage("Something went wrong. Please try again.");
        } finally { setIsFollowLoading(false); }
    };
    
    const handleRoleChange = async (newRole) => { /* ... unchanged ... */ };
    const handleToggleBan = async () => { /* ... unchanged ... */ };
    
    const handleVideoPress = (url, item) => {
        if (!currentUser) { showMessage("Please log in to view content."); return; }
        const event = new CustomEvent('openVideoModal', { detail: { url, item } });
        window.dispatchEvent(event);
    };

    if (loadingProfile) { return <div className="screenContainer"><p className="heading">Loading Profile...</p></div>; }
    if (!profile) return null;

    const isProfileVerified = profile.isVerifiedAdvertiser && profile.verifiedAdvertiserExpiresAt && profile.verifiedAdvertiserExpiresAt.toDate() > new Date();
    const isViewerAdminOrAuthority = creatorProfile && (creatorProfile.role === 'admin' || creatorProfile.role === 'authority');
    const canManageThisUser = isViewerAdminOrAuthority && currentUser?.uid !== profile.id && !(creatorProfile.role === 'authority' && profile.role === 'admin');

    // --- START: NEW COMPONENT TO AVOID REPETITION ---
    const ContentStats = ({ item }) => (
        <div style={{ padding: '0 10px 10px 10px', display: 'flex', alignItems: 'center', justifyContent: 'space-between', gap: '5px', color: '#AAA', fontSize: '12px' }}>
            <div style={{ display: 'flex', alignItems: 'center', gap: '5px' }}>
                <svg viewBox="0 0 24 24" style={{ width: '16px', height: '16px', fill: 'currentColor' }}><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5C21.27 7.61 17 4.5 12 4.5zm0 10c-2.48 0-4.5-2.02-4.5-4.5S9.52 5.5 12 5.5s4.5 2.02 4.5 4.5-2.02 4.5-4.5 4.5zM12 8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"></path></svg>
                <span>{(item.viewCount || 0).toLocaleString()}</span>
            </div>
            <LikeButton contentItem={item} currentUser={currentUser} showMessage={showMessage} />
        </div>
    );
    // --- END: NEW COMPONENT ---

    return (
        <>
            <div className="screenContainer">
                <div className="dashboardSection">
                     <div className="flex items-center mb-4">
                        <img src={profile.profilePictureUrl || 'https://placehold.co/100x100/555/FFF?text=P'} alt="Profile" style={{width: '100px', height: '100px', borderRadius: '50%', border: '2px solid #FFD700', objectFit: 'cover', cursor: 'pointer'}} onClick={() => setShowPfpModal(true)} />
                        <div style={{marginLeft: '1rem', flexGrow: 1}}>
                            <p className="dashboardItem" style={{fontSize: '20px', fontWeight: 'bold', color: '#FFF', marginBottom: '5px', display: 'flex', alignItems: 'center'}}>
                                {profile.creatorName}
                                {isProfileVerified && <span title="Verified Advertiser" style={{marginLeft: '10px', fontSize: '24px', color: '#00FFFF'}}>✔</span>}
                            </p>
                            <div style={{display: 'flex', gap: '15px', marginTop: '10px'}}><p className="dashboardItem"><strong>{profile.followerCount || 0}</strong> Followers</p><p className="dashboardItem"><strong>{profile.followingCount || 0}</strong> Following</p></div>
                        </div>
                    </div>
                    {currentUser && currentUser.uid !== selectedUserId && ( <button className="dashboardButton" onClick={handleFollowToggle} disabled={isFollowLoading} style={{ marginTop: '15px', backgroundColor: isFollowing ? '#555' : '#FFD700', color: isFollowing ? '#FFF' : '#0A0A0A', cursor: isFollowLoading ? 'wait' : 'pointer' }}> {isFollowLoading ? '...' : (isFollowing ? 'Unfollow' : 'Follow')} </button> )}
                    <p className="dashboardItem" style={{marginTop: '15px'}}><strong>Bio:</strong> {profile.bio || "No bio provided."}</p>
                    <p className="dashboardItem"><strong>Categories:</strong> {profile.categories?.length > 0 ? profile.categories.join(', ') : "No categories set."}</p>
                </div>

                {isViewerAdminOrAuthority && ( <div className="dashboardSection" style={{border: '2px solid #DC3545'}}>{/* ... Admin controls unchanged ... */}</div>)}
                
                <div className="profile-content-section">
                    <p className="sectionTitle">Pinned Content</p>
                    {loadingContent ? <p>Loading...</p> : 
                        pinnedContent.length === 0 ? <p className="dashboardItem">This creator hasn't pinned any content yet.</p> :
                        <div className="contentGrid">
                            {pinnedContent.map(item => (
                                <div key={item.id} className="pinned-item-card" >
                                    <div onClick={() => handleVideoPress(item.embedUrl || item.mainUrl, item)}>
                                        <div className="pinned-indicator-icon"><svg viewBox="0 0 24 24"><path d="M16 12V4h1V2H7v2h1v8l-2 2v2h5.2v6h1.6v-6H18v-2l-2-2z"></path></svg></div>
                                        <img src={item.customThumbnailUrl} alt={item.title} className="pinned-item-thumbnail" />
                                        <p className="contentTitle">{item.title}</p>
                                    </div>
                                    <ContentStats item={item} />
                                </div>
                            ))}
                        </div>
                    }
                </div>
                
                <div className="profile-content-section">
                    <p className="sectionTitle">All Content</p>
                    {loadingContent ? <p>Loading...</p> : 
                        allContent.length === 0 ? <p className="dashboardItem">This creator hasn't uploaded any other content.</p> :
                        <div className="contentGrid">
                            {allContent.map(item => (
                                <div key={item.id} className="contentCard">
                                    <div onClick={() => handleVideoPress(item.embedUrl || item.mainUrl, item)}>
                                        <DynamicThumbnail item={item} />
                                        <p className="contentTitle">{item.title}</p>
                                    </div>
                                    <ContentStats item={item} />
                                </div>
                            ))}
                        </div>
                    }
                </div>

                <button className="button" onClick={() => setActiveScreen('DiscoverUsers')} style={{ backgroundColor: '#3A3A3A', color: '#FFF', marginTop: '20px' }}><span className="buttonText">Back to Search</span></button>
            </div>
            {showPfpModal && profile && <ProfilePictureModal imageUrl={profile.profilePictureUrl || 'https://placehold.co/400x400/555/FFF?text=No+Image'} onClose={() => setShowPfpModal(false)} />}
        </>
    );
};

// --- END: FULL COMPONENT REPLACEMENT ---

                // ======================================================================
// ========= START: ADD THIS ENTIRE NEW LikesModal COMPONENT =========
// ======================================================================

const LikesModal = ({ contentItem, currentUser, showMessage, onClose, setActiveScreen, setSelectedUserId }) => {
    const [likers, setLikers] = useState([]);
    const [loading, setLoading] = useState(true);
    const [lastVisible, setLastVisible] = useState(null);
    const [hasMore, setHasMore] = useState(true);
    const PAGE_SIZE = 20;

    const fetchLikers = async (isFirstFetch = false) => {
        if (!hasMore && !isFirstFetch) return;
        setLoading(true);
        try {
            const likesRef = collection(db, `artifacts/${appId}/public/data/content_items/${contentItem.id}/likes`);
            let q;
            if (isFirstFetch) { q = query(likesRef, orderBy('likedAt', 'desc'), limit(PAGE_SIZE));
            } else if (lastVisible) { q = query(likesRef, orderBy('likedAt', 'desc'), startAfter(lastVisible), limit(PAGE_SIZE));
            } else { setLoading(false); return; }

            const likeSnapshot = await getDocs(q);
            const newLastVisible = likeSnapshot.docs[likeSnapshot.docs.length - 1];
            setLastVisible(newLastVisible);
            if (likeSnapshot.empty || likeSnapshot.size < PAGE_SIZE) { setHasMore(false); }
            const likerIds = likeSnapshot.docs.map(doc => doc.id);
            if (likerIds.length === 0) { setLoading(false); return; }

            const creatorsRef = collection(db, "creators");
            const usersQuery = query(creatorsRef, where("__name__", "in", likerIds));
            const userSnapshot = await getDocs(usersQuery);
            const usersData = userSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            setLikers(prev => isFirstFetch ? usersData : [...prev, ...usersData]);
        } catch (error) { showMessage("Could not load list of likes.");
        } finally { setLoading(false); }
    };

    useEffect(() => { fetchLikers(true); }, [contentItem]);

    const handleViewProfile = (userId) => {
        // --- THIS IS THE FIX ---
        // We now dispatch a global event that the main App component will listen for.
        const event = new CustomEvent('navigateToUserProfile', { detail: { userId } });
        window.dispatchEvent(event);
    };
    
    const handleOverlayClick = (e) => { if (e.target === e.currentTarget) { onClose(); } };

    return (
        <div className="likesModalOverlay" onClick={handleOverlayClick}>
            <div className="likesModalContent">
                <div className="likesModalHeader"><p className="likesModalTitle">Liked By</p><button className="closeButton" onClick={onClose}>×</button></div>
                <div className="likesList">
                    {loading && likers.length === 0 && <p style={{textAlign: 'center'}}>Loading...</p>}
                    {likers.map(user => (
                        <div key={user.id} className="likeItem" onClick={() => handleViewProfile(user.id)}>
                            <img src={user.profilePictureUrl || 'https://placehold.co/80x80/555/FFF?text=P'} alt={user.creatorName} className="likeItemPfp" />
                            <p className="likeItemName">{user.creatorName}</p>
                        </div>
                    ))}
                    {!loading && hasMore && (<button className="button" style={{width: '100%', marginTop: '10px'}} onClick={() => fetchLikers()}><span className="buttonText">Load More</span></button>)}
                </div>
            </div>
        </div>
    );
};

// ======================================================================
// ========== END: ADD THIS ENTIRE NEW LikesModal COMPONENT ===========
// ======================================================================


                // ======================================================================
// ========= START: ADD THIS ENTIRE NEW CommentsModal COMPONENT =========
// ======================================================================

const CommentsModal = ({ item, itemType, currentUser, creatorProfile, showMessage, onClose, setActiveScreen, setSelectedUserId }) => {
    const [comments, setComments] = useState([]);
    const [loading, setLoading] = useState(true);
    const [newCommentText, setNewCommentText] = useState('');
    const [isSubmitting, setIsSubmitting] = useState(false);
    const [replyingTo, setReplyingTo] = useState(null);
    const collectionPath = itemType === 'content' 
        ? `artifacts/${appId}/public/data/content_items/${item.id}/comments`
        : `opportunities/${item.id}/comments`;
        
    const timeAgo = (date) => { /* ... timeAgo function is unchanged ... */ };

    // --- START: FIX #1 - USE A REAL-TIME LISTENER ---
    useEffect(() => {
        setLoading(true);
        const commentsRef = collection(db, collectionPath);
        const q = query(commentsRef, orderBy('createdAt', 'desc'));
        const unsubscribe = onSnapshot(q, (snapshot) => {
            setComments(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
            setLoading(false);
        }, (error) => {
            showMessage("Could not load comments.");
            setLoading(false);
        });
        return () => unsubscribe();
    }, [collectionPath]);
    // --- END: FIX #1 ---

    const handleSubmit = async () => {
        if (!newCommentText.trim()) return;
        setIsSubmitting(true);

        // --- START: FIX #2 - OPTIMISTIC UPDATE ---
        const optimisticComment = {
            id: `optimistic-${Date.now()}`,
            userId: currentUser.uid,
            userName: creatorProfile.creatorName,
            userProfilePicture: creatorProfile.profilePictureUrl || '',
            text: newCommentText.trim(),
            createdAt: { toDate: () => new Date() }, // Mock server timestamp
            replyTo: replyingTo ? { userName: replyingTo.name } : null
        };
        setComments(prev => [optimisticComment, ...prev]);
        setNewCommentText('');
        setReplyingTo(null);
        // --- END: FIX #2 ---
        
        try {
            const postComment = httpsCallable(functions, 'postComment'); 
            await postComment({
                itemId: item.id, itemType: itemType, text: optimisticComment.text,
                replyTo: replyingTo ? { commentId: replyingTo.id, userId: replyingTo.userId, userName: replyingTo.name } : null
            });
        } catch (error) {
            showMessage(`Error: ${error.message}`);
            // If the post fails, remove the optimistic comment
            setComments(prev => prev.filter(c => c.id !== optimisticComment.id));
        } finally {
            setIsSubmitting(false);
        }
    };
    
    const handleViewProfile = (userId) => { /* ... unchanged ... */ };
    const handleAddEmoji = (emoji) => setNewCommentText(prev => prev + emoji);
    const emojis = ['👍', '👎', '❤️', '😂', '🔥', '😢', '😡'];

    return (
        <div className="likesModalOverlay" onClick={(e) => e.target === e.currentTarget && onClose()}>
            <div className="commentsModalContent">
                <div className="likesModalHeader"><p className="likesModalTitle">Comments ({comments.length})</p><button className="closeButton" onClick={onClose}>×</button></div>
                <div className="commentsList">
                    {loading && comments.length === 0 && <p style={{textAlign: 'center'}}>Loading comments...</p>}
                    {!loading && comments.length === 0 && <p style={{textAlign: 'center'}}>Be the first to comment!</p>}
                    {comments.map(c => (
                        <div key={c.id} className="commentItem" style={{ opacity: c.id.startsWith('optimistic') ? 0.6 : 1 }}>
                            {/* ... the rest of the JSX is unchanged ... */}
                        </div>
                    ))}
                    {/* The "Load More" button is no longer needed with a real-time listener for this UI */}
                </div>
                <div className="commentInputContainer">
                    {/* ... the rest of the JSX is unchanged ... */}
                </div>
            </div>
        </div>
    );
};

// ======================================================================
// ========== END: ADD THIS ENTIRE NEW CommentsModal COMPONENT ==========
// ======================================================================


        // --- START: COMPLETE AND CORRECTED ProfilePictureAdjustModal ---
     const ProfilePictureAdjustModal = ({ isUploading, imageUrl, onSave, onCancel, showMessage }) => {
            const canvasRef = useRef(null);
            const imageRef = useRef(new Image());
            const [scale, setScale] = useState(1);
            const [position, setPosition] = useState({ x: 0, y: 0 });
            const [isDragging, setIsDragging] = useState(false);
            const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
            
            // --- START: NEW STATE FOR TOUCH GESTURES ---
            const [touchStartDistance, setTouchStartDistance] = useState(0);
            const [isPinching, setIsPinching] = useState(false);
            // --- END: NEW STATE FOR TOUCH GESTURES ---

            const canvasSize = 200;
            const profilePicSize = 300;

            const drawImage = useCallback(() => {
                const canvas = canvasRef.current; if (!canvas) return;
                const ctx = canvas.getContext('2d'); const img = imageRef.current;
                if (!img.complete || img.naturalWidth === 0) { ctx.clearRect(0, 0, canvas.width, canvas.height); return; }
                ctx.fillStyle = '#333'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.save();
                const devicePixelRatio = window.devicePixelRatio || 1;
                ctx.scale(devicePixelRatio, devicePixelRatio);
                ctx.beginPath(); ctx.arc(canvasSize / 2, canvasSize / 2, canvasSize / 2, 0, Math.PI * 2, true); ctx.clip();
                const scaledWidth = img.naturalWidth * scale; const scaledHeight = img.naturalHeight * scale;
                ctx.drawImage(img, position.x, position.y, scaledWidth, scaledHeight);
                ctx.restore();
            }, [scale, position, canvasSize]);
            
            useEffect(() => {
                const canvas = canvasRef.current; if (canvas) {
                    const devicePixelRatio = window.devicePixelRatio || 1;
                    canvas.width = canvasSize * devicePixelRatio; canvas.height = canvasSize * devicePixelRatio;
                    canvas.style.width = `${canvasSize}px`; canvas.style.height = `${canvasSize}px`;
                }
            }, [canvasSize]);

            useEffect(() => {
                const img = imageRef.current; img.crossOrigin = 'anonymous'; img.src = imageUrl;
                img.onload = () => {
                    const initialScale = Math.min(canvasSize / img.naturalWidth, canvasSize / img.naturalHeight); setScale(initialScale);
                    const initialX = (canvasSize - img.naturalWidth * initialScale) / 2;
                    const initialY = (canvasSize - img.naturalHeight * initialScale) / 2;
                    setPosition({ x: initialX, y: initialY });
                };
                img.onerror = () => { showMessage("Failed to load image for adjustment."); };
            }, [imageUrl, showMessage, canvasSize]);

            useEffect(() => { drawImage(); }, [scale, position, drawImage]);
            
            // --- MOUSE EVENT HANDLERS (Unchanged) ---
            const handleMouseDown = (e) => { setIsDragging(true); setDragStart({ x: e.clientX - position.x, y: e.clientY - position.y }); };
            const handleMouseMove = (e) => { if (!isDragging) return; setPosition({ x: e.clientX - dragStart.x, y: e.clientY - dragStart.y }); };
            const handleMouseUp = () => setIsDragging(false);
            const handleMouseLeave = () => setIsDragging(false);
            const handleWheel = (e) => {
                e.preventDefault(); const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
                const newScale = scale * zoomFactor; const rect = canvasRef.current.getBoundingClientRect();
                const mouseX = e.clientX - rect.left; const mouseY = e.clientY - rect.top;
                const newPosition = { x: mouseX - (mouseX - position.x) * zoomFactor, y: mouseY - (mouseY - position.y) * zoomFactor };
                setScale(newScale); setPosition(newPosition);
            };

            // --- START: NEW TOUCH EVENT HANDLERS ---
            const getTouchDistance = (touches) => {
                const touch1 = touches[0]; const touch2 = touches[1];
                return Math.sqrt(Math.pow(touch2.clientX - touch1.clientX, 2) + Math.pow(touch2.clientY - touch1.clientY, 2));
            };

            const handleTouchStart = (e) => {
                if (e.touches.length === 2) {
                    e.preventDefault(); setIsPinching(true); setIsDragging(false);
                    setTouchStartDistance(getTouchDistance(e.touches));
                } else if (e.touches.length === 1) {
                    setIsDragging(true); setIsPinching(false);
                    const touch = e.touches[0];
                    setDragStart({ x: touch.clientX - position.x, y: touch.clientY - position.y });
                }
            };
            
            const handleTouchMove = (e) => {
                if (isPinching && e.touches.length === 2) {
                    e.preventDefault();
                    const newDistance = getTouchDistance(e.touches);
                    const newScale = scale * (newDistance / touchStartDistance);
                    setScale(newScale);
                    setTouchStartDistance(newDistance); // Update for smooth continuous zoom
                } else if (isDragging && e.touches.length === 1) {
                    e.preventDefault();
                    const touch = e.touches[0];
                    setPosition({ x: touch.clientX - dragStart.x, y: touch.clientY - dragStart.y });
                }
            };

            const handleTouchEnd = (e) => {
                setIsDragging(false);
                setIsPinching(false);
            };
            // --- END: NEW TOUCH EVENT HANDLERS ---

            const saveCroppedImage = () => {
                // This logic remains unchanged
                const img = imageRef.current; if (!img.complete || img.naturalWidth === 0) { showMessage("Image not loaded."); return; }
                const outputCanvas = document.createElement('canvas'); outputCanvas.width = profilePicSize; outputCanvas.height = profilePicSize;
                const ctx = outputCanvas.getContext('2d'); ctx.beginPath(); ctx.arc(profilePicSize / 2, profilePicSize / 2, profilePicSize / 2, 0, Math.PI * 2, true); ctx.clip();
                const finalScale = scale * (profilePicSize / canvasSize);
                const finalX = position.x * (profilePicSize / canvasSize); const finalY = position.y * (profilePicSize / canvasSize);
                ctx.drawImage(img, finalX, finalY, img.naturalWidth * finalScale, img.naturalHeight * finalScale);
                outputCanvas.toBlob((blob) => { if (blob) { onSave(blob); } else { showMessage("Failed to create image file."); } }, 'image/png', 0.9);
            };

            return (
                <div className="imageAdjustModalOverlay">
                    <div className="imageAdjustModalContent">
                        <p className="heading" style={{fontSize: '20px', marginBottom: '10px'}}>Adjust Profile Picture</p>
                        <p className="subHeading" style={{fontSize: '14px', marginBottom: '15px', color: '#CCC'}}>Drag to pan, pinch to zoom.</p>
                        <div
                            className={`canvasContainer ${isDragging ? 'dragging' : ''}`}
                            onMouseDown={handleMouseDown}
                            onMouseMove={handleMouseMove}
                            onMouseUp={handleMouseUp}
                            onMouseLeave={handleMouseLeave}
                            onWheel={handleWheel}
                            // --- ADDED TOUCH EVENT LISTENERS ---
                            onTouchStart={handleTouchStart}
                            onTouchMove={handleTouchMove}
                            onTouchEnd={handleTouchEnd}
                        >
                            <canvas ref={canvasRef}></canvas>
                        </div>
                        <div className="modalButtons">
                            <button className="modalButton" onClick={saveCroppedImage} disabled={isUploading}>
                                {isUploading ? 'Uploading...' : 'Save'}
                            </button>
                            <button className="modalButton cancel" onClick={onCancel} disabled={isUploading}>Cancel</button>
                        </div>
                    </div>
                </div>
            );
        };
        // --- END: COMPLETE AND CORRECTED ProfilePictureAdjustModal

        // =================== START: FULL COMPONENT REPLACEMENT ===================
        const CreateCampaignScreen = ({ showMessage, setActiveScreen, currentUser, creatorProfile }) => {
            const [title, setTitle] = useState('');
            const [description, setDescription] = useState('');
            const [goal, setGoal] = useState('');
            const [duration, setDuration] = useState(30);
            const [projectLink, setProjectLink] = useState('');
            const [customThumbnailFile, setCustomThumbnailFile] = useState(null);
            const [customThumbnailPreview, setCustomThumbnailPreview] = useState('');
            const [autoThumbnailPreview, setAutoThumbnailPreview] = useState('');
            const [isUploading, setIsUploading] = useState(false);
            const thumbnailInputRef = useRef(null);
            
            // --- STATE and HANDLERS for Image Adjustment Modal ---
            const [showImageAdjustModal, setShowImageAdjustModal] = useState(false);
            const [imageFileToAdjust, setImageFileToAdjust] = useState(null);

            const handleThumbnailFileSelect = (e) => {
                const file = e.target.files[0];
                if (file) {
                    setImageFileToAdjust(file);
                    setShowImageAdjustModal(true);
                }
            };

            const handleThumbnailSave = (adjustedBlob) => {
                const newFile = new File([adjustedBlob], "campaign_thumbnail.png", { type: "image/png" });
                setCustomThumbnailFile(newFile);
                setCustomThumbnailPreview(URL.createObjectURL(newFile));
                setShowImageAdjustModal(false);
            };

            const handleThumbnailCancel = () => {
                setImageFileToAdjust(null);
                setShowImageAdjustModal(false);
                if (thumbnailInputRef.current) {
                    thumbnailInputRef.current.value = null;
                }
            };

            useEffect(() => {
                if (!projectLink) {
                    setAutoThumbnailPreview('');
                    return;
                }
                const handler = setTimeout(() => {
                    const { thumbnailUrl } = extractVideoInfo(projectLink);
                    if (thumbnailUrl && thumbnailUrl !== GENERIC_THUMBNAIL_PLACEHOLDER) {
                        setAutoThumbnailPreview(thumbnailUrl);
                    } else {
                        setAutoThumbnailPreview('');
                    }
                }, 800);

                return () => clearTimeout(handler);
            }, [projectLink]);

            const handleSubmit = async (e) => {
                e.preventDefault();
                if (!title || !description || !goal) {
                    showMessage('Please fill in all required fields: Title, Description, and Funding Goal.');
                    return;
                }
                if (isNaN(goal) || parseFloat(goal) <= 0) {
                    showMessage('Funding Goal must be a positive number.');
                    return;
                }

                setIsUploading(true);
                let finalImageUrl = '';

                if (customThumbnailFile) {
                    showMessage("Uploading custom thumbnail...");
                    try {
                        const filePath = `campaign_thumbnails/${currentUser.uid}/${Date.now()}_${customThumbnailFile.name}`;
                        const storageRef = ref(storage, filePath);
                        const snapshot = await uploadBytes(storageRef, customThumbnailFile);
                        finalImageUrl = await getDownloadURL(snapshot.ref);
                    } catch (error) {
                        showMessage(`Thumbnail upload failed: ${error.message}`);
                        setIsUploading(false);
                        return;
                    }
                } else if (autoThumbnailPreview) {
                    finalImageUrl = autoThumbnailPreview;
                }

                if (projectLink && !finalImageUrl) {
                    showMessage("Could not get a thumbnail from the Project Link. Please upload a custom thumbnail to continue.");
                    setIsUploading(false);
                    return;
                }
                
                const campaignsCollectionRef = collection(db, `artifacts/${appId}/public/data/campaigns`);
                const q = query(campaignsCollectionRef, where('creatorId', '==', currentUser.uid), where('status', 'in', ['active', 'pending']));
                const querySnapshot = await getDocs(q);

                if (!querySnapshot.empty) {
                    showMessage('You can only have one active or pending crowdfunding campaign at a time.');
                    setIsUploading(false);
                    return;
                }

                try {
                    const createdAt = new Date();
                    const endDate = new Date(createdAt);
                    endDate.setDate(createdAt.getDate() + parseInt(duration, 10));

                    await addDoc(campaignsCollectionRef, {
                        creatorId: currentUser.uid,
                        creatorName: creatorProfile.creatorName || currentUser.email,
                        creatorProfilePictureUrl: creatorProfile.profilePictureUrl || '',
                        title, description, goal: parseFloat(goal), raised: 0,
                        projectLink: projectLink, imageUrl: finalImageUrl,
                        createdAt: createdAt.toISOString(), endDate: endDate.toISOString(),
                        status: 'pending'
                    });

                    showMessage(`Campaign "${title}" submitted for review!`);
                    setActiveScreen('CreatorDashboard');
                } catch (error) {
                    showMessage(`Failed to create campaign: ${error.message}.`);
                } finally {
                    setIsUploading(false);
                }
            };
            
            const currentPreview = customThumbnailPreview || autoThumbnailPreview;

            return (
                <div className="screenContainer">
                    <p className="heading">Create New Campaign</p>
                    <p className="subHeading">Tell us about your project. It will be reviewed before going live.</p>
                    <form onSubmit={handleSubmit}>
                        <div className="formGroup"><label htmlFor="campaignTitle" className="formLabel">Campaign Title:</label><input type="text" id="campaignTitle" className="formInput" value={title} onChange={(e) => setTitle(e.target.value)} required /></div>
                        <div className="formGroup"><label htmlFor="campaignDescription" className="formLabel">Description:</label><textarea id="campaignDescription" className="formTextarea" value={description} onChange={(e) => setDescription(e.target.value)} placeholder="Describe your project, what you need funding for, etc." required></textarea></div>
                        <div className="formGroup"><label htmlFor="campaignGoal" className="formLabel">Funding Goal (USD):</label><input type="number" id="campaignGoal" className="formInput" value={goal} onChange={(e) => setGoal(e.target.value)} min="1" step="any" placeholder="e.g., 500" required /></div>
                        <div className="formGroup"><label htmlFor="campaignDuration" className="formLabel">Campaign Duration:</label><select id="campaignDuration" className="formInput" value={duration} onChange={(e) => setDuration(e.target.value)}><option value="7">1 Week</option><option value="14">2 Weeks</option><option value="21">3 Weeks</option><option value="30">30 Days (Max)</option></select></div>
                        <div className="formGroup"><label htmlFor="projectLink" className="formLabel">Project Link (Optional):</label><input type="url" id="projectLink" className="formInput" value={projectLink} onChange={(e) => setProjectLink(e.target.value)} placeholder="e.g., YouTube, Facebook video link" /><p className="smallText" style={{textAlign: 'left', color: '#AAA', marginTop: '5px'}}>We'll try to generate a thumbnail from this link.</p></div>
                        <div className="formGroup"><label className="formLabel">Campaign Thumbnail:</label>{currentPreview && ( <div style={{ marginBottom: '15px' }}><img src={currentPreview} alt="Thumbnail Preview" style={{ maxWidth: '100%', borderRadius: '8px', border: '2px solid #FFD700' }} /></div>)}
                            <input type="file" ref={thumbnailInputRef} onChange={handleThumbnailFileSelect} accept="image/*" style={{ display: 'none' }} />
                            <button type="button" className="button" onClick={() => thumbnailInputRef.current.click()} style={{ width: '100%', backgroundColor: '#3A3A3A' }}><span className="buttonText">{customThumbnailFile ? 'Change' : 'Upload'} Custom Thumbnail</span></button>
                             <p className="smallText" style={{textAlign: 'center', color: '#AAA', marginTop: '5px'}}>Recommended size: 1280x720 pixels.</p>
                        </div>
                        <div className="formGroup"><p className="smallText" style={{textAlign: 'center', color: '#FFD700', lineHeight: 1.5}}>Please note: Upon successful completion or expiration of a campaign, a 30-day cooldown will apply before you can create a new one.</p></div>
                        <button type="submit" className="button" disabled={isUploading}><span className="buttonText">{isUploading ? 'Submitting...' : 'Submit for Review'}</span></button>
                    </form>
                    <button className="button" onClick={() => setActiveScreen('CreatorDashboard')} style={{ backgroundColor: '#555', marginTop: '20px' }}><span className="buttonText">Back to Dashboard</span></button>
                    {showImageAdjustModal && imageFileToAdjust && (
                        <ProfilePictureAdjustModal
                            imageUrl={URL.createObjectURL(imageFileToAdjust)}
                            onSave={handleThumbnailSave}
                            onCancel={handleThumbnailCancel}
                            showMessage={showMessage}
                            isUploading={isUploading}
                        />
                    )}
                </div>
            );
        };
// =================== END: FULL COMPONENT REPLACEMENT =====================

        const AllCampaignsScreen = ({ showMessage, setActiveScreen, setSelectedCampaignId, selectedCurrency, currencyRates }) => {
            const [campaigns, setCampaigns] = useState([]);
            const [loading, setLoading] = useState(true);
            const [searchTerm, setSearchTerm] = useState('');
            const PLATFORM_FEE_PERCENTAGE = 0.07; 

            useEffect(() => {
                const campaignsCollectionRef = collection(db, `artifacts/${appId}/public/data/campaigns`);
                const q = query(
                    campaignsCollectionRef,
                    where('status', '==', 'active'),
                    orderBy('createdAt', 'desc')
                );

                const unsubscribe = onSnapshot(q, (snapshot) => {
                    const fetchedCampaigns = snapshot.docs.map(doc => ({
                        id: doc.id,
                        ...doc.data()
                    }));
                    setCampaigns(fetchedCampaigns);
                    setLoading(false);
                }, (error) => {
                    console.error("Error fetching campaigns:", error);
                    showMessage("Failed to load campaigns. Please try again.");
                    setLoading(false);
                });

                return () => unsubscribe();
            }, []);

            if (loading) {
                return (
                    <div className="screenContainer" style={{ textAlign: 'center', paddingTop: '50px' }}>
                        <p className="heading">Loading Campaigns...</p>
                        <p className="subHeading" style={{ color: '#FFD700' }}>Please ensure you have an internet connection.</p>
                    </div>
                );
            }

            const filteredCampaigns = campaigns.filter(campaign => 
                campaign.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
                campaign.creatorName.toLowerCase().includes(searchTerm.toLowerCase())
            );

            return (
                <div className="screenContainer">
                    <p className="heading">All Campaigns</p>
                    <p className="subHeading">Discover and support projects by Caribbean creators!</p>
                    <div className="formGroup" style={{ marginTop: '10px', marginBottom: '20px' }}>
                        <input
                            type="text"
                            className="formInput"
                            placeholder="Search by title or creator name..."
                            value={searchTerm}
                            onChange={(e) => setSearchTerm(e.target.value)}
                        />
                    </div>

                    {campaigns.length === 0 ? (
                        <p className="paragraph" style={{ textAlign: 'center', marginTop: '20px' }}>No active campaigns found yet.</p>
                    ) : filteredCampaigns.length === 0 ? (
                        <p className="paragraph" style={{ textAlign: 'center', marginTop: '20px' }}>No campaigns found matching "{searchTerm}".</p>
                    ) : (
                        <div className="allCampaignsList">
                            {filteredCampaigns.map(campaign => {
                                const isEnded = new Date(campaign.endDate) < new Date();
                                return (
                                    <div
                                        key={campaign.id}
                                        className="allCampaignsListItem"
                                        onClick={() => {
                                            setSelectedCampaignId(campaign.id);
                                            setActiveScreen('CampaignDetails');
                                        }}
                                    >
                                        <div
                                            className="campaignListImagePlaceholder"
                                            style={{ backgroundImage: campaign.imageUrl ? `url(${campaign.imageUrl})` : 'none' }}
                                            onError={(e) => { e.target.onerror = null; e.target.style.backgroundImage='none'; }}
                                        >
                                            <button
                                                className="campaignListProjectButton"
                                                onClick={(e) => {
                                                    e.stopPropagation();
                                                    if (campaign.projectLink) {
                                                        window.open(campaign.projectLink, '_blank');
                                                    } else {
                                                        showMessage('No project link provided for this campaign.');
                                                    }
                                                }}
                                            >
                                                View Project
                                            </button>
                                        </div>
                                        <div className="campaignListContent">
                                            <p className="campaignListTitle">
                                                {campaign.title} {isEnded && <span style={{color: '#DC3545', fontSize: '12px'}}>(Ended)</span>}
                                            </p>
                                            <div className="campaignListCreator">
                                                <img
                                                    src={campaign.creatorProfilePictureUrl || 'https://placehold.co/100x100/555/FFF?text=Profile'}
                                                    alt={campaign.creatorName}
                                                    className="campaignListCreatorProfilePic"
                                                    onError={(e) => { e.target.onerror = null; e.target.src='https://placehold.co/24x24/555/FFF?text=P'; }}
                                                />
                                                <span>by {campaign.creatorName}</span>
                                            </div>
                                            <p className="campaignListDescription">{campaign.description}</p>
                                            <div className="campaignProgressContainer" style={{ height: '8px', marginBottom: '5px' }}>
                                                <div
                                                    className="campaignProgressBar"
                                                    style={{ width: `${(campaign.raised / campaign.goal) * 100}%` }}
                                                ></div>
                                            </div>
                                            <div className="campaignListStats">
                                                <span>
                                                    Raised: <span className="campaignListRaised">{formatCurrency(campaign.raised, selectedCurrency, currencyRates)}</span>
                                                    <div className="fee-info-container">
                                                        <span className="fee-info-icon">i</span>
                                                        <div className="fee-info-tooltip">
                                                            The 'Raised' amount is the total collected. Creator receives {((1 - PLATFORM_FEE_PERCENTAGE) * 100).toFixed(0)}% of this total after the platform fee.
                                                        </div>
                                                    </div>
                                                </span>
                                                <span>Goal: <span className="campaignListGoal">{formatCurrency(campaign.goal, selectedCurrency, currencyRates)}</span></span>
                                            </div>
                                        </div>
                                    </div>
                                );
                            })}
                        </div>
                    )}
                    <button
                        className="button"
                        onClick={() => setActiveScreen('Support')}
                        style={{ backgroundColor: '#3A3A3A', color: '#FFF', marginTop: '30px' }}
                    >
                        <span className="buttonText">Back to Support Us</span>
                    </button>
                </div>
            );
        };

         const CampaignDetailsScreen = ({ showMessage, setActiveScreen, selectedCampaignId, currentUser, setPledgeContext, selectedCurrency, currencyRates }) => {
            const [campaign, setCampaign] = useState(null);
            const [loading, setLoading] = useState(true);
            const campaignImageRef = useRef(null); // Ref to the image element

            useEffect(() => {
                const fetchCampaignDetails = async () => {
                    if (!selectedCampaignId) {
                        showMessage("No campaign selected.");
                        setActiveScreen('AllCampaigns');
                        return;
                    }

                    try {
                        const campaignDocRef = doc(db, `artifacts/${appId}/public/data/campaigns`, selectedCampaignId);
                        const docSnap = await getDoc(campaignDocRef);

                        if (docSnap.exists()) {
                            setCampaign({ id: docSnap.id, ...docSnap.data() });
                        } else {
                            showMessage("Campaign not found.");
                            setActiveScreen('AllCampaigns');
                        }
                        setLoading(false);
                    } catch (error) {
                        console.error("Error fetching campaign details:", error);
                        showMessage("Failed to load campaign details. Please try again.");
                        setLoading(false);
                        setActiveScreen('AllCampaigns');
                    }
                };

                fetchCampaignDetails();
            }, [selectedCampaignId, setActiveScreen, showMessage]);

            const handleSupportCampaign = () => {
                if (!campaign) return;

                const isEnded = new Date(campaign.endDate) < new Date();
                if (isEnded || campaign.status !== 'active') {
                    showMessage("This campaign is not active and cannot receive donations.");
                    return;
                }
                if (!currentUser) {
                    showMessage("Please log in to support a campaign.");
                    setActiveScreen('Login');
                    return;
                }

                setPledgeContext({
                    type: 'donation',
                    campaignId: campaign.id,
                    campaignTitle: campaign.title,
                    creatorName: campaign.creatorName,
                    amount: '' // Start with an empty amount
                });
                setActiveScreen('DonationPledge');
            };

            if (loading) {
                return (
                    <div className="screenContainer" style={{ textAlign: 'center', paddingTop: '50px' }}>
                        <p className="heading">Loading Campaign Details...</p>
                        <p className="subHeading" style={{ color: '#FFD700' }}>Please ensure you have an internet connection.</p>
                    </div>
                );
            }

            if (!campaign) {
                return null;
            }

            const progressPercentage = (campaign.raised / campaign.goal) * 100;
            const isCampaignEnded = new Date(campaign.endDate) < new Date();
            const daysRemaining = Math.ceil((new Date(campaign.endDate).getTime() - new Date().getTime()) / (1000 * 60 * 60 * 24));
            const isCampaignActive = campaign.status === 'active' && !isCampaignEnded;


            return (
                <div className="screenContainer">
                    <div className="campaignDetailHeader">
                        <img
                            ref={campaignImageRef}
                            src={campaign.imageUrl}
                            alt={campaign.title}
                            className="campaignDetailImage"
                            onError={(e) => { e.target.style.display = 'none'; }}
                            style={{ display: campaign.imageUrl ? 'block' : 'none' }}
                        />
                        <p className="campaignDetailTitle">
                            {campaign.title}
                            {isCampaignEnded && <span style={{color: '#DC3545', fontSize: '16px', marginLeft: '10px'}}>(Ended)</span>}
                            {!isCampaignEnded && campaign.status === 'pending' && <span style={{color: '#FFD700', fontSize: '16px', marginLeft: '10px'}}>(Pending Review)</span>}
                            {!isCampaignEnded && campaign.status === 'rejected' && <span style={{color: '#DC3545', fontSize: '16px', marginLeft: '10px'}}>(Rejected)</span>}
                            {!isCampaignEnded && campaign.status === 'active' && <span style={{color: '#00FF00', fontSize: '16px', marginLeft: '10px'}}>(Active)</span>}
                            {!isCampaignEnded && campaign.status === 'cancelled' && <span style={{color: '#888', fontSize: '16px', marginLeft: '10px'}}>(Cancelled)</span>}
                        </p>
                        <div className="campaignDetailCreator">
                            <img
                                src={campaign.creatorProfilePictureUrl || 'https://placehold.co/100x100/555/FFF?text=Profile'}
                                alt={campaign.creatorName}
                                className="campaignDetailCreatorProfilePic"
                                onError={(e) => { e.target.onerror = null; e.target.src='https://placehold.co/32x32/555/FFF?text=P'; }}
                            />
                            <span>by {campaign.creatorName}</span>
                        </div>
                    </div>

                    <p className="campaignDetailDescription">{campaign.description}</p>

                    <div className="campaignDetailStats">
                        <div className="campaignDetailStatItem">
                            <p className="campaignDetailStatValue" style={{fontSize: '16px'}}>{formatCurrency(campaign.raised, selectedCurrency, currencyRates)}</p>
                            <p>Raised</p>
                        </div>
                        <div className="campaignDetailStatItem">
                            <p className="campaignDetailStatValue" style={{fontSize: '16px'}}>{formatCurrency(campaign.goal, selectedCurrency, currencyRates)}</p>
                            <p>Goal</p>
                        </div>
                        <div className="campaignDetailStatItem">
                            <p className="campaignDetailStatValue">{Math.round(progressPercentage)}%</p>
                            <p>Progress</p>
                        </div>
                    </div>
                    <div className="campaignDetailProgressBarContainer">
                        <div className="campaignDetailProgressBar" style={{ width: `${progressPercentage}%` }}></div>
                    </div>

                    {isCampaignEnded ? (
                        <p className="smallText" style={{ textAlign: 'center', color: '#DC3545', marginTop: '10px' }}>
                            This campaign ended on {new Date(campaign.endDate).toLocaleDateString()}.
                        </p>
                    ) : (
                        <p className="smallText" style={{ textAlign: 'center', color: '#00FF00', marginTop: '10px' }}>
                            {daysRemaining > 0 ? `${daysRemaining} days remaining` : 'Campaign ending soon!'}
                        </p>
                    )}

                    <div style={{ display: 'flex', justifyContent: 'center', gap: '10px', flexWrap: 'wrap', marginTop: '20px' }}>
                        <button
                            className="button"
                            onClick={handleSupportCampaign}
                            disabled={!isCampaignActive}
                            style={!isCampaignActive ? { backgroundColor: '#555', cursor: 'not-allowed', margin: 0 } : { margin: 0 }}
                        >
                            <span className="buttonText">{isCampaignEnded ? 'Campaign Ended' : (campaign.status === 'pending' ? 'Pending Review' : (campaign.status === 'rejected' ? 'Campaign Rejected' : (campaign.status === 'cancelled' ? 'Campaign Cancelled' : 'Support This Campaign')))}</span>
                        </button>

                        {campaign.projectLink && (
                        <button
                            className="button"
                            onClick={() => window.open(campaign.projectLink, '_blank')}
                            style={{ backgroundColor: '#3A3A3A', margin: 0 }}
                        >
                            <span className="buttonText light">Visit Project Link</span>
                        </button>
                        )}

                        <button
                            className="button"
                            onClick={() => setActiveScreen('AllCampaigns')}
                            style={{ backgroundColor: '#3A3A3A', margin: 0 }}
                        >
                            <span className="buttonText light">Back to All Campaigns</span>
                        </button>
                    </div>
            </div>
            );
        };

const DataCorrectionTool = ({ showMessage }) => {
    const [isScanning, setIsScanning] = useState(false);
    const [scanResults, setScanResults] = useState('');

    const runCountCorrection = async () => {
        setIsScanning(true);
        setScanResults('Starting scan... This may take a moment.');
        showMessage('Starting data integrity scan...');

        try {
            const creatorsRef = collection(db, "creators");
            const querySnapshot = await getDocs(creatorsRef);
            let followersCorrected = 0;
            let followingCorrected = 0;
            let usersScanned = 0;

            for (const userDoc of querySnapshot.docs) {
                const userData = userDoc.data();
                const userId = userDoc.id;
                
                // 1. Check Followers
                const followersRef = collection(db, "creators", userId, "followers");
                const followersSnapshot = await getDocs(followersRef);
                const actualFollowerCount = followersSnapshot.size;
                const storedFollowerCount = userData.followerCount || 0;

                if (actualFollowerCount !== storedFollowerCount) {
                    await updateDoc(doc(db, "creators", userId), { followerCount: actualFollowerCount });
                    followersCorrected++;
                }
                
                // 2. Check Following
                const followingRef = collection(db, "creators", userId, "following");
                const followingSnapshot = await getDocs(followingRef);
                const actualFollowingCount = followingSnapshot.size;
                const storedFollowingCount = userData.followingCount || 0;
                
                if (actualFollowingCount !== storedFollowingCount) {
                    await updateDoc(doc(db, "creators", userId), { followingCount: actualFollowingCount });
                    followingCorrected++;
                }
                
                usersScanned++;
            }

            const resultsMessage = `Scan Complete. Scanned ${usersScanned} users. Corrected ${followersCorrected} follower counts and ${followingCorrected} following counts.`;
            setScanResults(resultsMessage);
            showMessage('Scan complete!');

        } catch (error) {
            console.error("Error during count correction:", error);
            const errorMessage = `An error occurred: ${error.message}`;
            setScanResults(errorMessage);
            showMessage(errorMessage);
        } finally {
            setIsScanning(false);
        }
    };

    return (
        <div className="dashboardSection" style={{ border: '2px solid #DC3545', marginTop: '20px' }}>
            <p className="dashboardSectionTitle">Data Correction Tools</p>
            <p className="dashboardItem" style={{ color: '#AAA', marginBottom: '15px' }}>
                Use this tool if you suspect that follower or following counts are incorrect for some users.
            </p>
            <button
                className="button"
                onClick={runCountCorrection}
                disabled={isScanning}
                style={{ backgroundColor: '#FF8C00' }}
            >
                <span className="buttonText">{isScanning ? 'Scanning...' : 'Recalculate All Follow Counts'}</span>
            </button>
            {scanResults && (
                <p className="paragraph" style={{ marginTop: '15px', backgroundColor: '#1A1A1A', padding: '10px', borderRadius: '5px' }}>
                    {scanResults}
                </p>
            )}
        </div>
    );
};

// AdminDashboardScreen Component
const AdminDashboardScreen = ({
    showMessage,
    setActiveScreen,
    featuredContentSlots,
    currentUser,
    setSelectedAdminCampaignId,
    creatorProfile,
    selectedAdminSubScreen,
    setSelectedAdminSubScreen,
    setShowConfirmationModal,
    setConfirmationTitle,
    setConfirmationMessage,
    setOnConfirmationAction,
    setSelectedUserId,
    setSelectedOpportunity,
    setSelectedStatus, 
    setSelectedCompAdmin,
    setSelectedReportGroup // This is the new prop
}) => {

    const [isUserManagementExpanded, setIsUserManagementExpanded] = useState(true);
    const [pledgeSortType, setPledgeSortType] = useState('date');
    const [pendingPledges, setPendingPledges] = useState([]);
    const [loadingPledges, setLoadingPledges] = useState(true);
    const [isPaymentsExpanded, setIsPaymentsExpanded] = useState(true);
    const [liveStatus, setLiveStatus] = useState(null);
    const [pendingOpportunities, setPendingOpportunities] = useState([]);
    const [loadingOpportunities, setLoadingOpportunities] = useState(true);
    const [activeOpportunities, setActiveOpportunities] = useState([]);
    const [loadingActiveOpportunities, setLoadingActiveOpportunities] = useState(true);
    const [isActiveOpportunitiesExpanded, setIsActiveOpportunitiesExpanded] = useState(true);

    // New state for holding the counts for notification badges
    const [pendingReportsCount, setPendingReportsCount] = useState(0);
    const [pendingAppealsCount, setPendingAppealsCount] = useState(0);
    const [pendingCampaignsCount, setPendingCampaignsCount] = useState(0); // ADDED
    const [pendingOpportunitiesCount, setPendingOpportunitiesCount] = useState(0); // ADDED

     // This dedicated hook fetches counts for the UI badges without fetching full data.
    useEffect(() => {
        if (!creatorProfile || (creatorProfile.role !== 'admin' && creatorProfile.role !== 'authority')) {
            return; // Don't run for non-moderators
        }

        // Listener for pending reports
        const reportsRef = collection(db, "reports");
        const qReports = query(reportsRef, where("status", "==", "pending"));
        const unsubReports = onSnapshot(qReports, (snapshot) => {
            setPendingReportsCount(snapshot.size);
        });

        // Listener for pending appeals
        const appealsRef = collection(db, "appeals");
        const qAppeals = query(appealsRef, where("status", "==", "pending"));
        const unsubAppeals = onSnapshot(qAppeals, (snapshot) => {
            setPendingAppealsCount(snapshot.size);
        });
        
        // NEW: Listener for pending campaigns
        const campaignsRef = collection(db, `artifacts/${appId}/public/data/campaigns`);
        const qCampaigns = query(campaignsRef, where("status", "==", "pending"));
        const unsubCampaigns = onSnapshot(qCampaigns, (snapshot) => {
            setPendingCampaignsCount(snapshot.size);
        });
        
        // NEW: Listener for pending opportunities
        const opportunitiesRef = collection(db, "opportunities");
        const qOpportunities = query(opportunitiesRef, where("status", "==", "pending"));
        const unsubOpportunities = onSnapshot(qOpportunities, (snapshot) => {
            setPendingOpportunitiesCount(snapshot.size);
        });

        // Cleanup all listeners on component unmount
        return () => {
            unsubReports();
            unsubAppeals();
            unsubCampaigns();
            unsubOpportunities();
        };
    }, [creatorProfile]); // Re-run if the user's role changes
// =================== END REPLACEMENT BLOCK (Action 2 of 4) =====================


    const [pendingStatuses, setPendingStatuses] = useState([]);
    const [loadingStatuses, setLoadingStatuses] = useState(true);
   
         // This single, consolidated hook manages all data fetching for the dashboard.
    useEffect(() => {
        // These listeners run for any user to fetch general user/ban data.
        const usersCollectionRef = collection(db, "creators");
        const unsubUsers = onSnapshot(usersCollectionRef, (snapshot) => {
            setAllUsers(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
            setLoading(false); // Main loading state
        });

        const banRequestsRef = collection(db, "banRequests");
        const qBans = query(banRequestsRef, where('status', '==', 'pending'));
        const unsubBanRequests = onSnapshot(qBans, (snapshot) => {
            setBanRequests(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
        });

        // These listeners ONLY run if the user is a moderator.
        let unsubOpportunities = () => {};
        let unsubActiveOpportunities = () => {};
        let unsubStatuses = () => {};
        if (creatorProfile && (creatorProfile.role === 'admin' || creatorProfile.role === 'authority')) {
            const opportunitiesRef = collection(db, "opportunities");
            const qPendingOps = query(opportunitiesRef, where('status', '==', 'pending'), orderBy('createdAt', 'asc'));
            unsubOpportunities = onSnapshot(qPendingOps, (snapshot) => {
                setPendingOpportunities(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
                setLoadingOpportunities(false);
            });
            const qActiveOps = query(opportunitiesRef, where('status', '==', 'active'), orderBy('createdAt', 'desc'));
            unsubActiveOpportunities = onSnapshot(qActiveOps, (snapshot) => {
                setActiveOpportunities(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
                setLoadingActiveOpportunities(false);
            });

            const statusesRef = collection(db, "promotedStatuses");
            const qStatuses = query(statusesRef, where('status', '==', 'content_review_pending'), orderBy('startTime', 'asc'));
            unsubStatuses = onSnapshot(qStatuses, (snapshot) => {
                setPendingStatuses(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
                setLoadingStatuses(false);
            }, (error) => {
                console.error("Error fetching pending statuses:", error);
                setLoadingStatuses(false);
            });
        } else {
            setLoadingOpportunities(false);
            setLoadingActiveOpportunities(false);
            setLoadingStatuses(false);
        }
        
        // This is the single, correct cleanup function for all listeners.
        return () => {
            unsubUsers();
            unsubBanRequests();
            unsubOpportunities();
            unsubActiveOpportunities();
            unsubStatuses();
        };
    }, [creatorProfile]); // This hook now correctly depends only on creatorProfile.
// =================== END REPLACEMENT ===================

    // Hook for admin-only data (payments)
    useEffect(() => {
        if (!creatorProfile || creatorProfile.role !== 'admin') {
            setLoadingPledges(false);
            return;
        }
        const pledgesRef = collection(db, "paymentPledges");
        const qPledges = query(pledgesRef, where('status', '==', 'pending'), orderBy('createdAt', 'asc'));
        const unsubPledges = onSnapshot(qPledges, (snapshot) => {
            setPendingPledges(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
            setLoadingPledges(false);
        });

        return () => unsubPledges();
    }, [creatorProfile]);

    // Hook for the LIVE billboard status
    useEffect(() => {
        if (!creatorProfile || creatorProfile.role !== 'admin') return;
        const statusesRef = collection(db, "promotedStatuses");
        const now = new Date();
        const q = query(
            statusesRef,
            where("status", "==", "approved_and_scheduled"),
            where("startTime", "<=", now),
            where("expiresAt", ">", now),
            limit(1)
        );
        const unsubscribe = onSnapshot(q, (snapshot) => {
            if (!snapshot.empty) {
                setLiveStatus({ id: snapshot.docs[0].id, ...snapshot.docs[0].data() });
            } else {
                setLiveStatus(null);
            }
        });
        return () => unsubscribe();
    }, [creatorProfile]);

    const handleApprovePledge = async (pledgeId) => {
   
           showMessage(`Approving pledge ${pledgeId}...`);
        try {
            const functions = getFunctions(window.firebaseApp);
            const approvePledgeCallable = httpsCallable(functions, 'approvePledge');
            const result = await approvePledgeCallable({ pledgeId: pledgeId, appId: appId });
            showMessage(result.data.message);
        } catch (error) {
            console.error("Error calling approvePledge function:", error);
            showMessage(`Error: ${error.message}`);
        }
    };

    const denyPledgeLogic = async (pledgeId) => {
        showMessage(`Denying pledge...`);
        try {
            await deleteDoc(doc(db, "paymentPledges", pledgeId));
            showMessage("Pledge denied and removed successfully.");
        } catch (error) {
            console.error("Error denying pledge:", error);
            showMessage(`Error denying pledge: ${error.message}`);
        }
    };

    const confirmDenyPledge = (pledge) => {
        setConfirmationTitle("Deny Pledge?");
        setConfirmationMessage(`Are you sure you want to deny and permanently delete this pledge from ${pledge.userName} for $${pledge.amount.toFixed(2)}? This action will notify the user and cannot be undone.`);
        setOnConfirmationAction(() => () => denyPledgeLogic(pledge.id));
        setShowConfirmationModal(true);
    };

    const [isPendingCampaignsExpanded, setIsPendingCampaignsExpanded] = useState(true);
    const [isActiveCampaignsExpanded, setIsActiveCampaignsExpanded] = useState(true);
    const [searchTerm, setSearchTerm] = useState('');
    const [selectedRole, setSelectedRole] = useState('All');
    const [pendingCampaigns, setPendingCampaigns] = useState([]);
    const [activeCampaigns, setActiveCampaigns] = useState([]);
    const [allUsers, setAllUsers] = useState([]);
    const [loading, setLoading] = useState(true);
    const [isUpdatingRole, setIsUpdatingRole] = useState(null);
    const [banRequests, setBanRequests] = useState([]);
    const [isSubmittingRequest, setIsSubmittingRequest] = useState(null);
    const [isCorrectingCount, setIsCorrectingCount] = useState(null);
    const [isUpdatingVerified, setIsUpdatingVerified] = useState(null);
    const [pledgeSearchTerm, setPledgeSearchTerm] = useState(''); // This is the new state for the pledge search


    const changeUserRoleLogic = async (targetUser, newRole) => { setIsUpdatingRole(targetUser.id); showMessage(`Updating role for ${targetUser.creatorName || targetUser.email}...`); try { const userDocRef = doc(db, "creators", targetUser.id); await updateDoc(userDocRef, { role: newRole }); showMessage(`Success! ${targetUser.creatorName || targetUser.email} is now a(n) ${newRole}.`); } catch (error) { console.error("Error changing user role:", error); showMessage(`Error: ${error.message}`); } finally { setIsUpdatingRole(null); } };
    const confirmChangeUserRole = (targetUser, newRole) => { setConfirmationTitle("Change User Role?"); setConfirmationMessage(`Are you sure you want to change ${targetUser.creatorName || targetUser.email}'s role to "${newRole}"?`); setOnConfirmationAction(() => () => changeUserRoleLogic(targetUser, newRole)); setShowConfirmationModal(true); };
    const toggleBanLogic = async (userToBan) => { if (userToBan.id === currentUser.uid) { showMessage("You cannot ban your own account."); return; } if (creatorProfile.role === 'authority' && userToBan.role === 'authority') { setIsSubmittingRequest(userToBan.id); try { const banRequestRef = collection(db, "banRequests"); await addDoc(banRequestRef, { requesterId: currentUser.uid, requesterName: creatorProfile.creatorName, targetUserId: userToBan.id, targetUserName: userToBan.creatorName || userToBan.email, status: 'pending', timestamp: new Date().toISOString() }); showMessage(`Ban request for ${userToBan.creatorName || userToBan.email} has been submitted for Admin approval.`); } catch (error) { console.error("Error submitting ban request:", error); showMessage(`Failed to submit ban request: ${error.message}`); } finally { setIsSubmittingRequest(null); } return; } if (creatorProfile.role === 'authority' && userToBan.role === 'admin') { showMessage("Authority users cannot ban Admin accounts."); return; } try { const userDocRef = doc(db, "creators", userToBan.id); await updateDoc(userDocRef, { banned: !userToBan.banned, updatedAt: new Date().toISOString() }); showMessage(`${userToBan.banned ? 'Unbanned' : 'Banned'} user: ${userToBan.creatorName || userToBan.email}`); } catch (error) { console.error("Error toggling ban status:", error); showMessage(`Failed to toggle ban status: ${error.message}`); } };
    const confirmToggleBan = (userToBan) => { const action = userToBan.banned ? 'Unban' : 'Ban'; const targetUserText = userToBan.creatorName || userToBan.email; if (creatorProfile.role === 'authority' && userToBan.role === 'authority') { setConfirmationTitle('Request Authority Ban?'); setConfirmationMessage(`This will submit a request for an Admin to ban ${targetUserText}. Proceed?`); } else { setConfirmationTitle(`${action} User?`); setConfirmationMessage(`Are you sure you want to ${action.toLowerCase()} user ${targetUserText}?`); } setOnConfirmationAction(() => () => toggleBanLogic(userToBan)); setShowConfirmationModal(true); };
    const handleApproveBanRequest = async (request) => { try { const userToBanRef = doc(db, "creators", request.targetUserId); const requestRef = doc(db, "banRequests", request.id); await updateDoc(userToBanRef, { banned: true }); await deleteDoc(requestRef); showMessage(`Request approved. User ${request.targetUserName} has been banned.`); } catch (error) { console.error("Error approving ban request:", error); showMessage(`Failed to approve ban request: ${error.message}`); } };
    const handleDenyBanRequest = async (request) => { try { await deleteDoc(doc(db, "banRequests", request.id)); showMessage(`Request to ban ${request.targetUserName} has been denied.`); } catch (error) { console.error("Error denying ban request:", error); showMessage(`Failed to deny ban request: ${error.message}`); } };
    const toggleSection = (setterFunction, currentState) => { setterFunction(!currentState); };

    // ======================================================================
    // ============= START: ADD THIS NEW HANDLER FUNCTION ===================
    // ======================================================================

    const [showExpiryModal, setShowExpiryModal] = useState(false);
    const [userToVerify, setUserToVerify] = useState(null);

    const handleOpenExpiryModal = (user) => {
        setUserToVerify(user);
        setShowExpiryModal(true);
    };

    const handleSetExpiry = async (durationInMonths) => {
        if (!userToVerify) return;
        setIsUpdatingVerified(userToVerify.id);
        setShowExpiryModal(false);
        try {
            const setStatusFunction = httpsCallable(functions, 'setVerifiedAdvertiserStatus');
            await setStatusFunction({ userId: userToVerify.id, durationInMonths: durationInMonths });
            showMessage(`${userToVerify.creatorName}'s status is set to Verified Advertiser for ${durationInMonths} month(s).`);
        } catch (error) {
            showMessage(`Error setting status: ${error.message}`);
        } finally {
            setIsUpdatingVerified(null);
            setUserToVerify(null);
        }
    };

    const handleRevokeVerified = async (user) => {
        setIsUpdatingVerified(user.id);
        try {
            const revokeFunction = httpsCallable(functions, 'revokeVerifiedAdvertiserStatus');
            await revokeFunction({ userId: user.id });
            showMessage(`${user.creatorName}'s Verified Advertiser status has been revoked.`);
        } catch (error) {
            showMessage(`Error revoking status: ${error.message}`);
        } finally {
            setIsUpdatingVerified(null);
        }
    };

    // This function is now a simple router to the correct new handler
    const handleToggleVerified = (user) => {
        // If they are currently verified, the only option is to revoke.
        if (user.isVerifiedAdvertiser) {
            setOnConfirmationAction(() => () => handleRevokeVerified(user));
            setConfirmationTitle("Revoke Verification?");
            setConfirmationMessage(`Are you sure you want to immediately revoke Verified Advertiser status for ${user.creatorName}?`);
            setShowConfirmationModal(true);
        } else {
            // If they are not verified, open the modal to set a duration.
            handleOpenExpiryModal(user);
        }
    };

    // ======================================================================
    // ============== END: ADD THIS NEW HANDLER FUNCTION ====================
    // ======================================================================

    useEffect(() => { const campaignsCollectionRef = collection(db, `artifacts/${appId}/public/data/campaigns`); const qPending = query(campaignsCollectionRef, where('status', '==', 'pending'), orderBy('createdAt', 'asc')); const unsubscribePending = onSnapshot(qPending, (snapshot) => { setPendingCampaigns(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }))); }); const qActive = query(campaignsCollectionRef, where('status', '==', 'active'), orderBy('createdAt', 'desc')); const unsubscribeActive = onSnapshot(qActive, (snapshot) => { setActiveCampaigns(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }))); }); const usersCollectionRef = collection(db, "creators"); const unsubscribeUsers = onSnapshot(usersCollectionRef, (snapshot) => { setAllUsers(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }))); setLoading(false); }); let unsubscribeBanRequests = () => {}; if (creatorProfile && creatorProfile.role === 'admin') { const banRequestsRef = collection(db, "banRequests"); const q = query(banRequestsRef, where('status', '==', 'pending')); unsubscribeBanRequests = onSnapshot(q, (snapshot) => { setBanRequests(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }))); }); } return () => { unsubscribePending(); unsubscribeActive(); unsubscribeUsers(); unsubscribeBanRequests(); }; }, [creatorProfile]);
    
    if (!currentUser || !creatorProfile || (creatorProfile.role !== 'admin' && creatorProfile.role !== 'authority')) { return ( <div className="screenContainer"> <p className="heading">Access Denied</p> <p className="subHeading">You must be an Admin or Authority to view this dashboard.</p> <button className="button" onClick={() => setActiveScreen('Login')}><span className="buttonText">Go to Login</span></button> </div> ); }
    if (loading) { return ( <div className="screenContainer" style={{ textAlign: 'center', paddingTop: '50px' }}> <p className="heading">Loading Admin Dashboard...</p> <p className="subHeading" style={{ color: '#FFD700' }}>Please wait.</p> </div> ); }
    const filteredUsers = allUsers.filter(user => {
        if (creatorProfile.role === 'authority' && user.role === 'admin') {
            return false;
        }
        const matchesSearchTerm = searchTerm === '' || (user.creatorName && user.creatorName.toLowerCase().includes(searchTerm.toLowerCase())) || (user.email && user.email.toLowerCase().includes(searchTerm.toLowerCase()));
        const matchesRole = selectedRole === 'All' || user.role === selectedRole;
        return matchesSearchTerm && matchesRole;
    });

    const pendingOverviewCount = pendingCampaignsCount + pendingPledges.length;    
    const sortedPledges = [...pendingPledges].sort((a, b) => {
        if (pledgeSortType === 'type') {
            return a.paymentType.localeCompare(b.paymentType);
        }
        return new Date(b.createdAt) - new Date(a.createdAt);
    });

    return (
        <div className="screenContainer">
            <p className="heading">Admin Dashboard</p>
            <p className="subHeading">Manage users and crowdfunding campaigns.</p>

           
                                {/* New Stylized & Compact Admin Navigation Hub */}
            <div className="dashboardSection" style={{ padding: '15px', marginBottom: '20px', position: 'sticky', top: 0, zIndex: 50 }}>
                <div style={{ display: 'flex', flexDirection: 'column', gap: '10px' }}>
                    
                    {/* Row 1: Core */}
                    <div style={{ display: 'flex', alignItems: 'center', gap: '10px', flexWrap: 'wrap' }}>
                        <p className="admin-nav-label">Core:</p>
                        <button className={`admin-nav-button ${selectedAdminSubScreen === 'Overview' ? 'active' : ''}`} onClick={() => setSelectedAdminSubScreen('Overview')}>
                            Overview {pendingOverviewCount > 0 && <span style={{color: '#DC3545', fontWeight: 'bold'}}>({pendingOverviewCount})</span>}
                        </button>
                       <button className={`admin-nav-button ${selectedAdminSubScreen === 'ModerationCenter' ? 'active' : ''}`} onClick={() => setSelectedAdminSubScreen('ModerationCenter')}>
                            Moderation {pendingReportsCount + pendingAppealsCount > 0 && <span style={{color: '#DC3545', fontWeight: 'bold'}}>({pendingReportsCount + pendingAppealsCount})</span>}
                        </button>
                    </div>

                    {/* Row 2: Content */}
                    <div style={{ display: 'flex', alignItems: 'center', gap: '10px', flexWrap: 'wrap' }}>
                        <p className="admin-nav-label">Content:</p>
                        <button className={`admin-nav-button ${selectedAdminSubScreen === 'ContentManagement' ? 'active' : ''}`} onClick={() => setSelectedAdminSubScreen('ContentManagement')}>
                            Curation {pendingOpportunitiesCount > 0 && <span style={{color: '#DC3545', fontWeight: 'bold'}}>({pendingOpportunitiesCount})</span>}
                        </button>
                        <button className={`admin-nav-button ${selectedAdminSubScreen === 'Competitions' ? 'active' : ''}`} onClick={() => setSelectedAdminSubScreen('Competitions')}>Competitions</button>
                        <button className={`admin-nav-button ${selectedAdminSubScreen === 'ManageCategories' ? 'active' : ''}`} onClick={() => setSelectedAdminSubScreen('ManageCategories')}>Categories/Live</button>
                    </div>

                    {/* Row 3: Platform */}
                     <div style={{ display: 'flex', alignItems: 'center', gap: '10px', flexWrap: 'wrap' }}>
                        <p className="admin-nav-label">Platform:</p>
                        <button className={`admin-nav-button ${selectedAdminSubScreen === 'SiteManagement' ? 'active' : ''}`} onClick={() => setSelectedAdminSubScreen('SiteManagement')}>Settings</button>
                        <button className="admin-nav-button" onClick={() => setActiveScreen('AnalyticsDashboard')}>Analytics</button>
                    </div>
                </div>
            </div>

            {selectedAdminSubScreen === 'Overview' && (
                <>
                  
                  {liveStatus && (
                        <section className="dashboardSection" style={{border: '2px solid #DC3545'}}>
                            <p className="dashboardSectionTitle" style={{color: '#DC3545'}}>Live Billboard Control</p>
                            <div className="adminDashboardItem">
                                <div style={{flexGrow: 1}}>
                                    <p className="adminDashboardItemTitle">{liveStatus.content.title}</p>
                                    <p style={{fontSize: '12px', color: '#CCC'}}>Expires: {new Date(liveStatus.expiresAt.toDate()).toLocaleString()}</p>
                                </div>
                                <button 
                                    className="adminActionButton reject"
                                    onClick={() => {
                                        setConfirmationTitle("Confirm Takedown");
                                        setConfirmationMessage(`Are you sure you want to immediately take down the live ad "${liveStatus.content.title}"?`);
                                        setOnConfirmationAction(() => async () => {
                                            const endFunction = httpsCallable(functions, 'endPromotedStatusByAdmin');
                                            await endFunction({ bookingId: liveStatus.id });
                                            showMessage("Ad has been taken down.");
                                        });
                                        setShowConfirmationModal(true);
                                    }}
                                >
                                    Take Down Now
                                </button>
                            </div>
                        </section>
                    )}

                  {creatorProfile.role === 'admin' && banRequests.length > 0 && ( <section className="dashboardSection" style={{ border: '2px solid #FFD700' }}> <p className="dashboardSectionTitle">Pending Authority Ban Requests ({banRequests.length})</p> <div className="dashboardContentList"> {banRequests.map(req => ( <div key={req.id} className="adminDashboardItem"> <div style={{ flexGrow: 1 }}> <p className="adminDashboardItemTitle">Target: {req.targetUserName}</p> <p style={{ fontSize: '12px', color: '#CCC' }}>Requested by: {req.requesterName}</p> </div> <button className="adminActionButton approve" onClick={() => handleApproveBanRequest(req)}>Approve Ban</button> <button className="adminActionButton reject" onClick={() => handleDenyBanRequest(req)}>Deny Request</button> </div> ))} </div> </section> )}
                    <section className="dashboardSection"> <div className="flex justify-between items-center cursor-pointer py-2" onClick={() => toggleSection(setIsUserManagementExpanded, isUserManagementExpanded)}> <p className="dashboardSectionTitle" style={{ marginBottom: '0' }}>User Management</p> <button className="admin-toggle-button">{isUserManagementExpanded ? '\u25BC' : '\u25B6'}</button> </div> <div id="user-management-content" className={`overflow-hidden transition-max-height duration-500 ease-in-out ${isUserManagementExpanded ? 'max-h-screen' : 'max-h-0'}`}> <div className="pt-4 border-t border-gray-200 mt-4" style={{ borderColor: '#3A3A3A' }}> <div className="formGroup" style={{ marginBottom: '15px' }}><label htmlFor="userSearch" className="formLabel">Search Users:</label><input type="text" id="userSearch" className="formInput" value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} placeholder="Search by name or email" /></div> <div className="formGroup" style={{ marginBottom: '15px' }}><label htmlFor="roleFilter" className="formLabel">Filter by Role:</label><select id="roleFilter" className="formInput" value={selectedRole} onChange={(e) => setSelectedRole(e.target.value)}><option value="All">All Roles</option><option value="user">User</option><option value="creator">Creator</option><option value="admin">Admin</option><option value="authority">Authority</option></select></div>

                               <button className="button" onClick={() => setActiveScreen('PremiumMembersScreen')} style={{width: '100%', backgroundColor: '#FFD700', color: '#0A0A0A', marginBottom: '15px'}}>
                                   <span className="buttonText">View All Premium Members 👑</span>
                               </button>
                               <div className="dashboardContentList" style={{maxHeight: '400px', overflowY: 'auto', paddingRight: '10px'}}>
                               
                               {filteredUsers.length === 0 ? <p className="dashboardItem">No users to display matching your criteria.</p> : filteredUsers.map(user => (
    <div key={user.id} className="adminDashboardItem" style={{alignItems: 'flex-start'}}>
        <div onClick={() => { setSelectedUserId(user.id); setActiveScreen('UserProfile'); }} style={{cursor: 'pointer', display: 'flex', alignItems: 'center', flexGrow: 1, marginRight: '10px'}}>
            <img src={user.profilePictureUrl || 'https://placehold.co/50x50/555/FFF?text=P'} alt={user.creatorName} style={{width: '50px', height: '50px', borderRadius: '50%', objectFit: 'cover', marginRight: '15px'}} />
            <div>
                <p className="adminDashboardItemTitle" style={{display: 'flex', alignItems: 'center'}}>
                    {user.creatorName || user.email}
                    {user.isVerifiedAdvertiser && <span style={{marginLeft: '10px', fontSize: '12px', color: '#00FFFF', fontWeight: 'bold'}}>✔ Verified</span>}
                </p>
                <p style={{ fontSize: '12px', color: '#CCC' }}>Role: {user.role}</p>
                                                <p style={{ fontSize: '12px', color: user.banned ? '#DC3545' : '#00FF00' }}>Status: {user.banned ? 'Banned' : 'Active'}</p>
                                            </div>
                                        </div>
                                        <div style={{display: 'flex', flexDirection: 'column', gap: '10px', alignItems: 'flex-end', flexShrink: 0}}>

                                            <div className="formGroup" style={{marginBottom: 0}}>
                                                <select className="formInput" value={user.role} onChange={(e) => confirmChangeUserRole(user, e.target.value)} disabled={isUpdatingRole === user.id || user.id === currentUser.uid || (creatorProfile.role === 'authority' && user.role === 'admin')} style={{padding: '5px', fontSize: '12px', width: '120px'}}>
                                                    <option value="user">User</option>
                                                    <option value="creator">Creator</option>
                                                    <option value="authority">Authority</option>
                                                    {creatorProfile.role === 'admin' && <option value="admin">Admin</option>}
                                                </select>
                                            </div>
                                            {currentUser.uid !== user.id && <button className={`adminActionButton ${user.banned ? 'approve' : 'reject'}`} onClick={() => confirmToggleBan(user)} disabled={isSubmittingRequest === user.id}> {isSubmittingRequest === user.id ? '...' : (user.banned ? 'Unban' : 'Ban')} </button>}
                                            <button 
                                                className="adminActionButton" 
                                                onClick={() => handleToggleVerified(user)} 
                                                disabled={isUpdatingVerified === user.id}
                                                style={{ backgroundColor: '#00FFFF', color: '#0A0A0A', width: '120px' }}
                                            >
                                                {isUpdatingVerified === user.id ? '...' : (user.isVerifiedAdvertiser ? 'Revoke Verified' : 'Make Verified')}
                                            </button>
                                        </div>
                                    </div>
                               ))} 
                           </div>
                           
                       </div> 
                </div> </section>

                   <section className="dashboardSection">
                        <div className="flex justify-between items-center cursor-pointer py-2" onClick={() => toggleSection(setIsPendingCampaignsExpanded, isPendingCampaignsExpanded)}>
                            <p className="dashboardSectionTitle" style={{ marginBottom: '0' }}>Pending Campaigns ({pendingCampaigns.length})</p>
                            <button className="admin-toggle-button">{isPendingCampaignsExpanded ? '\u25BC' : '\u25B6'}</button>
                        </div>
                        <div id="pending-campaigns-content" className={`overflow-hidden transition-max-height duration-500 ease-in-out ${isPendingCampaignsExpanded ? 'max-h-screen' : 'max-h-0'}`}>
                            <div className="pt-4 border-t border-gray-200 mt-4" style={{ borderColor: '#3A3A3A' }}>
                                {pendingCampaigns.length === 0 ? <p className="dashboardItem">No campaigns currently pending review.</p> : (
                                    <div className="dashboardContentList">
                                        {pendingCampaigns.map(campaign => (
                                            <div 
                                                key={campaign.id} 
                                                className="adminDashboardItem" 
                                                onClick={() => { setSelectedAdminCampaignId(campaign.id); setActiveScreen('AdminCampaignDetails'); }} 
                                                style={{ cursor: 'pointer', alignItems: 'center' }}
                                            >
                                                <img src={campaign.imageUrl || 'https://placehold.co/80x45/3A3A3A/FFF?text=N/A'} alt="Campaign Thumbnail" style={{ width: '80px', height: '45px', objectFit: 'cover', borderRadius: '4px', marginRight: '15px' }} />
                                                <div style={{ flexGrow: 1, marginRight: '10px' }}>
                                                    <p className="adminDashboardItemTitle">{campaign.title}</p>
                                                    <p style={{ fontSize: '12px', color: '#CCC' }}>by {campaign.creatorName}</p>
                                                </div>
                                                <button className="adminActionButton approve">Review</button>
                                            </div>
                                        ))}
                                    </div>
                                )}
                            </div>
                        </div>
                    </section>
             <section className="dashboardSection"> <div className="flex justify-between items-center cursor-pointer py-2" onClick={() => toggleSection(setIsActiveCampaignsExpanded, isActiveCampaignsExpanded)}> <p className="dashboardSectionTitle" style={{ marginBottom: '0' }}>Active Campaigns ({activeCampaigns.length})</p> <button className="admin-toggle-button">{isActiveCampaignsExpanded ? '\u25BC' : '\u25B6'}</button> </div> <div id="active-campaigns-content" className={`overflow-hidden transition-max-height duration-500 ease-in-out ${isActiveCampaignsExpanded ? 'max-h-screen' : 'max-h-0'}`}> <div className="pt-4 border-t border-gray-200 mt-4" style={{ borderColor: '#3A3A3A' }}> {activeCampaigns.length === 0 ? <p className="dashboardItem">No campaigns currently active.</p> : <div className="dashboardContentList"> {activeCampaigns.map(campaign => ( 
             <div key={campaign.id} className="adminDashboardItem" onClick={() => { setSelectedAdminCampaignId(campaign.id); setActiveScreen('AdminCampaignDetails'); }} style={{ cursor: 'pointer', alignItems: 'center' }}>
                                    <img src={campaign.imageUrl || 'https://placehold.co/80x45/3A3A3A/FFF?text=N/A'} alt="Campaign Thumbnail" style={{ width: '80px', height: '45px', objectFit: 'cover', borderRadius: '4px', marginRight: '15px' }} />
                                    <div style={{ flexGrow: 1, marginRight: '10px' }}>
                                        <p className="adminDashboardItemTitle">{campaign.title}</p>
                                        <p style={{ fontSize: '12px', color: '#CCC' }}>by {campaign.creatorName}</p>
                                    </div>
                                </div> 
                                ))} 
                                </div> } 
                            </div> 
                        </div> 
                    </section>
                                      
                            {creatorProfile.role === 'admin' && (
                    <section className="dashboardSection" style={{border: '2px solid #00FFFF'}}>
                        <p className="dashboardSectionTitle" style={{color: '#00FFFF'}}>Pending Billboard Content ({pendingStatuses.length})</p>
                        {loadingStatuses ? <p>Loading...</p> : (
                            <div className="dashboardContentList">
                                {pendingStatuses.length === 0 ? <p className="dashboardItem">No billboard content is pending review.</p> : (
                                    pendingStatuses.map(status => (
                                        <div key={status.id} 
                                            className="adminDashboardItem" 
                                            style={{cursor: 'pointer', flexDirection: 'column', alignItems: 'stretch', gap: '5px'}}
                                            onClick={() => { setSelectedStatus(status); setActiveScreen('AdminStatusReview'); }}
                                        >
                                            <div style={{display: 'flex', justifyContent: 'space-between', width: '100%'}}>
                                                <p className="adminDashboardItemTitle">{status.content?.title || "Untitled Ad"}</p>
                                                <button className="adminActionButton approve" style={{flexShrink: 0}}>Review</button>
                                            </div>
                                            <div style={{fontSize: '12px', color: '#CCC'}}>
                                                <p><strong>Booking for:</strong> {new Date(status.startTime.toDate()).toLocaleDateString()}</p>
                                                <p><strong>Pledge ID:</strong> <span style={{color: '#FFD700', fontWeight: 'bold'}}>{status.pledgeId || 'N/A'}</span></p>
                                            </div>
                                        </div>
                                    ))
                                )}
                            </div>
                        )}
                    </section>
                )}

                    {creatorProfile.role === 'admin' && (
                        <section className="dashboardSection" style={{border: '2px solid #FFD700'}}>
                            <div className="flex justify-between items-center cursor-pointer py-2" onClick={() => toggleSection(setIsPaymentsExpanded, isPaymentsExpanded)}>
                                <p className="dashboardSectionTitle" style={{marginBottom: 0}}>Pending Payments ({pendingPledges.length})</p>
                                <button className="admin-toggle-button">{isPaymentsExpanded ? '\u25BC' : '\u25B6'}</button>
                            </div>
                            <div id="pending-payments-content" className={`overflow-hidden transition-max-height duration-500 ease-in-out ${isPaymentsExpanded ? 'max-h-screen' : 'max-h-0'}`}>
                                <div className="pt-4 border-t border-gray-200 mt-4" style={{borderColor: '#3A3A3A'}}>
                                    <div style={{display: 'flex', gap: '10px', justifyContent: 'flex-end', marginBottom: '15px'}}>
                                        <button className="sectionHeaderButton" style={{backgroundColor: pledgeSortType === 'date' ? '#FFD700' : '#555', color: pledgeSortType === 'date' ? '#0A0A0A' : '#FFF'}} onClick={() => setPledgeSortType('date')}>Sort by Time</button>
                                        <button className="sectionHeaderButton" style={{backgroundColor: pledgeSortType === 'type' ? '#FFD700' : '#555', color: pledgeSortType === 'type' ? '#0A0A0A' : '#FFF'}} onClick={() => setPledgeSortType('type')}>Sort by Type</button>
                                    </div>
                                    
                                        <div className="formGroup" style={{ marginBottom: '15px' }}>
                                        <input
                                            type="text"
                                            className="formInput"
                                            placeholder="Search by Pledge ID or User Name..."
                                            value={pledgeSearchTerm}
                                            onChange={(e) => setPledgeSearchTerm(e.target.value)}
                                        />
                                    </div>
                                    
                                    {loadingPledges ? (<p className="dashboardItem">Loading pending payments...</p>) : pendingPledges.length === 0 ? (<p className="dashboardItem">There are no payments pending review.</p>) : (() => {
                                        // THIS IS THE NEW FILTERING LOGIC
                                        const filteredPledges = sortedPledges.filter(pledge => {
                                            const searchTermLower = pledgeSearchTerm.toLowerCase();
                                            if (!searchTermLower) return true; // Show all if search is empty
                                            return (
                                                pledge.pledgeId?.toLowerCase().includes(searchTermLower) ||
                                                pledge.userName?.toLowerCase().includes(searchTermLower)
                                            );
                                        });

                                        return filteredPledges.length === 0 ? (
                                            <p className="dashboardItem">No pledges found matching your search.</p>
                                        ) : (
                                            <div className="dashboardContentList">
                                                {filteredPledges.map(pledge => (
                                                    <div key={pledge.id} className="adminDashboardItem" style={{flexDirection: 'column', alignItems: 'stretch', gap: '10px'}}>
                                                        <div className="flex justify-between items-center">
                                                            <p className="adminDashboardItemTitle">{pledge.paymentType === 'premium' ? 'Premium Subscription' : (pledge.paymentType === 'eventTicket' ? 'Event Ticket' : (pledge.paymentType === 'promotedStatus' ? 'Promoted Status Booking' : 'Campaign Donation'))}</p>
                                                            <p style={{fontSize: '18px', fontWeight: 'bold', color: '#FFD70D'}}>${pledge.amount.toFixed(2)}</p>
                                                        </div>
                                                        <div style={{fontSize: '12px', color: '#CCC'}}>
                                                            <p>Pledge ID: <span style={{fontWeight: 'bold', color: '#FFF'}}>{pledge.pledgeId}</span></p>
                                                            <p>User: {pledge.userName} ({pledge.userEmail})</p>
                                                            {pledge.paymentType === 'donation' && <p>Campaign: {pledge.targetCampaignTitle}</p>}
                                                            {pledge.paymentType === 'eventTicket' && <p>Event: {pledge.targetEventTitle || 'Live Premiere'}</p>}
                                                            {pledge.paymentType === 'promotedStatus' && <p>Booking: {pledge.targetEventTitle}</p>}
                                                            <p>Date: {new Date(pledge.createdAt).toLocaleString()}</p>
                                                        </div>
                                                        <div className="flex justify-end items-center gap-4 mt-2">
                                                            <button className="adminActionButton reject" onClick={() => confirmDenyPledge(pledge)}>Deny</button>
                                                            <button className="adminActionButton approve" onClick={() => handleApprovePledge(pledge.id)}>Approve</button>
                                                        </div>
                                                    </div>
                                                ))}
                                            </div>
                                        );
                                    })()}
                                </div>
                            </div>
                        </section>
                    )}
                    
                    {/* ====================================================================== */}
                    {/* ============== START: ADD THIS NEW UI SECTION ======================== */}
                    {/* ====================================================================== */}
                    <section className="dashboardSection" style={{border: '2px solid #00FFFF'}}>
                        <p className="dashboardSectionTitle">Pending Opportunities ({pendingOpportunities.length})</p>
                        {loadingOpportunities ? <p>Loading...</p> : (
                            <div className="dashboardContentList">
                                {pendingOpportunities.length === 0 ? <p className="dashboardItem">No opportunities pending review.</p> : (
                                    pendingOpportunities.map(opp => (
                                        <div key={opp.id} 
                                            className="adminDashboardItem" 
                                            style={{cursor: 'pointer'}}
                                            onClick={() => { setSelectedOpportunity(opp); setActiveScreen('AdminOpportunityDetails'); }} // <<< --- THIS IS THE FIX
                                        >
                                            <div style={{flexGrow: 1}}>
                                                <p className="adminDashboardItemTitle">{opp.title}</p>
                                                <p style={{fontSize: '12px', color: '#CCC'}}>by {opp.providerName}</p>
                                            </div>
                                            <button className="adminActionButton approve">Review</button>
                                        </div>
                                    ))
                                )}
                            </div>
                        )}
                    </section>
                    {/* ====================================================================== */}
                    {/* =============== END: ADD THIS NEW UI SECTION ========================= */}
                    {/* ====================================================================== */}
                    

                    {/* ====================================================================== */}
                    {/* ============== START: ADD THIS NEW UI SECTION ======================== */}
                    {/* ====================================================================== */}
                    <section className="dashboardSection">
                        <div className="flex justify-between items-center cursor-pointer py-2" onClick={() => setIsActiveOpportunitiesExpanded(!isActiveOpportunitiesExpanded)}>
                            <p className="dashboardSectionTitle" style={{ marginBottom: 0 }}>Active Opportunities ({activeOpportunities.length})</p>
                            <button className="admin-toggle-button">{isActiveOpportunitiesExpanded ? '▼' : '▶'}</button>
                        </div>
                        <div className={`overflow-hidden transition-max-height duration-500 ease-in-out ${isActiveOpportunitiesExpanded ? 'max-h-screen' : 'max-h-0'}`}>
                            <div className="pt-4 border-t border-gray-200 mt-4" style={{ borderColor: '#3A3A3A' }}>
                                {loadingActiveOpportunities ? <p>Loading...</p> : (
                                    <div className="dashboardContentList">
                                        {activeOpportunities.length === 0 ? <p className="dashboardItem">There are no active opportunities.</p> : (
                                            activeOpportunities.map(opp => (
                                                <div key={opp.id} className="adminDashboardItem" style={{cursor: 'pointer'}} onClick={() => { setSelectedOpportunity(opp); setActiveScreen('AdminOpportunityDetails'); }}>
                                                    <div style={{flexGrow: 1}}>
                                                        <p className="adminDashboardItemTitle">{opp.title}</p>
                                                        <p style={{fontSize: '12px', color: '#CCC'}}>by {opp.providerName}</p>
                                                    </div>
                                                    <button className="adminActionButton approve">Review</button>
                                                </div>
                                            ))
                                        )}
                                    </div>
                                )}
                            </div>
                        </div>
                    </section>
                    {/* ====================================================================== */}
                    {/* =============== END: ADD THIS NEW UI SECTION ========================= */}
                    {/* ====================================================================== */}  


                    <button className="button" onClick={() => setActiveScreen('Home')} style={{ backgroundColor: '#3A3A3A', color: '#FFF', marginTop: '30px' }}><span className="buttonText light">Back to Home</span></button>
                </>
            )}

            {selectedAdminSubScreen === 'ModerationCenter' && (
                <AdminModerationCenter
                    showMessage={showMessage}
                    setActiveScreen={setActiveScreen}
                    setSelectedReportGroup={setSelectedReportGroup}
                    setShowConfirmationModal={setShowConfirmationModal}
                    setConfirmationTitle={setConfirmationTitle}
                    setConfirmationMessage={setConfirmationMessage}
                    setOnConfirmationAction={setOnConfirmationAction}
                />
            )}

            {selectedAdminSubScreen === 'ContentManagement' && (
                <AdminContentManagerScreen
                    showMessage={showMessage}
                    featuredContentSlots={featuredContentSlots}
                    setActiveScreen={setActiveScreen}
                    currentUser={currentUser}
                    creatorProfile={creatorProfile}
                    setShowConfirmationModal={setShowConfirmationModal}
                    setConfirmationTitle={setConfirmationTitle}
                    setConfirmationMessage={setConfirmationMessage}
                    setOnConfirmationAction={setOnConfirmationAction}
                />
            )}

            {selectedAdminSubScreen === 'ManageCategories' && (
                <AdminCategoryManagerScreen
                    showMessage={showMessage}
                    setActiveScreen={setActiveScreen}
                    setShowConfirmationModal={setShowConfirmationModal}
                    setConfirmationTitle={setConfirmationTitle}
                    setConfirmationMessage={setConfirmationMessage}
                    setOnConfirmationAction={setOnConfirmationAction}
                />
            )}
            
            {selectedAdminSubScreen === 'Competitions' && (
                <AdminCompetitionManager
                    showMessage={showMessage}
                    setActiveScreen={setActiveScreen}
                    currentUser={currentUser}
                    setSelectedCompAdmin={setSelectedCompAdmin}
                    creatorProfile={creatorProfile}
                    // ADD THESE FOUR PROPS TO PASS THEM DOWN
                    setShowConfirmationModal={setShowConfirmationModal}
                    setConfirmationTitle={setConfirmationTitle}
                    setConfirmationMessage={setConfirmationMessage}
                    setOnConfirmationAction={setOnConfirmationAction}
                />
            )}

            {selectedAdminSubScreen === 'SiteManagement' && (
                <AdminSiteManagerScreen
                    showMessage={showMessage}
                    setActiveScreen={setActiveScreen}
                    setShowConfirmationModal={setShowConfirmationModal}
                    setConfirmationTitle={setConfirmationTitle}
                    setConfirmationMessage={setConfirmationMessage}
                    setOnConfirmationAction={setOnConfirmationAction}
                    creatorProfile={creatorProfile}
                />
            )}

            

            {showExpiryModal && userToVerify && (
                <SetVerificationExpiryModal
                    userName={userToVerify.creatorName}
                    onCancel={() => setShowExpiryModal(false)}
                    onConfirm={handleSetExpiry}
                />
            )}
        </div>
    );
};
// =================== END REPLACEMENT ===================
// =========== END REPLACEMENT ==========
       
        const SubscriptionPledgeScreen = ({ showMessage, setActiveScreen, currentUser, creatorProfile, pledgeContext, setPledgeIdForConfirmation, selectedCurrency, currencyRates }) => {
            const [userName, setUserName] = useState((creatorProfile && creatorProfile.creatorName) ? creatorProfile.creatorName : (currentUser ? currentUser.email.split('@')[0] : ''));
            const [agreedToTerms, setAgreedToTerms] = useState(false);
            const [isSubmitting, setIsSubmitting] = useState(false);
            const isTicket = pledgeContext.type === 'eventTicket';

            const handleSubmitPledge = async (e) => {
                e.preventDefault();
                if (!userName.trim()) { 
                    showMessage("Please enter your name."); 
                    return; 
                }
                if (!agreedToTerms) { 
                    showMessage("You must agree to the terms."); 
                    return; 
                }
                setIsSubmitting(true);
                
                const pledgeId = `NVA-${Date.now().toString().slice(-6).toUpperCase()}`;
                try {
                    const pledgeRef = doc(collection(db, "paymentPledges"), pledgeId);
                    await setDoc(pledgeRef, {
                        pledgeId, userId: currentUser.uid, userName, userEmail: currentUser.email,
                        paymentType: pledgeContext.type, amount: pledgeContext.amount, status: 'pending',
                        targetEventId: pledgeContext.targetEventId || null, 
                        targetEventTitle: pledgeContext.targetEventTitle || null,
                        createdAt: new Date().toISOString(),
                    });
                    setPledgeIdForConfirmation(pledgeId);
                    setActiveScreen('PendingConfirmation');
                } catch (error) {
                    showMessage(`An error occurred: ${error.message}`);
                    setIsSubmitting(false);
                }
            };
            
            return (
                <div className="screenContainer">
                    <p className="heading">{isTicket ? "Purchase Event Ticket" : "Get NVA Premium"}</p>
                    <p className="subHeading">{isTicket ? `Ticket for: "${pledgeContext.targetEventTitle}"` : "Unlock exclusive content and an ad-free experience."}</p>
                    <form onSubmit={handleSubmitPledge}>
                        <div className="formGroup">
                            <label htmlFor="pledgeName" className="formLabel">Your Name:</label>
                            <input type="text" id="pledgeName" className="formInput" value={userName} onChange={(e) => setUserName(e.target.value)} required />
                        </div>
                        <div className="premiumFeatureCard">
                            <p className="premiumFeatureTitle" style={{textAlign: 'center'}}>{isTicket ? 'Event Ticket' : 'Premium Subscription'}</p>
                            <p className="premiumFeatureDescription" style={{fontSize: '24px', fontWeight: 'bold', textAlign: 'center', color: '#FFF'}}>{formatCurrency(pledgeContext.amount, selectedCurrency, currencyRates)}</p>
                            <p className="premiumFeatureDescription" style={{textAlign: 'center'}}>{isTicket ? 'one-time purchase' : 'per month'}</p>
                        </div>
                        <div className="formGroup"><p className="termsText" style={{textAlign: 'left', color: '#CCC'}}>This is a manual payment process. You will be given instructions to complete your payment via MMG after submitting.</p></div>
                        <div className="formGroup"><div className="checkboxItem"><input type="checkbox" id="agreeToTerms" checked={agreedToTerms} onChange={(e) => setAgreedToTerms(e.target.checked)} required /><label htmlFor="agreeToTerms">I understand and agree to the payment terms.</label></div></div>
                        <button type="submit" className="button" disabled={isSubmitting}><span className="buttonText">{isSubmitting ? "Generating..." : "Submit Pledge & Get Payment Info"}</span></button>
                    </form>
                    <button className="button" onClick={() => setActiveScreen('Premium')} style={{ backgroundColor: '#3A3A3A', marginTop: '20px' }}>
                        <span className="buttonText">Back</span>
                    </button>
                </div>
            );
        };
// =========== END REPLACEMENT ===========

                // =========== ADD THE FOLLOWING CODE BLOCK ===========
         const PendingConfirmationScreen = ({ showMessage, setActiveScreen, pledgeId, currentUser, selectedCurrency, currencyRates }) => {
            const [pledgeDetails, setPledgeDetails] = useState(null);
            const [isLoading, setIsLoading] = useState(true);
            const [mmgNumber, setMmgNumber] = useState('');

            useEffect(() => {
                if (!pledgeId) {
                    setActiveScreen('Home');
                    return () => {};
                }

                const settingsRef = doc(db, "settings", "socialLinks");
                getDoc(settingsRef).then(settingsSnap => {
                    if (settingsSnap.exists()) {
                        setMmgNumber(settingsSnap.data().mmgNumber || 'Admin Not Set');
                    }
                });

                const pledgeRef = doc(db, "paymentPledges", pledgeId);
                const unsubscribe = onSnapshot(pledgeRef, (docSnap) => {
                    if (docSnap.exists()) {
                        const data = docSnap.data();
                        setPledgeDetails(data);
                        setIsLoading(false);
                        if (data.status === 'approved') {
                            showMessage("Payment confirmed successfully!");
                            unsubscribe();
                            setTimeout(() => setActiveScreen('Home'), 3000);
                        } else if (data.status === 'denied') {
                            showMessage("Your payment pledge was denied.");
                            unsubscribe();
                            setTimeout(() => setActiveScreen('Home'), 3000);
                        }
                    } else {
                        showMessage("This payment pledge is no longer valid.");
                        unsubscribe();
                        setActiveScreen('Home');
                    }
                });

                return () => unsubscribe();
            }, [pledgeId]);

            if (isLoading) {
                return <div className="screenContainer"><p className="heading">Generating Your Payment Details...</p></div>;
            }
            
            if (pledgeDetails.status === 'approved') {
                return (
                    <div className="screenContainer" style={{textAlign: 'center'}}>
                        <p className="heading" style={{color: '#00FF00'}}>Payment Confirmed!</p>
                        <p className="subHeading">Thank you for your support. Redirecting you home...</p>
                    </div>
                );
            }

            return (
                <div className="screenContainer">
                    <p className="heading">Complete Your Payment</p>
                    <p className="subHeading" style={{color: '#FFD700'}}>Action Required</p>
                    
                    <div className="premiumFeatureCard" style={{textAlign: 'center'}}>
                        <p className="premiumFeatureDescription" style={{marginBottom: '5px'}}>Please send the equivalent of:</p>
                        <p className="premiumFeatureTitle" style={{fontSize: '32px', color: '#FFF'}}>{formatCurrency(pledgeDetails.amount, selectedCurrency, currencyRates)}</p>
                        <p className="premiumFeatureDescription" style={{marginTop: '10px'}}>To our MMG account along with screenshot of your confirmed Payment Receipt:</p>
                        <p className="premiumFeatureTitle" style={{fontSize: '24px'}}>{mmgNumber || 'Contact Admin for Payment Info'}</p>
                    </div>

                    <div className="dashboardSection" style={{marginTop: '20px'}}>
                        <p className="dashboardSectionTitle">Crucial Final Step:</p>
                        <p className="paragraph">
                            In the MMG Enter Description Field you **MUST** include the following Pledge ID.
                            Failure to do so will result in your payment not being processed.
                        </p>
                        <p className="heading" style={{fontSize: '28px', backgroundColor: '#0A0A0A', padding: '10px', borderRadius: '8px', border: '1px solid #FFD700', userSelect: 'all'}}>
                            {pledgeId}
                        </p>
                    </div>

                    <p className="paragraph" style={{textAlign: 'center', marginTop: '20px'}}>This screen is listening for updates. Once we manually verify your MMG transaction, this screen will automatically confirm it.</p>
                     <p className="smallText">You can safely navigate away and come back later if needed.</p>

                    <button className="button" onClick={() => setActiveScreen('Home')} style={{backgroundColor: '#3A3A0A', marginTop: '10px'}}>
                        <span className="buttonText">I have paid. Back to Home</span>
                    </button>
                </div>
            );
        };
// END of REPLACEMENT Block



                    // --- START: NEW COMPONENT ---
        const AddExternalLinkModal = ({ showMessage, onSave, onCancel }) => {
            const [title, setTitle] = useState('');
            const [destinationUrl, setDestinationUrl] = useState('');
            const [imageFile, setImageFile] = useState(null);
            const [imagePreview, setImagePreview] = useState('');
            const [isUploading, setIsUploading] = useState(false);
            const fileInputRef = useRef(null);

            useEffect(() => {
                if (imageFile) return;
                if (!destinationUrl) {
                    setImagePreview('');
                    return;
                }
                const videoInfo = extractVideoInfo(destinationUrl);
                if (videoInfo && videoInfo.thumbnailUrl !== GENERIC_THUMBNAIL_PLACEHOLDER) {
                    setImagePreview(videoInfo.thumbnailUrl);
                } else {
                    setImagePreview('');
                }
            }, [destinationUrl, imageFile]);

            const handleFileChange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    setImageFile(file);
                    setImagePreview(URL.createObjectURL(file));
                }
            };

            const handleSave = async () => {
                if (!title || !destinationUrl) {
                    showMessage("A Title and Destination URL are required.");
                    return;
                }

                if (imageFile) {
                    setIsUploading(true);
                    showMessage("Uploading custom image...");
                    try {
                        const filePath = `curated_thumbnails/${Date.now()}_${imageFile.name}`;
                        const storageRef = ref(storage, filePath);
                        const snapshot = await uploadBytes(storageRef, imageFile);
                        const finalImageUrl = await getDownloadURL(snapshot.ref);
                        showMessage("Image uploaded successfully!");
                        
                        onSave({
                            type: 'external',
                            title,
                            externalLink: destinationUrl,
                            imageUrl: finalImageUrl,
                            orderIndex: Date.now()
                        });
                        setIsUploading(false);
                        onCancel();

                    } catch (error) {
                        showMessage(`Image upload failed: ${error.message}`);
                        setIsUploading(false);
                    }
                } else {
                    onSave({
                        type: 'external',
                        title,
                        externalLink: destinationUrl,
                        imageUrl: imagePreview || GENERIC_THUMBNAIL_PLACEHOLDER,
                        orderIndex: Date.now()
                    });
                    onCancel();
                }
            };

            return (
                <div className="confirmationModalOverlay" style={{ zIndex: 3000 }}>
                    <div className="confirmationModalContent" style={{ textAlign: 'left', maxWidth: '500px' }}>
                        <p className="confirmationModalTitle">Add External Link</p>
                        <div className="formGroup">
                            <label className="formLabel">Title:</label>
                            <input type="text" className="formInput" value={title} onChange={(e) => setTitle(e.target.value)} placeholder="e.g., Summer Festival Tickets" required/>
                        </div>
                        <div className="formGroup">
                            <label className="formLabel">Destination URL:</label>
                            <input type="url" className="formInput" value={destinationUrl} onChange={(e) => { setDestinationUrl(e.target.value); setImageFile(null); }} placeholder="https://www.externalsite.com/page" required/>
                            <p className="smallText" style={{textAlign: 'left', color: '#AAA', marginTop: '5px'}}>The app will try to fetch a preview from this link.</p>
                        </div>
                        <hr style={{borderColor: '#333', margin: '15px 0'}}/>
                        <div className="formGroup">
                            <label className="formLabel">Upload Custom Image (Overrides Preview):</label>
                            <input type="file" ref={fileInputRef} onChange={handleFileChange} accept="image/*" style={{ display: 'none' }} />
                            <button type="button" className="button" onClick={() => fileInputRef.current.click()} style={{ width: '100%', backgroundColor: '#3A3A3A' }}>
                                <span className="buttonText">Choose Image File</span>
                            </button>
                            {imagePreview && (
                                <div style={{marginTop: '15px'}}>
                                    <p className="formLabel">Final Preview:</p>
                                    <img src={imagePreview} alt="Preview" style={{ maxWidth: '200px', borderRadius: '8px', marginTop: '5px' }} onError={(e) => { e.target.onerror = null; e.target.src='https://placehold.co/200x120/555/FFF?text=No+Preview'; }} />
                                </div>
                            )}
                        </div>
                        <div className="confirmationModalButtons">
                            <button className="confirmationButton cancel" onClick={onCancel}>Cancel</button>
                            <button className="confirmationButton confirm" onClick={handleSave} disabled={isUploading}>
                                {isUploading ? 'Uploading...' : 'Save Link'}
                            </button>
                        </div>
                    </div>
                </div>
            );
        };
        
        const ContentSelectorModal = ({ onSelect, onCancel, showMessage }) => {
            const [contentItems, setContentItems] = useState([]);
            const [loading, setLoading] = useState(true);
            const [searchTerm, setSearchTerm] = useState('');

            useEffect(() => {
                const contentCollectionRef = collection(db, `artifacts/${appId}/public/data/content_items`);
                const q = query(contentCollectionRef, orderBy('createdAt', 'desc'));
                const unsubscribe = onSnapshot(q, (snapshot) => {
                    setContentItems(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
                    setLoading(false);
                }, (error) => {
                    showMessage("Failed to load content library.");
                    setLoading(false);
                });
                return () => unsubscribe();
            }, []);

            const filteredItems = contentItems.filter(item =>
                item.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
                item.creatorName.toLowerCase().includes(searchTerm.toLowerCase())
            );

            return (
                <div className="confirmationModalOverlay" style={{ zIndex: 4000 }}>
                    <div className="confirmationModalContent" style={{ maxWidth: '600px', textAlign: 'left' }}>
                        <p className="confirmationModalTitle">Select Content from Library</p>
                        <div className="formGroup">
                            <input type="text" className="formInput" placeholder="Search by title or creator..." value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} />
                        </div>
                        <div className="dashboardContentList" style={{ maxHeight: '40vh', overflowY: 'auto', marginBottom: '20px' }}>
                            {loading ? <p>Loading...</p> : filteredItems.map(item => (
                                <div key={item.id} className="adminDashboardItem" style={{ cursor: 'pointer' }} onClick={() => onSelect(item)}>
                                    <img src={item.customThumbnailUrl} style={{ width: '80px', height: '45px', objectFit: 'cover', borderRadius: '4px' }}/>
                                    <div style={{ flexGrow: 1, marginLeft: '10px' }}>
                                        <p className="adminDashboardItemTitle">{item.title}</p>
                                        <p style={{ fontSize: '12px', color: '#AAA' }}>by {item.creatorName}</p>
                                    </div>
                                    <button className="adminActionButton approve">Select</button>
                                </div>
                            ))}
                        </div>
                        <div className="confirmationModalButtons">
                            <button className="confirmationButton cancel" onClick={onCancel}>Cancel</button>
                        </div>
                    </div>
                </div>
            );
        };

        const AdminCurationModal = ({ curationTarget, showMessage, onCancel, contentItems }) => {
            const [curatedItems, setCuratedItems] = useState([]);
            const [loading, setLoading] = useState(true);
            const [isSaving, setIsSaving] = useState(false);
            const [showContentSelector, setShowContentSelector] = useState(false);
            const [showExternalLinkModal, setShowExternalLinkModal] = useState(false);

            const targetField = `${curationTarget.toLowerCase().replace(' ', '')}Items`;

            useEffect(() => {
                const fetchInitialData = async () => {
                    setLoading(true);
                    const layoutDocRef = doc(db, "settings", "homeScreenLayout");
                    try {
                        const docSnap = await getDoc(layoutDocRef);
                        if (docSnap.exists()) {
                            const layoutData = docSnap.data();
                            const itemsFromDB = layoutData[targetField] || [];
                            
                            const enrichedItems = itemsFromDB.map(item => {
                                if (item.type === 'internal') {
                                    const fullContent = contentItems.find(ci => ci.id === item.contentId);
                                    return fullContent ? { ...item, ...fullContent } : null;
                                }
                                // External items no longer exist in this format, but we keep this for legacy safety
                                return item;
                            }).filter(Boolean);
                            setCuratedItems(enrichedItems);
                        } else {
                            setCuratedItems([]);
                        }
                    } catch (error) {
                        showMessage("Error fetching curation data: " + error.message);
                    } finally {
                        setLoading(false);
                    }
                };
                fetchInitialData();
            }, [curationTarget, contentItems]);

            const handleMove = (index, direction) => {
                const newItems = [...curatedItems];
                const item = newItems[index];
                const newIndex = index + direction;
                if (newIndex < 0 || newIndex >= newItems.length) return;
                newItems.splice(index, 1);
                newItems.splice(newIndex, 0, item);
                setCuratedItems(newItems);
            };

            const handleRemove = (index) => {
                const newItems = [...curatedItems];
                newItems.splice(index, 1);
                setCuratedItems(newItems);
            };

            const handleSelectInternalContent = (selectedContent) => {
                const isAlreadyInList = curatedItems.some(item => item.contentId === selectedContent.id);
                if (isAlreadyInList) {
                    showMessage("This content is already in the list.");
                    return;
                }
                const newItem = {
                    type: 'internal',
                    contentId: selectedContent.id,
                    orderIndex: curatedItems.length,
                    ...selectedContent
                };
                setCuratedItems(prev => [...prev, newItem]);
                setShowContentSelector(false);
            };
            
            // --- THIS IS THE CORRECTED HANDLER ---
            const handleSaveExternalLink = async (newLinkData) => {
                setShowExternalLinkModal(false); // Close modal immediately for better UX
                setIsSaving(true); // Use the existing saving state to provide feedback
                showMessage("Promoting external link to library...");

                try {
                    const promoteFunction = httpsCallable(functions, 'promoteExternalLink');
                    const result = await promoteFunction({
                        title: newLinkData.title,
                        externalLink: newLinkData.externalLink,
                        imageUrl: newLinkData.imageUrl,
                        appId: appId
                    });

                    if (result.data && result.data.newItem) {
                        const newItem = {
                            ...result.data.newItem,
                            type: 'internal', // It's now treated as an internal, governable item
                            contentId: result.data.newItem.id
                        };
                        setCuratedItems(prev => [...prev, newItem]);
                        showMessage("Link successfully promoted and added to list!");
                    } else {
                        throw new Error("Invalid response from server.");
                    }
                } catch (error) {
                    showMessage(`Error promoting link: ${error.message}`);
                } finally {
                    setIsSaving(false);
                }
            };

            const handleSaveChanges = async () => {
                setIsSaving(true);
                showMessage("Saving and cleaning changes...");
                
                // THIS IS THE FIX: We now validate each item before attempting to save it.
                const itemsToSave = curatedItems
                    .map((item, index) => {
                        const id = item.contentId || item.id;
                        // If an item has no ID, it's a ghost or legacy data.
                        // We will filter it out to prevent the crash.
                        if (!id) {
                            console.warn("Filtering out invalid/ghost item during save:", item);
                            return null;
                        }
                        return {
                            type: 'internal',
                            contentId: id,
                            orderIndex: index
                        };
                    })
                    .filter(item => item !== null); // This step removes any null (ghost) items.

                try {
                    const layoutDocRef = doc(db, "settings", "homeScreenLayout");
                    await setDoc(layoutDocRef, { [targetField]: itemsToSave }, { merge: true });
                    showMessage("Curation saved successfully! Invalid entries were automatically removed.");
                    onCancel();
                } catch (error) {
                    // This error should no longer happen, but we keep the catch for other potential issues.
                    showMessage(`Error saving: ${error.message}`);
                } finally {
                    setIsSaving(false);
                }
            };

            return (
                <div className="confirmationModalOverlay" style={{ zIndex: 2500 }}>
                    <div className="confirmationModalContent" style={{ maxWidth: '700px', textAlign: 'left' }}>
                        <p className="confirmationModalTitle">Manage {curationTarget} Section</p>
                        
                        <div className="dashboardContentList" style={{ maxHeight: '40vh', overflowY: 'auto', marginBottom: '20px' }}>
                            {loading || isSaving ? <p>Loading...</p> : ( // Show loading while saving
                                curatedItems.length === 0 ? <p className="dashboardItem">This section is empty.</p> :
                                curatedItems.map((item, index) => (
                                    <div key={item.id || item.title + index} className="adminDashboardItem">
                                        <img src={item.customThumbnailUrl || item.imageUrl} style={{width: '80px', height: '45px', objectFit: 'cover', borderRadius: '4px'}}/>
                                        <div style={{flexGrow: 1, marginLeft: '10px'}}>
                                            <p className="adminDashboardItemTitle">{item.title}</p>
                                            {/* All items will now have a creatorName */}
                                            <p style={{fontSize: '12px', color: '#AAA'}}>by {item.creatorName || '...loading'}</p>
                                        </div>
                                        <div style={{display: 'flex', gap: '5px'}}>
                                            <button onClick={() => handleMove(index, -1)} disabled={index === 0} className="adminActionButton" style={{width: '30px'}}>▲</button>
                                            <button onClick={() => handleMove(index, 1)} disabled={index === curatedItems.length - 1} className="adminActionButton" style={{width: '30px'}}>▼</button>
                                            <button onClick={() => handleRemove(index)} className="adminActionButton reject">Remove</button>
                                        </div>
                                    </div>
                                ))
                            )}
                        </div>

                        <div className="flex justify-around gap-4 my-4">
                            <button className="button" onClick={() => setShowContentSelector(true)} disabled={isSaving}>
                                <span className="buttonText">Add from Library</span>
                            </button>
                             <button className="button" onClick={() => setShowExternalLinkModal(true)} disabled={isSaving}>
                                <span className="buttonText">Add External URL</span>
                            </button>
                        </div>

                        <div className="confirmationModalButtons">
                            <button className="confirmationButton cancel" onClick={onCancel}>Cancel</button>
                            <button className="confirmationButton confirm" onClick={handleSaveChanges} disabled={isSaving}>
                                {isSaving ? 'Saving...' : 'Save Changes'}
                            </button>
                        </div>

                        {showContentSelector && <ContentSelectorModal showMessage={showMessage} onSelect={handleSelectInternalContent} onCancel={() => setShowContentSelector(false)} />}
                        {showExternalLinkModal && <AddExternalLinkModal showMessage={showMessage} onSave={handleSaveExternalLink} onCancel={() => setShowExternalLinkModal(false)} />}
                    </div>
                </div>
            );
        };

        const AdminFeaturedContentManager = ({ featuredContentSlots, showMessage }) => {
            const [showModal, setShowModal] = useState(false);
            const [editingSlot, setEditingSlot] = useState(null);
            const [isSaving, setIsSaving] = useState(null);

            const handleUnlock = async (slotKey) => {
                setIsSaving(slotKey);
                showMessage("Unlocking and reverting slot...");
                try {
                    const slotNumber = parseInt(slotKey.split('_')[1], 10);
                    // In this new system, unlocking simply means removing the manual override.
                    // The backend will handle recalculating the top creator.
                    // For the frontend, we just need to set the content to null and unlock.
                    const slotsDocRef = doc(db, "settings", "featuredContentSlots");
                    await updateDoc(slotsDocRef, {
                        [`${slotKey}.isLocked`]: false,
                        [`${slotKey}.content`]: null // Let the backend recalculate
                    });
                    showMessage(`Slot #${slotNumber} unlocked and will now update automatically.`);
                } catch (error) {
                    showMessage("Error unlocking slot: " + error.message);
                } finally {
                    setIsSaving(null);
                }
            };

            const handleSelectContent = async (selectedContent) => {
                if (!editingSlot) return;
                setIsSaving(editingSlot);
                setShowModal(false);
                try {
                    const slotsDocRef = doc(db, "settings", "featuredContentSlots");
                    await updateDoc(slotsDocRef, {
                        [`${editingSlot}.content`]: selectedContent,
                        [`${editingSlot}.isLocked`]: true
                    });
                    showMessage(`Slot #${editingSlot.split('_')[1]} has been manually updated.`);
                } catch (error) {
                    showMessage("Error updating slot: " + error.message);
                } finally {
                    setIsSaving(null);
                    setEditingSlot(null);
                }
            };
            
            // Generate keys for 6 slots
            const slotKeys = Array.from({ length: 6 }, (_, i) => `slot_${i + 1}`);
            const slots = featuredContentSlots ? slotKeys.map(key => ({ key, data: featuredContentSlots[key] })) : [];

            return (
                <div className="dashboardSection" style={{border: '2px solid #FFD700'}}>
                    <p className="dashboardSectionTitle">Top Creators Content Slots</p>
                    <p className="dashboardItem" style={{color: '#AAA', marginBottom: '15px'}}>Manually override the content featured on the "Top Creators" screen.</p>
                    
                    <div className="dashboardContentList">
                        {slots.map((slot, index) => (
                            <div key={slot.key} className="adminDashboardItem" style={{flexDirection: 'column', alignItems: 'flex-start', gap: '10px'}}>
                                <p className="adminDashboardItemTitle">Slot #{index + 1} <span style={{fontSize: '12px', color: slot.data?.isLocked ? '#00FF00' : '#FFD700'}}>({slot.data?.isLocked ? 'Locked' : 'Automatic'})</span></p>
                                <div style={{display: 'flex', width: '100%', alignItems: 'center', gap: '10px'}}>
                                    <div style={{flexGrow: 1, display: 'flex', alignItems: 'center', gap: '10px'}}>
                                        {slot.data?.content ? (
                                            <>
                                                <img src={slot.data.content.customThumbnailUrl} style={{width: '80px', height: '45px', objectFit: 'cover', borderRadius: '4px'}}/>
                                                <div>
                                                    <p style={{fontWeight: 'bold'}}>{slot.data.content.title}</p>
                                                    <p style={{fontSize: '12px', color: '#CCC'}}>by {slot.data.content.creatorName}</p>
                                                </div>
                                            </>
                                        ) : <p className="dashboardItem">This slot is currently empty or updating automatically.</p>}
                                    </div>
                                    <div style={{display: 'flex', gap: '10px'}}>
                                        {isSaving === slot.key ? <p>Saving...</p> : <>
                                            {slot.data?.isLocked && <button className="adminActionButton" onClick={() => handleUnlock(slot.key)}>Unlock</button>}
                                            <button className="adminActionButton approve" onClick={() => { setEditingSlot(slot.key); setShowModal(true); }}>Change</button>
                                        </>}
                                    </div>
                                </div>
                            </div>
                        ))}
                    </div>

                    {showModal && <ContentSelectorModal onSelect={handleSelectContent} onCancel={() => setShowModal(false)} showMessage={showMessage} />}
                </div>
            );
        };

const AdminContentManagerScreen = ({
    showMessage,
    setActiveScreen,
    currentUser,
    featuredContentSlots,
    creatorProfile,
    setShowConfirmationModal,
    setConfirmationTitle,
    setConfirmationMessage,
    setOnConfirmationAction
}) => {
    const [contentItems, setContentItems] = useState([]);
    const [loading, setLoading] = useState(true);
    const [isContentListExpanded, setIsContentListExpanded] = useState(true);

    const [title, setTitle] = useState('');
    const [mainUrl, setMainUrl] = useState('');
    const [customThumbnailFile, setCustomThumbnailFile] = useState(null);
    const [customThumbnailUrlPreview, setCustomThumbnailUrlPreview] = useState('');
    const [autoThumbnailPreview, setAutoThumbnailPreview] = useState('');
    const [creatorName, setCreatorName] = useState('');
    const [contentType, setContentType] = useState('Skits');
    const [orderIndex, setOrderIndex] = useState(0);
    const [isActive, setIsActive] = useState(true);
    const [description, setDescription] = useState('');

    const thumbnailFileInputRef = useRef(null);
    
        // =================== START: ADD THIS NEW CODE BLOCK ===================  

    const [availableCategories, setAvailableCategories] = useState([]);
    
            // =================== START: ADD THIS NEW CODE BLOCK ===================
    // --- NEW STATE for Image Adjustment Modal ---
    const [showImageAdjustModal, setShowImageAdjustModal] = useState(false);
    const [imageFileToAdjust, setImageFileToAdjust] = useState(null);

    // This handler is called when the user selects a file. It OPENS the modal.
    const handleThumbnailFileSelect = (e) => {
        const file = e.target.files[0];
        if (file) {
            setImageFileToAdjust(file);
            setShowImageAdjustModal(true);
        }
    };

    // This handler is called when the user SAVES from the modal. It SETS the final file.
    const handleThumbnailSave = (adjustedBlob) => {
        const newFile = new File([adjustedBlob], "custom_thumbnail.png", { type: "image/png" });
        setCustomThumbnailFile(newFile);
        setCustomThumbnailPreview(URL.createObjectURL(newFile)); // Update preview
        setShowImageAdjustModal(false); // Close modal
    };

    // This handler is for CANCELING the modal.
    const handleThumbnailCancel = () => {
        setImageFileToAdjust(null);
        setShowImageAdjustModal(false);
        // Clear the file input so the user can select the same file again if they want
        if (thumbnailFileInputRef.current) {
            thumbnailFileInputRef.current.value = null;
        }
    };
// =================== END: ADD THIS NEW CODE BLOCK =====================

    const [showCurationModal, setShowCurationModal] = useState(false);
    const [curationTarget, setCurationTarget] = useState('');

    const openCurationModal = (target) => {
        setCurationTarget(target);
        setShowCurationModal(true);
    };

    useEffect(() => {
        const categoriesRef = collection(db, "content_categories");
        const systemCategories = ['Featured', 'Trending']; 

        const q = query(
            categoriesRef, 
            where("isActive", "==", true), 
            orderBy("orderIndex", "asc")
        );
        
        const unsubscribe = onSnapshot(q, (snapshot) => {
            const fetchedCategories = snapshot.docs
                .map(doc => doc.data().name)
                .filter(name => !systemCategories.includes(name));
            
            const finalCategories = [...fetchedCategories, 'Live Feed'];
            
            setAvailableCategories(finalCategories);
        });
        
        return () => unsubscribe();
    }, []);

    useEffect(() => {
        if (availableCategories.length > 0 && !availableCategories.includes(contentType)) {
            setContentType(availableCategories[0]);
        }
    }, [availableCategories]);

    useEffect(() => {
        if (creatorProfile) {
            if (creatorProfile.role === 'authority') {
                setCreatorName(creatorProfile.creatorName || currentUser.email);
            } else {
                setCreatorName('');
            }
        }
    }, [creatorProfile]);

    useEffect(() => {
        if (!mainUrl) {
            setAutoThumbnailPreview('');
            return;
        }
        const handler = setTimeout(() => {
            const { thumbnailUrl } = extractVideoInfo(mainUrl);
            if (thumbnailUrl) {
                setAutoThumbnailPreview(thumbnailUrl);
            } else {
                setAutoThumbnailPreview('');
            }
        }, 800);

        return () => clearTimeout(handler);
    }, [mainUrl]);

    useEffect(() => {
        const contentCollectionRef = collection(db, `artifacts/${appId}/public/data/content_items`);
        const q = query(contentCollectionRef, orderBy('orderIndex', 'asc'), orderBy('createdAt', 'desc'));

        const unsubscribe = onSnapshot(q, (snapshot) => {
            const fetchedItems = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            setContentItems(fetchedItems);
            setLoading(false);
        }, (error) => {
            console.error("Error fetching content items for admin:", error);
            showMessage("Failed to load content items.");
            setLoading(false);
        });

        return () => unsubscribe();
    }, [showMessage]);

    const resetForm = () => {
        setTitle('');
        setMainUrl('');
        setCustomThumbnailFile(null);
        setCustomThumbnailUrlPreview('');
        setAutoThumbnailPreview('');
        if (creatorProfile && creatorProfile.role === 'authority') {
            setCreatorName(creatorProfile.creatorName || '');
        } else {
            setCreatorName('');
        }
        setContentType('Skits');
        setOrderIndex(0);
        setIsActive(true);
        setDescription('');
        if (thumbnailFileInputRef.current) {
            thumbnailFileInputRef.current.value = '';
        }
    };

    // =================== START REPLACEMENT ===================
   const handleAddContent = async (e) => {
        e.preventDefault();
        if (!title || !mainUrl || !creatorName || !contentType) {
            showMessage('Please fill in all required fields.');
            return;
        }
        if (!currentUser || (creatorProfile.role !== 'admin' && creatorProfile.role !== 'authority')) {
            showMessage("You don't have permission to add content.");
            return;
        }
        
        // This function does not have a loading spinner state, so no change is needed for that.
        // The core validation logic is what we need to ensure is correct.
        
        let finalThumbnailUrl = '';
        let embedUrl = '';
        let videoPlatform = 'generic';

        if (customThumbnailFile) {
            showMessage('Uploading custom thumbnail...');
            try {
                const fileName = `content_thumbnails/${currentUser.uid}/${Date.now()}_${customThumbnailFile.name}`;
                const storageRefPath = ref(storage, fileName);
                await uploadBytes(storageRefPath, customThumbnailFile);
                finalThumbnailUrl = await getDownloadURL(storageRefPath);
            } catch (error) {
                showMessage(`Failed to upload custom thumbnail: ${error.message}`);
                return; // Stop execution on upload failure
            }
        } else {
            const info = extractVideoInfo(mainUrl);
            if (info.thumbnailUrl && info.thumbnailUrl !== GENERIC_THUMBNAIL_PLACEHOLDER) {
                finalThumbnailUrl = info.thumbnailUrl;
                embedUrl = info.embedUrl;
                videoPlatform = info.platform;
            } else {
                // This is the crucial validation check
                showMessage("Could not get a thumbnail from this URL. Please upload a custom image to continue.");
                return; // Stop execution if no thumbnail is available
            }
        }

        try {
            await addDoc(collection(db, `artifacts/${appId}/public/data/content_items`), {
                title, description, mainUrl, customThumbnailUrl: finalThumbnailUrl,
                embedUrl: embedUrl || extractVideoInfo(mainUrl).embedUrl,
                videoPlatform: videoPlatform || extractVideoInfo(mainUrl).platform,
                creatorId: currentUser.uid, creatorName, contentType,
                orderIndex: parseInt(orderIndex), isActive,
                createdAt: new Date().toISOString(),
                createdBy: currentUser.uid,
                createdByName: creatorProfile.creatorName || currentUser.email,
            });
            showMessage('Content item added successfully!');
            resetForm();
        } catch (error) {
            console.error("Error adding content item:", error);
            showMessage(`Failed to add content item: ${error.message}`);
        }
    };
// =================== END REPLACEMENT =====================

    const deleteContentLogic = async (id, titleToDelete) => {
        if (!currentUser || (creatorProfile.role !== 'admin' && creatorProfile.role !== 'authority')) {
            showMessage("You don't have permission to delete content.");
            return;
        }
        try {
            await deleteDoc(doc(db, `artifacts/${appId}/public/data/content_items`, id));
            showMessage(`Content item "${titleToDelete}" deleted successfully.`);
        } catch (error) {
            console.error("Error deleting content item:", error);
            showMessage(`Failed to delete content item: ${error.message}`);
        }
    };
    
    const confirmDeleteContent = (id, titleToDelete) => {
        setConfirmationTitle("Delete Content?");
        setConfirmationMessage(`Are you sure you want to permanently delete "${titleToDelete}"? This action cannot be undone.`);
        setOnConfirmationAction(() => () => deleteContentLogic(id, titleToDelete));
        setShowConfirmationModal(true);
    };

    const handleToggleActive = async (item) => {
        if (!currentUser || (creatorProfile.role !== 'admin' && creatorProfile.role !== 'authority')) { showMessage("You don't have permission to modify content status."); return; }
        try {
            await updateDoc(doc(db, `artifacts/${appId}/public/data/content_items`, item.id), {
                isActive: !item.isActive, updatedAt: new Date().toISOString(), updatedBy: currentUser.uid
            });
            showMessage(`Content item "${item.title}" status changed to ${!item.isActive ? 'Active' : 'Inactive'}.`);
        } catch (error) {
            console.error("Error toggling content active status:", error);
            showMessage(`Failed to toggle content status: ${error.message}`);
        }
    };

    if (!currentUser || (creatorProfile.role !== 'admin' && creatorProfile.role !== 'authority')) {
        return (
            <div className="screenContainer">
                <p className="heading">Access Denied</p>
                <p className="subHeading">You must be an Admin or Authority to manage content.</p>
                <button className="button" onClick={() => setActiveScreen('AdminDashboard')}><span className="buttonText">Back to Admin Dashboard</span></button>
            </div>
        );
    }
    
    const currentPreview = customThumbnailUrlPreview || autoThumbnailPreview;

    return (
        <div className="screenContainer">
            <p className="heading">Manage Content</p>
            <p className="subHeading">Curate the home screen and add new videos to the content library.</p>
            
            <AdminFeaturedContentManager featuredContentSlots={featuredContentSlots} showMessage={showMessage} />

            <div className="dashboardSection" style={{marginTop: '30px', border: '1px solid #00FF00'}}>
                <p className="dashboardSectionTitle">Home Screen Curation</p>
                <p className="dashboardItem" style={{color: '#AAA', marginBottom: '15px'}}>
                    Manually add, remove, and reorder content for the main sections on the Home screen.
                </p>
                <div style={{display: 'flex', justifyContent: 'space-around', gap: '10px', marginTop: '15px'}}>
                    <button type="button" className="button" onClick={() => openCurationModal('Featured')} style={{margin: 0}}>
                        <span className="buttonText">Manage Featured</span>
                    </button>
                    <button type="button" className="button" onClick={() => openCurationModal('Trending')} style={{margin: 0}}>
                        <span className="buttonText">Manage Trending</span>
                    </button>
                </div>
            </div>

            <div className="dashboardSection">
                <p className="dashboardSectionTitle">Add New Content to Library</p>
                <form onSubmit={handleAddContent}>
                    <div className="formGroup"><label htmlFor="contentTitle" className="formLabel">Title:</label><input type="text" id="contentTitle" className="formInput" value={title} onChange={(e) => setTitle(e.target.value)} required /></div>
                    <div className="formGroup"><label htmlFor="contentDescription" className="formLabel">Description:</label><textarea id="contentDescription" className="formTextarea" value={description} onChange={(e) => setDescription(e.target.value)} placeholder="Brief description for the content item"></textarea></div>
                    <div className="formGroup"><label htmlFor="mainUrl" className="formLabel">Main Content URL (Video/Project Link):</label><input type="url" id="mainUrl" className="formInput" value={mainUrl} onChange={(e) => setMainUrl(e.target.value)} placeholder="e.g., YouTube link, Facebook video" required /><p className="smallText" 
                    style={{textAlign: 'left', marginTop: '5px', color: '#AAA'}}>We'll try to extract a thumbnail from this link.</p></div>
                    {currentPreview && (
                        <div style={{ marginTop: '10px' }}>
                            <p className="formLabel" style={{marginBottom: '5px'}}>Thumbnail Preview:</p>
                            <img src={currentPreview} alt="Thumbnail Preview" style={{ maxWidth: '150px', borderRadius: '8px', border: '2px solid #FFD700' }} />
                        </div>
                    )}
                    <div className="formGroup"><label htmlFor="customThumbnailFile" className="formLabel">Custom Thumbnail Image (Optional):</label><input type="file" id="customThumbnailFile" ref={thumbnailFileInputRef} className="formInput" onChange={handleThumbnailFileSelect} accept="image/*" style={{padding: '10px 0', border: 'none', backgroundColor: 'transparent'}} /><p className="smallText" style={{textAlign: 'left', marginTop: '5px', color: '#AAA'}}>Upload an image to override the thumbnail from the video link.</p></div>
                    <div className="formGroup">
                        <label htmlFor="creatorName" className="formLabel">Creator Name:</label>
                        <input
                            type="text"
                            id="creatorName"
                            className="formInput"
                            value={creatorName}
                            onChange={(e) => setCreatorName(e.target.value)}
                            required
                            disabled={creatorProfile && creatorProfile.role === 'authority'}
                            style={creatorProfile && creatorProfile.role === 'authority' ? { backgroundColor: '#2A2A2A', cursor: 'not-allowed' } : {}}
                        />
                    </div>
                    <div className="formGroup">
                        <label htmlFor="contentType" className="formLabel">Content Type:</label>
                        <select id="contentType" className="formInput" value={contentType} onChange={(e) => setContentType(e.target.value)} required>
                            {availableCategories.length === 0 ? (
                                <option>Loading categories...</option>
                            ) : (
                                availableCategories.map(cat => (<option key={cat} value={cat}>{cat}</option>))
                            )}
                        </select>
                    </div>
                    <div className="formGroup"><label htmlFor="orderIndex" className="formLabel">Display Order Index (Lower numbers appear first):</label><input type="number" id="orderIndex" className="formInput" value={orderIndex} onChange={(e) => setOrderIndex(e.target.value)} min="0" /></div>
                    <div className="formGroup"><div className="checkboxItem"><input type="checkbox" id="isActive" checked={isActive} onChange={(e) => setIsActive(e.target.checked)} /><label htmlFor="isActive">Is Active (Show on public pages)</label></div></div>
                    <button type="submit" className="button"><span className="buttonText">Add Content Item</span></button>
                    <button type="button" className="button" onClick={resetForm} style={{ backgroundColor: '#555', color: '#FFF', marginLeft: '10px' }}><span className="buttonText">Clear Form</span></button>
                </form>
            </div>

            <div className="dashboardSection" style={{ marginTop: '30px' }}>
                <div 
                    className="flex justify-between items-center cursor-pointer" 
                    onClick={() => setIsContentListExpanded(!isContentListExpanded)}
                >
                    <p className="dashboardSectionTitle" style={{ marginBottom: 0 }}>Existing Content Items ({contentItems.length})</p>
                    <button className="text-xl font-bold text-white">{isContentListExpanded ? '▼' : '▶'}</button>
                </div>
                
                <div className={`overflow-hidden transition-all duration-500 ease-in-out ${isContentListExpanded ? 'max-h-[3000px] mt-4' : 'max-h-0'}`}>
                    <div className="pt-4 border-t" style={{borderColor: '#3A3A3A'}}>
                        {loading ? <p>Loading...</p> : (
                            <div className="dashboardContentList">
                                {contentItems.map(item => (
                                    <div key={item.id} className="adminDashboardItem">
                                        <img src={item.customThumbnailUrl || 'https://placehold.co/50x50/3A3A3A/FFF?text=X'} alt="Thumbnail" style={{ width: '50px', height: '50px', borderRadius: '5px', objectFit: 'cover', marginRight: '10px' }} />
                                        <div style={{ flexGrow: 1 }}>
                                            <p className="adminDashboardItemTitle">{item.title}</p>
                                            <p style={{ fontSize: '12px', color: '#CCC' }}>Creator: {item.creatorName} | Type: {item.contentType}</p>
                                            <p style={{ fontSize: '12px', color: item.isActive ? '#00FF00' : '#DC3545' }}>Status: {item.isActive ? 'Active' : 'Inactive'}</p>
                                        </div>
                                        <button className="adminActionButton" onClick={() => handleToggleActive(item)} style={{ backgroundColor: item.isActive ? '#DC3545' : '#008000', color: '#FFF' }}>{item.isActive ? 'Deactivate' : 'Activate'}</button>
                                        <button className="adminActionButton reject" onClick={() => confirmDeleteContent(item.id, item.title)}>Delete</button>
                                    </div>
                                ))}
                            </div>
                        )}
                    </div>
                </div>
            </div>
            
            {showCurationModal && (
                <AdminCurationModal 
                    curationTarget={curationTarget}
                    showMessage={showMessage}
                    onCancel={() => setShowCurationModal(false)}
                    contentItems={contentItems}
                />
            )}
       
                

        </div>
    );
};
// ====================== END: FULL COMPONENT REPLACEMENT ======================

    // FINAL VERSION of AdminSiteManagerScreen (with Inbox)
    
        const AdminSiteManagerScreen = ({ showMessage, setActiveScreen, setShowConfirmationModal, setConfirmationTitle, setConfirmationMessage, setOnConfirmationAction, creatorProfile }) => {
    const [socialLinks, setSocialLinks] = useState([]);
    const [isLoading, setIsLoading] = useState(true);
    const [isSaving, setIsSaving] = useState(false);
    const [hasChanges, setHasChanges] = useState(false);
    const [isLeaderboardEnabled, setIsLeaderboardEnabled] = useState(false);
    const [premiumPrice, setPremiumPrice] = useState(1.99);
    const [ticketPrice, setTicketPrice] = useState(5.00);
    const [promotedStatusPrice, setPromotedStatusPrice] = useState(10.00);
    const [isTicketedEvent, setIsTicketedEvent] = useState(false);
    const [submissions, setSubmissions] = useState([]);
    const [isLoadingSubmissions, setIsLoadingSubmissions] = useState(true);
    const [selectedSubmission, setSelectedSubmission] = useState(null);
    const [diagnosticResults, setDiagnosticResults] = useState(null);
    const [isDiagnosing, setIsDiagnosing] = useState(false);
    const [mmgNumber, setMmgNumber] = useState('');
    const [isCleaning, setIsCleaning] = useState(false);
    const [cleanupResults, setCleanupResults] = useState(null);
    const [isAuditing, setIsAuditing] = useState(false);
    const [auditResults, setAuditResults] = useState(null);

    // --- START: NEW STATE FOR SUPPORT HUB CONTENT ---
    const [supportHubContent, setSupportHubContent] = useState({
        hubTitle: '', hubSubtitle: '',
        card1Title: '', card1Desc: '',
        card2Title: '', card2Desc: '',
        card3Title: '', card3Desc: '',
        premiumPerks: [], advertiserPerks: []
    });
    const [newPremiumPerk, setNewPremiumPerk] = useState('');
    const [newAdvertiserPerk, setNewAdvertiserPerk] = useState('');
    const [isLoadingSupportContent, setIsLoadingSupportContent] = useState(true);
    const [hasSupportContentChanges, setHasSupportContentChanges] = useState(false);
    // --- END: NEW STATE FOR SUPPORT HUB CONTENT ---

    // This useEffect now fetches BOTH social links AND the new support hub content
    useEffect(() => {
        const socialLinksDocRef = doc(db, "settings", "socialLinks");
        const supportHubDocRef = doc(db, "settings", "supportHubContent");

        const unsubSocial = onSnapshot(socialLinksDocRef, (docSnap) => {
           if (docSnap.exists()) {
                const data = docSnap.data();
                setSocialLinks(Array.isArray(data.links) ? [...data.links].sort((a, b) => a.name.localeCompare(b.name)) : []);
                setIsLeaderboardEnabled(data.isLeaderboardEnabled ?? false);
                setPremiumPrice(data.premiumPrice ?? 1.99);
                setTicketPrice(data.ticketPrice ?? 5.00);
                setPromotedStatusPrice(data.promotedStatusPrice ?? 10.00);
                setIsTicketedEvent(data.isTicketedEvent ?? false);
                setMmgNumber(data.mmgNumber ?? '');
            }
            setIsLoading(false);
        });
        
        // --- NEW: Fetch logic for support hub content ---
        const unsubSupport = onSnapshot(supportHubDocRef, (docSnap) => {
            if (docSnap.exists()) {
                setSupportHubContent(docSnap.data());
            }
            setIsLoadingSupportContent(false);
        });

        return () => {
            unsubSocial();
            unsubSupport(); // Unsubscribe from both listeners
        };
    }, []);

    // --- START: NEW HANDLERS FOR SUPPORT HUB ---
    const handleSupportContentChange = (field, value) => {
        setSupportHubContent(prev => ({ ...prev, [field]: value }));
        setHasSupportContentChanges(true);
    };

    const handleAddPerk = (type) => {
        setHasSupportContentChanges(true);
        if (type === 'premium') {
            if (!newPremiumPerk.trim()) return;
            setSupportHubContent(prev => ({ ...prev, premiumPerks: [...prev.premiumPerks, newPremiumPerk] }));
            setNewPremiumPerk('');
        } else {
            if (!newAdvertiserPerk.trim()) return;
            setSupportHubContent(prev => ({ ...prev, advertiserPerks: [...prev.advertiserPerks, newAdvertiserPerk] }));
            setNewAdvertiserPerk('');
        }
    };
    
    const handleRemovePerk = (type, index) => {
        setHasSupportContentChanges(true);
        if (type === 'premium') {
            setSupportHubContent(prev => ({ ...prev, premiumPerks: prev.premiumPerks.filter((_, i) => i !== index) }));
        } else {
            setSupportHubContent(prev => ({ ...prev, advertiserPerks: prev.advertiserPerks.filter((_, i) => i !== index) }));
        }
    };
    
    const handleSaveChanges = async (section) => {
        if (section === 'supportHub') {
            if (!hasSupportContentChanges) return;
            setIsSaving(true); showMessage("Saving Support Hub content...");
            try {
                const supportHubDocRef = doc(db, "settings", "supportHubContent");
                await setDoc(supportHubDocRef, supportHubContent, { merge: true });
                showMessage("Support Hub content saved successfully!");
                setHasSupportContentChanges(false);
            } catch (error) { showMessage(`Error: ${error.message}`); }
            finally { setIsSaving(false); }
        } else {
             if (!hasChanges) return;
            setIsSaving(true); showMessage("Saving site settings...");
            try {
                const socialLinksDocRef = doc(db, "settings", "socialLinks");
                await setDoc(socialLinksDocRef, { links: socialLinks, isLeaderboardEnabled, premiumPrice: parseFloat(premiumPrice), ticketPrice: parseFloat(ticketPrice), promotedStatusPrice: parseFloat(promotedStatusPrice), isTicketedEvent, mmgNumber }, { merge: true });
                showMessage("Site settings saved successfully!");
                setHasChanges(false);
            } catch (error) { showMessage(`Error saving changes: ${error.message}`); }
            finally { setIsSaving(false); }
        }
    };
    // --- END: NEW HANDLERS FOR SUPPORT HUB ---

    // All other handlers (for submissions, diagnostics, etc.) remain unchanged.
    useEffect(() => { setIsLoadingSubmissions(true); const submissionsRef = collection(db, "contactSubmissions"); const q = query(submissionsRef, orderBy("submittedAt", "desc")); const unsubscribe = onSnapshot(q, (snapshot) => { setSubmissions(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }))); setIsLoadingSubmissions(false); }, (error) => { showMessage("Failed to load submissions."); setIsLoadingSubmissions(false); }); return () => unsubscribe(); }, []);
    const handleRunDiagnostics = async () => { setIsDiagnosing(true); setDiagnosticResults(null); showMessage("Running system diagnostics..."); try { const runDiagnosticsCallable = window.httpsCallable(window.firebaseFunctions, 'runSystemDiagnostics'); const result = await runDiagnosticsCallable(); setDiagnosticResults(result.data.diagnosticResults); showMessage("Diagnostics complete."); } catch (error) { showMessage(`Diagnostics failed: ${error.message}`); setDiagnosticResults({ error: error.message }); } finally { setIsDiagnosing(false); } };
    const handleCleanup = async () => { setIsCleaning(true); setCleanupResults("Initiating cleanup..."); showMessage("Starting ghost artifact cleanup..."); try { const functions = getFunctions(window.firebaseApp); const cleanupCallable = httpsCallable(functions, 'cleanupGhostArtifacts'); const result = await cleanupCallable(); setCleanupResults(result.data.message); showMessage("Cleanup process finished!"); } catch (error) { const errorMessage = `Cleanup failed: ${error.message}`; setCleanupResults(errorMessage); showMessage(errorMessage); } finally { setIsCleaning(false); } };
    const confirmCleanup = () => { setConfirmationTitle("Confirm Database Cleanup"); setConfirmationMessage("This will permanently delete all old artifact documents that do not match the stable 'production-app-id'. This action is irreversible. Are you absolutely sure you want to proceed?"); setOnConfirmationAction(() => () => handleCleanup()); setShowConfirmationModal(true); };
    const handleRunAudit = async () => { setIsAuditing(true); setAuditResults("Starting data integrity audit..."); showMessage("Starting data integrity audit..."); try { const auditFunction = httpsCallable(functions, 'runDataIntegrityAudit'); const result = await auditFunction(); setAuditResults(result.data.summary); showMessage("Audit complete! See results below."); } catch (error) { const errorMessage = `Audit failed: ${error.message}`; setAuditResults({ error: errorMessage }); showMessage(errorMessage); } finally { setIsAuditing(false); } };
    const handleUpdateField = (fieldName, value) => { if (fieldName === 'isLeaderboardEnabled') { setIsLeaderboardEnabled(value); } else { const [index, field] = fieldName.split('-'); const updatedLinks = [...socialLinks]; updatedLinks[parseInt(index)][field] = value; setSocialLinks(updatedLinks); } setHasChanges(true); };
    const handleViewSubmission = async (submission) => { setSelectedSubmission(submission); if (submission.status === 'New') { try { await updateDoc(doc(db, "contactSubmissions", submission.id), { status: 'Read' }); } catch (error) { console.error("Error marking submission as read:", error); } } };
    const deleteSubmissionLogic = async (submissionId) => { showMessage("Deleting submission..."); try { await deleteDoc(doc(db, "contactSubmissions", submissionId)); setSelectedSubmission(null); showMessage("Submission deleted successfully."); } catch (error) { showMessage(`Failed to delete submission: ${error.message}`); } };
    const confirmDeleteSubmission = (submission) => { setSelectedSubmission(null); setConfirmationTitle("Delete Submission?"); setConfirmationMessage(`Are you sure you want to permanently delete this message from "${submission.userName}"? This action cannot be undone.`); setOnConfirmationAction(() => () => deleteSubmissionLogic(submission.id)); setShowConfirmationModal(true); };
    if (isLoading) { return <div className="screenContainer"><p className="heading">Loading Site Settings...</p></div>; }
    const currentUserRole = creatorProfile ? creatorProfile.role : 'user';

    return (
        <div className="screenContainer">
            <p className="heading">Site Management</p>
            
            {/* THIS IS THE NEW SUPPORT HUB MANAGEMENT SECTION */}
            <div className="dashboardSection" style={{ border: '2px solid #00FF00', marginTop: '20px' }}>
                <div className="flex justify-between items-center mb-4">
                    <p className="dashboardSectionTitle" style={{marginBottom: 0, color: '#00FF00'}}>Support Hub Content</p>
                    <button className="button" onClick={() => handleSaveChanges('supportHub')} disabled={!hasSupportContentChanges || isSaving}>
                        <span className="buttonText">{isSaving ? 'Saving...' : 'Save Hub Content'}</span>
                    </button>
                </div>
                {isLoadingSupportContent ? <p>Loading content...</p> : (
                    <>
                        <div className="formGroup"><label className="formLabel">Hub Main Title:</label><input type="text" className="formInput" value={supportHubContent.hubTitle} onChange={(e) => handleSupportContentChange('hubTitle', e.target.value)} /></div>
                        <div className="formGroup"><label className="formLabel">Hub Subtitle:</label><textarea className="formTextarea" value={supportHubContent.hubSubtitle} onChange={(e) => handleSupportContentChange('hubSubtitle', e.target.value)} /></div>
                        <hr style={{borderColor: '#444', margin: '20px 0'}}/>
                        <div className="formGroup"><label className="formLabel">Premium Card Title:</label><input type="text" className="formInput" value={supportHubContent.card1Title} onChange={(e) => handleSupportContentChange('card1Title', e.target.value)} /></div>
                        <div className="formGroup"><label className="formLabel">Premium Card Description:</label><input type="text" className="formInput" value={supportHubContent.card1Desc} onChange={(e) => handleSupportContentChange('card1Desc', e.target.value)} /></div>
                        <div className="formGroup"><label className="formLabel">Advertiser Card Title:</label><input type="text" className="formInput" value={supportHubContent.card2Title} onChange={(e) => handleSupportContentChange('card2Title', e.target.value)} /></div>
                        <div className="formGroup"><label className="formLabel">Advertiser Card Description:</label><input type="text" className="formInput" value={supportHubContent.card2Desc} onChange={(e) => handleSupportContentChange('card2Desc', e.target.value)} /></div>
                        <div className="formGroup"><label className="formLabel">Campaign Card Title:</label><input type="text" className="formInput" value={supportHubContent.card3Title} onChange={(e) => handleSupportContentChange('card3Title', e.target.value)} /></div>
                        <div className="formGroup"><label className="formLabel">Campaign Card Description:</label><input type="text" className="formInput" value={supportHubContent.card3Desc} onChange={(e) => handleSupportContentChange('card3Desc', e.target.value)} /></div>
                        <hr style={{borderColor: '#444', margin: '20px 0'}}/>
                        {/* Premium Perks Manager */}
                        <div>
                            <label className="formLabel">Premium Perks List:</label>
                            {supportHubContent.premiumPerks?.map((perk, index) => (<div key={index} className="adminDashboardItem"><span className="flex-grow">{perk}</span><button onClick={() => handleRemovePerk('premium', index)} className="adminActionButton reject">Delete</button></div>))}
                            <div className="flex items-end gap-4 mt-2"><input type="text" className="formInput flex-grow" value={newPremiumPerk} onChange={(e) => setNewPremiumPerk(e.target.value)} placeholder="Add new perk..." /><button onClick={() => handleAddPerk('premium')} className="button m-0"><span className="buttonText">Add</span></button></div>
                        </div>
                        <hr style={{borderColor: '#444', margin: '20px 0'}}/>
                        {/* Advertiser Perks Manager */}
                        <div>
                            <label className="formLabel">Advertiser Perks List:</label>
                            {supportHubContent.advertiserPerks?.map((perk, index) => (<div key={index} className="adminDashboardItem"><span className="flex-grow">{perk}</span><button onClick={() => handleRemovePerk('advertiser', index)} className="adminActionButton reject">Delete</button></div>))}
                            <div className="flex items-end gap-4 mt-2"><input type="text" className="formInput flex-grow" value={newAdvertiserPerk} onChange={(e) => setNewAdvertiserPerk(e.target.value)} placeholder="Add new perk..." /><button onClick={() => handleAddPerk('advertiser')} className="button m-0"><span className="buttonText">Add</span></button></div>
                        </div>
                    </>
                )}
            </div>

            <div className="dashboardSection"><div className="flex justify-between items-center mb-4"><p className="dashboardSectionTitle" style={{marginBottom: 0}}>Social Links Manager</p><button className="button" onClick={() => handleSaveChanges('siteSettings')} disabled={!hasChanges || isSaving}><span className="buttonText">{isSaving ? 'Saving...' : 'Save Changes'}</span></button></div><div className="dashboardContentList">{socialLinks.map((link, index) => (<div key={link.name || index} className="adminDashboardItem" style={{flexDirection: 'column', alignItems: 'stretch', gap: '10px'}}><div className="flex justify-between items-center"><p className="adminDashboardItemTitle">{link.name}</p><label className="flex items-center cursor-pointer"><span className="mr-3 text-sm font-medium text-gray-300">{link.isEnabled ? 'Visible' : 'Hidden'}</span><div className="relative"><input type="checkbox" className="sr-only" checked={link.isEnabled} onChange={(e) => handleUpdateField(`${index}-isEnabled`, e.target.checked)} /><div className={`block w-14 h-8 rounded-full ${link.isEnabled ? 'bg-green-500' : 'bg-gray-600'}`}></div><div className={`dot absolute left-1 top-1 bg-white w-6 h-6 rounded-full transition-transform ${link.isEnabled ? 'transform translate-x-6' : ''}`}></div></div></label></div><div className="formGroup" style={{marginBottom: 0}}><label className="formLabel" style={{fontSize: '12px', color: '#AAA'}}>URL:</label><input type="url" className="formInput" value={link.url} onChange={(e) => handleUpdateField(`${index}-url`, e.target.value)} placeholder={`Enter full URL for ${link.name}`} /></div></div>))}</div></div>
            <div className="dashboardSection"><p className="dashboardSectionTitle">Feature Toggles</p><div className="adminDashboardItem"><p className="adminDashboardItemTitle" style={{fontWeight: 'normal'}}>Enable Top Performers Screen</p><label className="flex items-center cursor-pointer"><span className="mr-3 text-sm font-medium text-gray-300">{isLeaderboardEnabled ? 'Enabled' : 'Disabled'}</span><div className="relative"><input type="checkbox" className="sr-only" checked={isLeaderboardEnabled} onChange={(e) => handleUpdateField('isLeaderboardEnabled', e.target.checked)} /><div className={`block w-14 h-8 rounded-full ${isLeaderboardEnabled ? 'bg-green-500' : 'bg-gray-600'}`}></div><div className={`dot absolute left-1 top-1 bg-white w-6 h-6 rounded-full transition-transform ${isLeaderboardEnabled ? 'transform translate-x-6' : ''}`}></div></div></label></div></div>
            <div className="dashboardSection"><p className="dashboardSectionTitle">Monetization Settings</p><div className="adminDashboardItem"><p className="adminDashboardItemTitle" style={{fontWeight: 'normal'}}>Premium Subscription Price (USD)</p><input type="number" className="formInput" value={premiumPrice} onChange={(e) => { setPremiumPrice(e.target.value); setHasChanges(true); }} style={{width: '100px', textAlign: 'right'}} /></div><div className="adminDashboardItem"><p className="adminDashboardItemTitle" style={{fontWeight: 'normal'}}>Promoted Status Price (USD)</p><input type="number" className="formInput" value={promotedStatusPrice} onChange={(e) => { setPromotedStatusPrice(e.target.value); setHasChanges(true); }} style={{width: '100px', textAlign: 'right'}} /></div>{currentUserRole === 'admin' && (<div className="adminDashboardItem"><p className="adminDashboardItemTitle" style={{fontWeight: 'normal', color: '#FFD700'}}>MMG Account Number</p><input type="text" className="formInput" value={mmgNumber} onChange={(e) => { setMmgNumber(e.target.value); setHasChanges(true); }} placeholder="Enter MMG number..." style={{width: '200px', textAlign: 'right'}} /></div>)}</div>
            <div className="dashboardSection" style={{marginTop: '20px'}}><p className="dashboardSectionTitle">Contact Form Submissions</p>{isLoadingSubmissions ? <p>Loading submissions...</p> : (<div className="dashboardContentList">{submissions.length === 0 ? <p className="dashboardItem">No submissions yet.</p> : (submissions.map(sub => (<div key={sub.id} className="adminDashboardItem" onClick={() => handleViewSubmission(sub)} style={{cursor: 'pointer', borderLeft: sub.status === 'New' ? '4px solid #FFD700' : '4px solid transparent'}}><div style={{flexGrow: 1}}><p className="adminDashboardItemTitle">{sub.queryType} - <span style={{fontWeight: 'normal'}}>{sub.userName}</span></p><p style={{fontSize: '12px', color: '#AAA'}}>{new Date(sub.submittedAt).toLocaleString()}</p></div><span className="adminDashboardItemStatus">{sub.status}</span></div>)))}</div>)}{selectedSubmission && (<div className="confirmationModalOverlay" style={{zIndex: 2500}}><div className="confirmationModalContent" style={{textAlign: 'left', maxWidth: '500px'}}><p className="confirmationModalTitle">{selectedSubmission.queryType}</p><div className="dashboardItem"><strong>From:</strong> {selectedSubmission.userName}</div><div className="dashboardItem"><strong>Email:</strong> <a href={`mailto:${selectedSubmission.userEmail}`} className="termsLink">{selectedSubmission.userEmail}</a></div><div className="dashboardItem"><strong>Date:</strong> {new Date(selectedSubmission.submittedAt).toLocaleString()}</div><hr style={{borderColor: '#333', margin: '15px 0'}}/><p className="paragraph" style={{backgroundColor: '#0A0A0A', padding: '10px', borderRadius: '5px', whiteSpace: 'pre-wrap'}}>{selectedSubmission.message}</p><div className="confirmationModalButtons"><button className="confirmationButton cancel" onClick={() => confirmDeleteSubmission(selectedSubmission)}>Delete</button><button className="confirmationButton confirm" onClick={() => setSelectedSubmission(null)}>Close</button></div></div></div>)}</div>
            <div className="dashboardSection" style={{ border: '2px solid #FF8C00', marginTop: '20px' }}><p className="dashboardSectionTitle">Data Integrity Tools</p><p className="dashboardItem" style={{ color: '#AAA', marginBottom: '15px' }}>Use these tools to perform database maintenance. These are powerful actions. Use with caution.</p><button className="button" onClick={confirmCleanup} style={{ backgroundColor: '#DC3545' }} disabled={isCleaning}><span className="buttonText">{isCleaning ? 'Cleaning...' : 'Clean Up Ghost Artifacts'}</span></button>{cleanupResults && (<p className="paragraph" style={{ marginTop: '15px', backgroundColor: '#1A1A1A', padding: '10px', borderRadius: '5px', whiteSpace: 'pre-wrap' }}>{cleanupResults}</p>)}<div style={{borderTop: '1px solid #444', marginTop: '20px', paddingTop: '20px'}}><button className="button" onClick={handleRunAudit} style={{ backgroundColor: '#FFD700' }} disabled={isAuditing}><span className="buttonText" style={{color: '#0A0A0A'}}>{isAuditing ? 'Auditing...' : 'Run Full Data Integrity Audit'}</span></button>{auditResults && (<div style={{marginTop: '15px'}}><p className="dashboardSectionTitle" style={{fontSize: '16px'}}>Audit Results:</p><pre className="paragraph" style={{ backgroundColor: '#1A1A1A', padding: '10px', borderRadius: '5px', whiteSpace: 'pre-wrap', color: '#00FF00', fontSize: '12px' }}>{JSON.stringify(auditResults, null, 2)}</pre></div>)}</div></div>
            <div className="dashboardSection" style={{ border: '2px solid #00FFFF', marginTop: '20px' }}><p className="dashboardSectionTitle">System Status</p><button className="button" onClick={handleRunDiagnostics} style={{ backgroundColor: '#008080' }} disabled={isDiagnosing}><span className="buttonText">{isDiagnosing ? 'Running...' : 'Run System Diagnostics'}</span></button>{diagnosticResults && (<div style={{ marginTop: '15px', color: '#FFF' }}>{diagnosticResults.error ? (<p style={{ color: '#DC3545' }}>Error: {diagnosticResults.error}</p>) : (<table style={{ width: '100%', borderCollapse: 'collapse' }}><tbody><tr style={{ borderBottom: '1px solid #3A3A3A' }}><td style={{ padding: '8px 0', fontWeight: 'bold' }}>Project ID:</td><td style={{ textAlign: 'right' }}>{diagnosticResults.projectID}</td></tr><tr style={{ borderBottom: '1px solid #3A3A3A' }}><td style={{ padding: '8px 0', fontWeight: 'bold' }}>Database Connectivity:</td><td style={{ textAlign: 'right', color: diagnosticResults.dbConnectivity === 'Success' ? '#00FF00' : '#DC3545', fontWeight: 'bold' }}>{diagnosticResults.dbConnectivity}</td></tr></tbody></table>)}</div>)}</div>
        </div>
    );
};
// =================== END: REPLACE THIS ENTIRE COMPONENT ===================


        const SupportUsScreen = ({ setActiveScreen }) => {
    const [content, setContent] = useState(null);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        const docRef = doc(db, "settings", "supportHubContent");
        const unsubscribe = onSnapshot(docRef, (docSnap) => {
            if (docSnap.exists()) {
                setContent(docSnap.data());
            } else {
                // Provide fallback content if the document doesn't exist yet
                setContent({
                    hubTitle: "Support the NVA Network",
                    hubSubtitle: "Your support empowers Caribbean creators and helps us bring more unique content to the world.",
                    card1Title: "Become a Premium Member",
                    card1Desc: "Get exclusive access, ad-free viewing, and support the platform directly.",
                    card2Title: "Become a Verified Advertiser",
                    card2Desc: "Promote your brand on our home page and post to Creator Connect.",
                    card3Title: "Support a Creator Campaign",
                    card3Desc: "Directly fund a specific project and help bring a creator's vision to life."
                });
            }
            setLoading(false);
        });
        return () => unsubscribe();
    }, []);

    if (loading) {
        return <div className="screenContainer"><p className="heading">Loading...</p></div>;
    }

    return (
        <div className="screenContainer">
            <p className="heading">{content.hubTitle}</p>
            <p className="subHeading">{content.hubSubtitle}</p>

            <div className="allCampaignsList">
                <div className="allCampaignsListItem" onClick={() => setActiveScreen('PremiumPerks')} style={{borderLeft: '5px solid #FFD700'}}>
                    <div className="campaignListContent">
                        <p className="campaignListTitle">{content.card1Title}</p>
                        <p className="campaignListDescription">{content.card1Desc}</p>
                    </div>
                </div>
                <div className="allCampaignsListItem" onClick={() => setActiveScreen('AdvertiserPerks')} style={{borderLeft: '5px solid #00FFFF'}}>
                    <div className="campaignListContent">
                        <p className="campaignListTitle" style={{color: '#00FFFF'}}>{content.card2Title}</p>
                        <p className="campaignListDescription">{content.card2Desc}</p>
                    </div>
                </div>
                <div className="allCampaignsListItem" onClick={() => setActiveScreen('Crowdfunding')} style={{borderLeft: '5px solid #CCC'}}>
                    <div className="campaignListContent">
                        <p className="campaignListTitle" style={{color: '#FFF'}}>{content.card3Title}</p>
                        <p className="campaignListDescription">{content.card3Desc}</p>
                    </div>
                </div>
            </div>
            
            <button className="button" onClick={() => setActiveScreen('Home')} style={{ backgroundColor: '#3A3A3A', marginTop: '30px' }}>
                <span className="buttonText light">Back to Home</span>
            </button>
        </div>
    );
};

const PremiumPerksScreen = ({ setActiveScreen }) => {
    const [perks, setPerks] = useState([]);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        const docRef = doc(db, "settings", "supportHubContent");
        const unsubscribe = onSnapshot(docRef, (docSnap) => {
            if (docSnap.exists() && Array.isArray(docSnap.data().premiumPerks)) {
                setPerks(docSnap.data().premiumPerks);
            }
            setLoading(false);
        });
        return () => unsubscribe();
    }, []);

    return (
        <div className="screenContainer">
            <p className="heading">Premium Member Perks</p>
            <p className="subHeading">Unlock the ultimate NVA Network experience.</p>
            {loading ? <p>Loading perks...</p> : perks.map((perk, index) => (
                <div key={index} className="premiumFeatureCard">
                    <p className="premiumFeatureDescription">✓ {perk}</p>
                </div>
            ))}
            <button className="button" onClick={() => setActiveScreen('Premium')} style={{marginTop: '20px'}}>
                <span className="buttonText">Become a Premium Member</span>
            </button>
            <button className="button" onClick={() => setActiveScreen('SupportUsScreen')} style={{ backgroundColor: '#3A3A3A', marginTop: '10px' }}>
                <span className="buttonText light">Back to Support Hub</span>
            </button>
        </div>
    );
};

const AdvertiserPerksScreen = ({ setActiveScreen }) => {
    const [perks, setPerks] = useState([]);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        const docRef = doc(db, "settings", "supportHubContent");
        const unsubscribe = onSnapshot(docRef, (docSnap) => {
            if (docSnap.exists() && Array.isArray(docSnap.data().advertiserPerks)) {
                setPerks(docSnap.data().advertiserPerks);
            }
            setLoading(false);
        });
        return () => unsubscribe();
    }, []);
    
    return (
        <div className="screenContainer">
            <p className="heading" style={{color: '#00FFFF'}}>Verified Advertiser Perks</p>
            <p className="subHeading">Maximize your brand's visibility and connect with top talent.</p>
            {loading ? <p>Loading perks...</p> : perks.map((perk, index) => (
                <div key={index} className="premiumFeatureCard" style={{borderLeft: '3px solid #00FFFF'}}>
                    <p className="premiumFeatureDescription">✓ {perk}</p>
                </div>
            ))}
             <button className="button" onClick={() => setActiveScreen('Contact')} style={{marginTop: '20px', backgroundColor: '#0A0A0A', border: '1px solid #00FFFF'}}>
                <span className="buttonText" style={{color: '#00FFFF'}}>Contact Us for Verification</span>
            </button>
            <button className="button" onClick={() => setActiveScreen('SupportUsScreen')} style={{ backgroundColor: '#3A3A3A', marginTop: '10px' }}>
                <span className="buttonText light">Back to Support Hub</span>
            </button>
        </div>
    );
};

            // ======================================================================
// ========= START: ADD THIS ENTIRE NEW COMPONENT =======================
// ======================================================================
const AdminCompetitionManager = ({ showMessage, setActiveScreen, currentUser, setSelectedCompAdmin, creatorProfile, setShowConfirmationModal, setConfirmationTitle, setConfirmationMessage, setOnConfirmationAction }) => {    const [title, setTitle] = useState('');
    const [competitionType, setCompetitionType] = useState('Photo');
    const [description, setDescription] = useState('');
    const [rules, setRules] = useState('');
    const [prizesText, setPrizesText] = useState('');
    const [flyerFile, setFlyerFile] = useState(null);
    const [flyerPreview, setFlyerPreview] = useState('');
    const [flyerUrl, setFlyerUrl] = useState('');
    const [entryDeadline, setEntryDeadline] = useState('');
    
    const [competitionEnd, setCompetitionEnd] = useState('');
    const [resultsDate, setResultsDate] = useState('');
    const [isSubmitting, setIsSubmitting] = useState(false);
    const flyerInputRef = useRef(null);

    const [competitions, setCompetitions] = useState([]);
    const [loadingComps, setLoadingComps] = useState(true);
    const [managingComp, setManagingComp] = useState(null);

    const resetForm = () => {
        setTitle('');
        setCompetitionType('Photo');
        setDescription('');
        setRules('');
        setPrizesText('');
        setFlyerFile(null);
        setFlyerPreview('');
        setFlyerUrl('');
        setEntryDeadline('');
        setCompetitionEnd('');
        setResultsDate('');
        if(flyerInputRef.current) {
            flyerInputRef.current.value = null;
        }
    };

        useEffect(() => {
    const compRef = collection(db, "competitions");
    const q = query(compRef, orderBy("createdAt", "desc"));

    const unsubscribe = onSnapshot(q, (snapshot) => {
        setCompetitions(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
        setLoadingComps(false);
    });

    return () => unsubscribe();
}, []);

    const handleSaveAsDraft = async () => {
        if (!title.trim()) {
            showMessage("Competition Title is a required field.");
            return;
        }
        setIsSubmitting(true);
        let uploadedFlyerUrl = '';

        // Step 1: Upload the flyer image if it exists
        if (flyerFile) {
            showMessage("Uploading flyer image...");
            try {
                const filePath = `competition_flyers/${Date.now()}_${flyerFile.name}`;
                const storageRefPath = ref(storage, filePath);
                const snapshot = await uploadBytes(storageRefPath, flyerFile);
                uploadedFlyerUrl = await getDownloadURL(snapshot.ref);
                showMessage("Flyer uploaded successfully.");
            } catch (error) {
                showMessage(`Flyer upload failed: ${error.message}`);
                setIsSubmitting(false);
                return;
            }
        }

        // Step 2: Prepare the data object
        const competitionData = {
            title: title.trim(),
            competitionType,
            description: description.trim(),
            rules: rules.trim(),
            prizesText: prizesText.trim(),
            flyerImageUrl: uploadedFlyerUrl,
            flyerUrl: flyerUrl.trim(),
            entryDeadline: entryDeadline ? new Date(entryDeadline) : null,
            competitionEnd: competitionEnd ? new Date(competitionEnd) : null,
            resultsDate: resultsDate ? new Date(resultsDate) : null,
        };

        // Step 3: Call the Cloud Function
        try {
            const createCompetitionFunction = httpsCallable(functions, 'createCompetition');
            const result = await createCompetitionFunction({ competitionData });
            showMessage(result.data.message);
            resetForm(); // Correctly reset the form on success
        } catch (error) {
            showMessage(`Error saving draft: ${error.message}`);
        } finally {
            setIsSubmitting(false);
        }
    };
    
    return (
        <div className="screenContainer">
            <p className="heading">Competition Manager</p>
            <p className="subHeading">Create and manage competitions for the NVA Network community.</p>

            <div className="dashboardSection">
                <p className="dashboardSectionTitle">Create New Competition</p>
                <form onSubmit={(e) => e.preventDefault()}>
                    <div className="formGroup">
                        <label className="formLabel">Competition Title</label>
                        <input type="text" className="formInput" value={title} onChange={e => setTitle(e.target.value)} placeholder="e.g., NVA Summer Photo Challenge" required />
                    </div>
                    <div className="formGroup">
                        <label className="formLabel">Competition Type</label>
                        <select className="formInput" value={competitionType} onChange={e => setCompetitionType(e.target.value)}>
                            <option value="Photo">Photo Submission</option>
                            <option value="Video">Video Submission</option>
                            <option value="External">External Link Submission</option>
                        </select>
                    </div>
                    <div className="formGroup">
                        <label className="formLabel">Description (Public)</label>
                        <textarea className="formTextarea" value={description} onChange={e => setDescription(e.target.value)} placeholder="A brief, exciting summary of the competition." />
                    </div>
                    <div className="formGroup">
                        <label className="formLabel">Official Rules & Requirements</label>
                        <textarea className="formTextarea" value={rules} onChange={e => setRules(e.target.value)} placeholder="Detail the rules, eligibility, and how to win." />
                    </div>
                     <div className="formGroup">
                        <label className="formLabel">Prizes (Simple Text)</label>
                        <textarea className="formTextarea" value={prizesText} onChange={e => setPrizesText(e.target.value)} placeholder="e.g., 1st Place: $500, 2nd Place: Gift Basket..." />
                        <p className="smallText" style={{textAlign: 'left', color: '#AAA', marginTop: '5px'}}>We will build the advanced prize manager with images later.</p>
                    </div>
                    <div className="formGroup">
                        <label className="formLabel">Promotional Flyer Image</label>
                        <input type="file" ref={flyerInputRef} onChange={(e) => { const f = e.target.files[0]; if (f) { setFlyerFile(f); setFlyerPreview(URL.createObjectURL(f)); } }} accept="image/*" className="formInput" />
                        {flyerPreview && <img src={flyerPreview} alt="Flyer Preview" style={{maxWidth: '300px', borderRadius: '8px', marginTop: '10px'}} />}
                    </div>
                    <div className="formGroup">
                        <label className="formLabel">Flyer Click-Through URL</label>
                        <input type="url" className="formInput" value={flyerUrl} onChange={e => setFlyerUrl(e.target.value)} placeholder="https://www.sponsor-site.com" />
                    </div>
                    <div className="formGroup">
                         <label className="formLabel">Entry Deadline</label>
                        <input type="datetime-local" className="formInput" value={entryDeadline} onChange={(e) => setEntryDeadline(e.target.value)} required />
                    </div>
                    <div className="formGroup">
                        <label className="formLabel">Competition End Date (Voting/Judging Ends)</label>
                        <input type="datetime-local" className="formInput" value={competitionEnd} onChange={(e) => setCompetitionEnd(e.target.value)} required />
                    </div>

                    <div className="formGroup">
                        <label className="formLabel">Results Announcement Date (Optional)</label>
                        <input type="datetime-local" className="formInput" value={resultsDate} onChange={(e) => setResultsDate(e.target.value)} />
                        <p className="smallText" style={{textAlign: 'left', color: '#AAA', marginTop: '5px'}}>Builds suspense by telling users when to check back for winners.</p>
                    </div>

                    <button type="button" className="button" onClick={handleSaveAsDraft} disabled={isSubmitting}>
                        <span className="buttonText">{isSubmitting ? 'Saving...' : 'Save as Draft'}</span>
                    </button>
                </form>
            </div>
            <div className="dashboardSection" style={{marginTop: '30px'}}>
        <p className="dashboardSectionTitle">Existing Competitions</p>
        {loadingComps ? (
            <p>Loading competitions...</p>
        ) : (
            <div className="dashboardContentList">
                {competitions.length === 0 ? <p className="dashboardItem">No competitions found.</p> :
                    competitions.map(comp => {
                        // --- START: NEW DELETE HANDLER LOGIC ---
                        const handleDelete = async (e) => {
                            e.stopPropagation(); // Prevent modal actions from bubbling up
                            try {
                                const deleteFunction = httpsCallable(functions, 'deleteCompetition');
                                await deleteFunction({ competitionId: comp.id });
                                showMessage("Competition deleted successfully. The list will update.");
                                // No need to close modal, it will be done in the onConfirm handler
                            } catch (error) {
                                showMessage(`Error: ${error.message}`);
                            }
                        };

                        const confirmDelete = (e) => {
                            e.stopPropagation(); // The CRITICAL FIX: stops the manage modal from opening
                            setShowConfirmationModal(true);
                            setConfirmationTitle("Permanently Delete Competition?");
                            setConfirmationMessage(`This will delete "${comp.title}", all entries, and all uploaded images. This is irreversible. Are you sure?`);
                            setOnConfirmationAction(() => () => handleDelete(e));
                        };
                        // --- END: NEW DELETE HANDLER LOGIC ---

                        return (
                            <div key={comp.id} className="adminDashboardItem">
                                <div style={{flexGrow: 1, cursor: 'pointer', height: '100%', display: 'flex', flexDirection: 'column', justifyContent: 'center'}} onClick={() => setManagingComp({...comp})}>
                                    <p className="adminDashboardItemTitle">{comp.title}</p>
                                    <p style={{fontSize: '12px', color: '#CCC'}}>Type: {comp.competitionType}</p>
                                </div>
                                <span className="adminDashboardItemStatus" style={{color: '#00FFFF', margin: '0 10px'}}>{comp.status}</span>
                                <button className="adminActionButton reject" onClick={confirmDelete}>Delete</button>
                                <button className="adminActionButton approve" style={{marginLeft: '10px'}} onClick={() => setManagingComp({...comp})}>Manage</button>
                            </div>
                        );
                    })
                }
            </div>
        )}
    {/* START of ADDITION */}
       {managingComp && (() => {
            // --- START: NEW VALIDATION LOGIC ---
            const now = new Date();
            const entryDeadlineDate = managingComp.entryDeadline ? new Date(managingComp.entryDeadline) : null;
            const competitionEndDate = managingComp.competitionEnd ? new Date(managingComp.competitionEnd) : null;

            const entryWarning = managingComp.status === 'Accepting Entries' && (!entryDeadlineDate || entryDeadlineDate < now);
            const votingWarning = managingComp.status === 'Live Voting' && (!competitionEndDate || competitionEndDate < now);
            // --- END: NEW VALIDATION LOGIC ---

            return (
                <div className="confirmationModalOverlay" style={{zIndex: 4000}}>
                    <div className="confirmationModalContent" style={{textAlign: 'left', maxWidth: '500px'}}>
                        <div style={{display: 'flex', justifyContent: 'space-between', alignItems: 'center'}}>
                            <p className="confirmationModalTitle">Manage: {managingComp.title}</p>
                            <button className="closeButton" onClick={() => setManagingComp(null)} style={{position: 'static'}}>×</button>
                        </div>
                        
                        <div className="formGroup">
                            <label className="formLabel">Update Notice Text</label>
                            <textarea className="formTextarea" defaultValue={managingComp.noticeText || ''} onChange={(e) => setManagingComp({...managingComp, noticeText: e.target.value})} placeholder="Post an update for all entrants to see..." />
                        </div>

                        <div className="formGroup">
                            <label className="formLabel">Entry Period Ends / Voting Begins</label>
                            <input type="datetime-local" className="formInput"
                                defaultValue={(() => {
                                    const d = managingComp.entryDeadline;
                                    if (!d) return '';
                                    const jsDate = d.toDate ? d.toDate() : new Date(d);
                                    const localDate = new Date(jsDate.getTime() - (new Date().getTimezoneOffset() * 60000));
                                    return localDate.toISOString().slice(0, 16);
                                })()}
                                onChange={(e) => setManagingComp({...managingComp, entryDeadline: e.target.value ? new Date(e.target.value) : null})}
                            />
                        </div>
                        <div className="formGroup">
                            <label className="formLabel">Voting Period Ends / Judging Begins</label>
                            <input type="datetime-local" className="formInput"
                               defaultValue={(() => {
                                    const d = managingComp.competitionEnd;
                                    if (!d) return '';
                                    const jsDate = d.toDate ? d.toDate() : new Date(d);
                                    const localDate = new Date(jsDate.getTime() - (new Date().getTimezoneOffset() * 60000));
                                    return localDate.toISOString().slice(0, 16);
                                })()}
                                onChange={(e) => setManagingComp({...managingComp, competitionEnd: e.target.value ? new Date(e.target.value) : null})}
                            />
                        </div>

                       <div className="formGroup">
                            <label className="formLabel">Reveal Results At (Optional)</label>
                            <input type="datetime-local" className="formInput"
                                defaultValue={(() => {
                                    const revealTime = managingComp.resultsRevealTime;
                                    if (!revealTime) return '';
                                    const jsDate = revealTime.toDate ? revealTime.toDate() : revealTime;
                                    const localDate = new Date(jsDate.getTime() - (new Date().getTimezoneOffset() * 60000));
                                    return localDate.toISOString().slice(0, 16);
                                })()}
                                onChange={(e) => setManagingComp({...managingComp, resultsRevealTime: e.target.value ? new Date(e.target.value) : null})}
                            />
                            <p className="smallText" style={{textAlign: 'left', color: '#AAA', marginTop: '5px'}}>If set, results will auto-publish at this time.</p>
                        </div>
                         <div className="formGroup">
                            <label className="formLabel">Change Status</label>
                            <select className="formInput" value={managingComp.status} onChange={(e) => setManagingComp({...managingComp, status: e.target.value})}>
                                <option value="Pending">Pending</option>
                                <option value="Accepting Entries">Accepting Entries (Go Live)</option>
                                <option value="Live Voting">Live Voting</option>
                                <option value="Judging">Judging (Results Soon)</option>
                                <option value="Completed">Completed (Keep Private)</option>
                                <option value="Results Visible">Results Visible (Make Public)</option>
                            </select>
                            {/* --- START: NEW WARNING MESSAGES --- */}
                            {entryWarning && <p className="smallText" style={{color: '#DC3545', marginTop: '5px'}}><b>Warning:</b> To automate this phase, please set a future "Entry Deadline".</p>}
                            {votingWarning && <p className="smallText" style={{color: '#DC3545', marginTop: '5px'}}><b>Warning:</b> To automate this phase, please set a future "Competition End Date".</p>}
                            {/* --- END: NEW WARNING MESSAGES --- */}
                         </div>

                         <div className="confirmationModalButtons" style={{flexDirection: 'column', gap: '10px', alignItems: 'stretch'}}>
                            <button 
                                className="confirmationButton confirm" 
                                onClick={async () => {
                                    const updates = { 
                                        status: managingComp.status, 
                                        noticeText: managingComp.noticeText || '',
                                        isPubliclyVisible: managingComp.isPubliclyVisible || false,
                                        resultsRevealTime: managingComp.resultsRevealTime ? new Date(managingComp.resultsRevealTime) : null,
                                        entryDeadline: managingComp.entryDeadline ? new Date(managingComp.entryDeadline) : null,
                                        competitionEnd: managingComp.competitionEnd ? new Date(managingComp.competitionEnd) : null,
                                    };
                                    const updateFunction = httpsCallable(functions, 'updateCompetition');
                                    try {
                                        await updateFunction({ competitionId: managingComp.id, updates });
                                        showMessage("Competition updated successfully!");
                                        setManagingComp(null);
                                    } catch (error) {
                                        showMessage(`Error: ${error.message}`);
                                    }
                                }}
                            >
                                Save Changes
                            </button>
                            <button 
                                className="confirmationButton" 
                                style={{backgroundColor: '#555', margin: 0}}
                                onClick={() => {
                                    setSelectedCompAdmin(managingComp);
                                    setActiveScreen('AdminCompetitionResults');
                                }}
                            >
                                View Entries / Results
                            </button>
                        </div>
                    </div>
                </div>
            );
        })()}
            </div>
        </div>
    );
};
// ======================================================================
// =========== END: ADD THIS ENTIRE NEW COMPONENT =======================
// ======================================================================


// ======================================================================
// ========= START: ADD THIS ENTIRE NEW COMPONENT =======================
// ======================================================================
const AdminCompetitionResults = ({ showMessage, setActiveScreen, selectedComp, setSelectedEntry, competition, currentUser }) => {
    const [entries, setEntries] = useState([]);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        if (!selectedComp) {
            setActiveScreen('AdminDashboard');
            return;
        }
        const entriesRef = collection(db, "competitions", selectedComp.id, "entries");
        const q = query(entriesRef, orderBy("createdAt", "desc")); // Keep original order for admin view initially

        const unsubscribe = onSnapshot(q, (snapshot) => {
            setEntries(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
            setLoading(false);
        });
        return () => unsubscribe();
    }, [selectedComp]);

    // Admin view always uses the weighted score for ranking
    const rankedEntries = useMemo(() => {
        return [...entries].sort((a, b) => {
            const scoreA = (a.likeCount || 0) * 5 + (a.viewCount || 0);
            const scoreB = (b.likeCount || 0) * 5 + (b.viewCount || 0);
            return scoreB - scoreA;
        });
    }, [entries]);

    if (loading) {
        return <div className="screenContainer"><p className="heading">Loading Results for {selectedComp.title}...</p></div>;
    }

    return (
        <div className="screenContainer">
            <div style={{ display: 'flex', alignItems: 'center', marginBottom: '10px' }}>
                <button 
                    onClick={() => setActiveScreen('AdminDashboard')} 
                    style={{ background: 'none', border: '1px solid #FFD700', color: '#FFD700', borderRadius: '50%', width: '40px', height: '40px', display: 'flex', alignItems: 'center', justifyContent: 'center', cursor: 'pointer', marginRight: '15px' }}
                >
                    &#x2190;
                </button>
                <p className="heading" style={{ margin: 0, textAlign: 'center', flexGrow: 1 }}>Results: {selectedComp.title}</p>
                <div style={{ width: '40px' }}></div>
            </div>
            <p className="subHeading">Ranked view of all entries. Click an entry to view details.</p>

            <div className="allCampaignsList">
                {rankedEntries.length === 0 ? <p className="dashboardItem">No entries were submitted for this competition.</p> :
                    rankedEntries.map((entry, index) => (
                        <div 
                            key={entry.id} 
                            className="allCampaignsListItem" 
                            style={{borderLeft: '5px solid #00FFFF', position: 'relative', cursor: 'pointer'}}
                            onClick={() => setSelectedEntry(entry)} // This will open the viewer modal
                        >
                            <div style={{position: 'absolute', top: '-1px', left: '-1px', backgroundColor: '#00FFFF', color: '#0A0A0A', padding: '5px 10px', borderTopLeftRadius: '8px', borderBottomRightRadius: '8px', fontWeight: 'bold'}}>
                                #{index + 1}
                            </div>
                             <img src={entry.photoUrl || entry.userProfilePicture} alt={entry.title} className="creator-campaign-thumbnail" style={{width: '120px', height: '70px', objectFit: 'cover'}}/>
                            <div className="campaignListContent">
                                <p className="campaignListTitle" style={{color: '#FFF'}}>{entry.title}</p>
                                <div className="campaignListCreator">
                                    <img src={entry.userProfilePicture || 'https://placehold.co/24x24/555/FFF?text=P'} alt={entry.userName} className="campaignListCreatorProfilePic"/>
                                    <span>by {entry.userName}</span>
                                </div>
                                <div className="campaignListStats">
                                    <span>Score: <span className="campaignListRaised" style={{color: '#00FFFF'}}>{(entry.likeCount || 0) * 5 + (entry.viewCount || 0)}</span></span>
                                    <span>Likes: <span className="campaignListGoal">{entry.likeCount || 0}</span></span>
                                    {selectedComp.competitionType === 'Video' && (
                                         <span>Views: <span className="campaignListRaised">{entry.viewCount || 0}</span></span>
                                    )}
                                </div>
                            </div>
                        </div>
                    ))
                }
            </div>
        </div>
    );
};
// ======================================================================
// =========== END: ADD THIS ENTIRE NEW COMPONENT =======================
// ======================================================================


// ======================================================================
// ============ START: ADD THIS ENTIRE NEW COMPONENT BLOCK =============
// ======================================================================

const ConfirmationModal = ({ title, message, onConfirm, onCancel }) => {
    const handleConfirm = () => {
        onConfirm(); // Execute the action passed in
        onCancel();  // Close the modal
    };

    return (
        <div className="confirmationModalOverlay">
            <div className="confirmationModalContent">
                <p className="confirmationModalTitle">{title}</p>
                <p className="confirmationModalMessage">{message}</p>
                <div className="confirmationModalButtons">
                    <button className="confirmationButton cancel" onClick={onCancel}>
                        Cancel
                    </button>
                    <button className="confirmationButton confirm" onClick={handleConfirm}>
                        Confirm
                    </button>
                </div>
            </div>
        </div>
    );
};

// ======================================================================
// ============== END: ADD THIS ENTIRE NEW COMPONENT BLOCK ==============
// ======================================================================


                // ======================================================================
// ========= START: PASTE THIS ENTIRE NEW BLOCK OF THREE COMPONENTS =========
// ======================================================================

        const OpportunityDetailsScreen = ({ showMessage, setActiveScreen, selectedOpportunity }) => {
            if (!selectedOpportunity) { return <div className="screenContainer"><p className="heading">Loading Opportunity...</p></div>; }
            return (
                <div className="screenContainer">
                    {selectedOpportunity.flyerImageUrl && <img src={selectedOpportunity.flyerImageUrl} alt="Opportunity Flyer" style={{width: '100%', borderRadius: '10px', marginBottom: '20px'}} />}
                    <p className="heading">{selectedOpportunity.title}</p>
                    <p className="subHeading">Posted by {selectedOpportunity.providerName}</p>
                    <div className="dashboardSection"><div className="campaignListStats" style={{flexDirection: 'column', alignItems: 'flex-start', gap: '10px'}}>
                        <p><strong>Type:</strong> <span className="campaignListGoal">{selectedOpportunity.opportunityType}</span></p>
                        <p><strong>Location:</strong> <span className="campaignListGoal">{selectedOpportunity.location}</span></p>
                        <p><strong>Compensation:</strong> <span className="campaignListGoal">{selectedOpportunity.compensationType}</span></p>
                        <p><strong>Equipment:</strong> <span className="campaignListGoal">{selectedOpportunity.equipmentProvided}</span></p>
                        <p><strong>Apply By:</strong> <span className="campaignListGoal">{new Date(selectedOpportunity.expiresAt.toDate()).toLocaleDateString()}</span></p>
                    </div></div>
                    <div className="dashboardSection"><p className="dashboardSectionTitle">Description</p><p className="paragraph" style={{whiteSpace: 'pre-wrap'}}>{selectedOpportunity.description}</p></div>
                    <div className="dashboardSection" style={{border: '1px solid #FFD700'}}><p className="dashboardSectionTitle">How to Apply</p><p className="paragraph" style={{whiteSpace: 'pre-wrap'}}>{selectedOpportunity.howToApply}</p></div>
                    <div style={{ display: 'flex', justifyContent: 'center', gap: '10px', flexWrap: 'wrap', marginTop: '20px' }}>
                        {/* START: ADDED COMMENT BUTTON */}
                        <button
                            className="button"
                            onClick={() => window.dispatchEvent(new CustomEvent('openCommentsModal', { detail: { item: selectedOpportunity, itemType: 'opportunity' } }))}
                            style={{ backgroundColor: '#FFD700', margin: 0 }}
                        >
                            <span className="buttonText">View Comments</span>
                        </button>
                        {/* END: ADDED COMMENT BUTTON */}

                        <button className="button" onClick={() => setActiveScreen('CreatorConnect')} style={{backgroundColor: '#3A3A3A', margin: 0}}>
                            <span className="buttonText light">Back to All Opportunities</span>
                        </button>
                    </div>
                </div>
            );
        };
        
        const CreatorConnectScreen = ({ showMessage, setActiveScreen, currentUser, creatorProfile, setSelectedOpportunity, setShowConfirmationModal, setConfirmationTitle, setConfirmationMessage, setOnConfirmationAction }) => {
    const [promotedOpportunities, setPromotedOpportunities] = useState([]);
    const [standardOpportunities, setStandardOpportunities] = useState([]);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        // THIS IS THE SECURITY CHECK. If no user, redirect immediately.
        if (!currentUser) {
            showMessage("You must be logged in to view listings.");
            setActiveScreen('Login');
            return; // Stop the hook from running further
        }

        setLoading(true);
        const opportunitiesRef = collection(db, "opportunities");
        
        const qPromoted = query(opportunitiesRef, where("status", "==", "active"), where("listingTier", "==", "promoted"), orderBy("createdAt", "desc"));
        const unsubPromoted = onSnapshot(qPromoted, (snapshot) => {
            setPromotedOpportunities(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
        });

        const qStandard = query(opportunitiesRef, where("status", "==", "active"), where("listingTier", "==", "standard"), orderBy("createdAt", "desc"));
        const unsubStandard = onSnapshot(qStandard, (snapshot) => {
            setStandardOpportunities(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
            setLoading(false);
        });

        return () => {
            unsubPromoted();
            unsubStandard();
        };
    }, [currentUser]); // The hook correctly depends on the user's state.

    const handlePostClick = async () => {
        // Since the useEffect handles the main login check, we can focus on posting permissions here.
        const isVerified = creatorProfile?.isVerifiedAdvertiser && creatorProfile.verifiedAdvertiserExpiresAt && creatorProfile.verifiedAdvertiserExpiresAt.toDate() > new Date();
        const isPremium = creatorProfile?.premiumExpiresAt && creatorProfile.premiumExpiresAt.toDate() > new Date();

        if (isPremium || isVerified) {
            setActiveScreen('PostOpportunityForm');
            return;
        }
        
        // If they are logged in but NOT authorized, show the upsell modal.
        setConfirmationTitle("Premium Feature");
        setConfirmationMessage("Posting to Creator Connect is a Premium feature. Upgrade your account to post your opportunities.");
        setOnConfirmationAction(() => () => setActiveScreen('Premium'));
        setShowConfirmationModal(true);
    };
    
    const interleavedOpportunities = [];
    if (!loading) {
        const promotedCopy = [...promotedOpportunities];
        const standardCopy = [...standardOpportunities];
        while (promotedCopy.length > 0 || standardCopy.length > 0) {
            interleavedOpportunities.push(...promotedCopy.splice(0, 3));
            interleavedOpportunities.push(...standardCopy.splice(0, 10));
        }
    }

    // This prevents a brief flash of content before the redirect happens.
    if (!currentUser) {
        return <div className="screenContainer"><p className="heading">Redirecting...</p></div>;
    }

    return (
        <div className="screenContainer">
            <div className="sectionHeaderWithButton">
                <p className="heading" style={{margin: 0, textAlign: 'left'}}>Creator Connect</p>
                {/* The button is now always present, but its action is secured */}
                <button className="button" onClick={handlePostClick} style={{margin: 0}}><span className="buttonText">Post an Opportunity</span></button>
            </div>
            <p className="subHeading" style={{textAlign: 'left', marginBottom: '20px'}}>Welcome to the Hub! Premium members can post one active listing at a time. All posts are subject to review.</p>
            {loading ? <p>Loading opportunities...</p> : (
                <div className="allCampaignsList">
                    {interleavedOpportunities.length === 0 ? <p className="dashboardItem">No active opportunities at the moment. Check back soon!</p> :
                        interleavedOpportunities.map(opp => (
                            <div key={opp.id} 
                                className="allCampaignsListItem" 
                                style={opp.listingTier === 'promoted' ? {border: '2px solid #FFD700', background: 'rgba(255, 215, 0, 0.05)'} : {}} 
                                onClick={() => { setSelectedOpportunity(opp); setActiveScreen('OpportunityDetails'); }}>
                                <div className="campaignListContent">
                                    <div className="campaignListTitle" style={{display: 'flex', justifyContent: 'space-between', alignItems: 'center'}}>
                                        <span>{opp.title}</span> 
                                        <div style={{display: 'flex', alignItems: 'center', gap: '10px'}}>
                                            {opp.listingTier === 'promoted' && <span style={{fontSize: '12px', color: '#0A0A0A', backgroundColor: '#FFD700', padding: '3px 8px', borderRadius: '10px', fontWeight: 'bold'}}>★ Promoted</span>}
                                            <SaveOpportunityButton currentUser={currentUser} opportunityId={opp.id} showMessage={showMessage} />
                                        </div>
                                    </div>
                                    <p className="campaignListCreator" style={{marginBottom: '10px'}}>by {opp.providerName}</p>
                                    <div className="campaignListStats"><span><span className="campaignListGoal">{opp.location}</span></span><span><span className="campaignListRaised">{opp.compensationType}</span></span></div>
                                </div>
                            </div>
                        ))
                    }
                </div>
            )}
        </div>
    );
};


        // =================== START: FULL COMPONENT REPLACEMENT ===================
      const PostOpportunityForm = ({ showMessage, setActiveScreen, currentUser, creatorProfile, setOpportunityToPromote }) => {
    const [title, setTitle] = useState('');
    const [providerName, setProviderName] = useState(creatorProfile?.creatorName || '');
    const [mainUrl, setMainUrl] = useState('');
    const [opportunityType, setOpportunityType] = useState('Casting Call');
    const [compensationType, setCompensationType] = useState('Paid');
    const [equipmentProvided, setEquipmentProvided] = useState('Not Applicable');
    const [location, setLocation] = useState('');
    const [description, setDescription] = useState('');
    const [howToApply, setHowToApply] = useState('');
    const [listingDuration, setListingDuration] = useState(7);
    const [isSubmitting, setIsSubmitting] = useState(false);
    
    const [flyerFile, setFlyerFile] = useState(null);
    const [flyerPreview, setFlyerPreview] = useState('');
    const [isPromotedInFeed, setIsPromotedInFeed] = useState(false);

    const [showImageAdjustModal, setShowImageAdjustModal] = useState(false);
    const [imageFileToAdjust, setImageFileToAdjust] = useState(null);
    const flyerInputRef = useRef(null);

    // THIS IS THE NEW TIME-AWARE LOGIC
    const isVerified = creatorProfile?.isVerifiedAdvertiser && creatorProfile.verifiedAdvertiserExpiresAt && creatorProfile.verifiedAdvertiserExpiresAt.toDate() > new Date();

    const handleFileSelect = (e) => {
        const file = e.target.files[0];
        if (file) {
            setImageFileToAdjust(file);
            setShowImageAdjustModal(true);
        }
    };
    const handleSaveAdjustedImage = (adjustedBlob) => {
        const newFile = new File([adjustedBlob], "flyer.png", { type: "image/png" });
        setFlyerFile(newFile);
        setFlyerPreview(URL.createObjectURL(newFile));
        setShowImageAdjustModal(false);
    };
    const handleCancelAdjust = () => {
        setImageFileToAdjust(null);
        setShowImageAdjustModal(false);
        if (flyerInputRef.current) flyerInputRef.current.value = null;
    };

    const opportunityCategories = ['Casting Call', 'Film & Video Crew', 'Modeling', 'Events & Production Staff', 'Design & Creative', 'Music & Audio', 'Collaboration / TFP', 'Other'];
    const equipmentRelevantCategories = ['Film & Video Crew', 'Music & Audio', 'Design & Creative'];

    const handleSubmit = async (e) => {
        e.preventDefault();
        setIsSubmitting(true);

        if (!flyerFile) {
            showMessage("A flyer or thumbnail image is required to post an opportunity.");
            setIsSubmitting(false);
            return;
        }

        let flyerImageUrl = '';

        showMessage("Uploading flyer...");
        try {
            const path = `opportunity_flyers/${currentUser.uid}/${Date.now()}.png`;
            const storageRef = ref(storage, path);
            const snapshot = await uploadBytes(storageRef, flyerFile);
            flyerImageUrl = await getDownloadURL(snapshot.ref);
        } catch (error) { 
            showMessage(`Flyer upload failed: ${error.message}`); 
            setIsSubmitting(false); 
            return; 
        }

        try {
            const createOpportunityFunction = httpsCallable(functions, 'createOpportunity');
            const result = await createOpportunityFunction({
                title, providerName, 
                mainUrl: isVerified ? mainUrl : '', // THIS IS THE FIX
                opportunityType, compensationType, equipmentProvided, location, description, howToApply,
                listingDuration: parseInt(listingDuration), 
                flyerImageUrl: flyerImageUrl,
                listingTier: isPromotedInFeed && isVerified ? 'promoted' : 'standard' // THIS IS THE FIX
            });

            if (result.data.success && result.data.opportunityId) {
                if (isVerified) { // THIS IS THE FIX
                    setOpportunityToPromote(result.data.opportunityId);
                    setActiveScreen('PostSubmissionUpsell');
                } else {
                    showMessage("Your opportunity has been submitted for review.");
                    setActiveScreen('MyListings');
                }
            } else {
                throw new Error("Failed to get new opportunity ID from server.");
            }
        } catch (error) {
            showMessage(`Error: ${error.message}`);
        } finally {
            setIsSubmitting(false);
        }
    };

    return (
        <div className="screenContainer">
            <p className="heading">Post an Opportunity</p>
            <p className="subHeading">Your listing will be submitted for review before going live in Creator Connect.</p>
            <form onSubmit={handleSubmit}>
                <div className="formGroup"><label className="formLabel">Listing Title</label><input type="text" className="formInput" value={title} onChange={e => setTitle(e.target.value)} required /></div>
                <div className="formGroup"><label className="formLabel">Your Company/Provider Name</label><input type="text" className="formInput" value={providerName} onChange={e => setProviderName(e.target.value)} required /></div>
                
                {/* THIS IS THE FIX */}
                {isVerified && (
                    <div className="formGroup">
                        <label className="formLabel">Project URL (Optional, Advertiser Only)</label>
                        <input type="url" className="formInput" value={mainUrl} onChange={e => setMainUrl(e.target.value)} placeholder="e.g., YouTube video, project page" />
                        <p className="smallText" style={{textAlign: 'left', color: '#AAA', marginTop: '5px'}}>Link to a video or website related to your opportunity.</p>
                    </div>
                )}

                <div className="formGroup"><label className="formLabel">Location</label><input type="text" className="formInput" value={location} onChange={e => setLocation(e.target.value)} placeholder="e.g., Georgetown, Remote" required /></div>
                <div className="formGroup"><label className="formLabel">Opportunity Type</label><select className="formInput" value={opportunityType} onChange={e => setOpportunityType(e.target.value)}>{opportunityCategories.map(c => <option key={c} value={c}>{c}</option>)}</select></div>
                <div className="formGroup"><label className="formLabel">Compensation</label><select className="formInput" value={compensationType} onChange={e => setCompensationType(e.target.value)}><option value="Paid">Paid</option><option value="Volunteer">Volunteer</option><option value="Stipend">Stipend</option><option value="Collaboration/TFP">Collaboration/TFP</option></select></div>
                {equipmentRelevantCategories.includes(opportunityType) && (<div className="formGroup"><label className="formLabel">Equipment</label><select className="formInput" value={equipmentProvided} onChange={e => setEquipmentProvided(e.target.value)}><option value="Provided">Equipment will be provided</option><option value="Owner/Operator Required">Applicant must bring their own</option></select></div>)}
                <div className="formGroup"><label className="formLabel">Listing Duration</label><select className="formInput" value={listingDuration} onChange={e => setListingDuration(e.target.value)}><option value="7">1 Week</option><option value="14">2 Weeks</option><option value="21">3 Weeks</option><option value="30">30 Days</option></select></div>

                {/* THIS IS THE FIX */}
                {isVerified && (
                    <div className="formGroup" style={{border: '1px solid #FFD700', borderRadius: '8px', padding: '15px', backgroundColor: '#1A1A1A'}}>
                        <div className="checkboxItem">
                            <input type="checkbox" id="isPromotedInFeed" checked={isPromotedInFeed} onChange={(e) => setIsPromotedInFeed(e.target.checked)} />
                            <label htmlFor="isPromotedInFeed" style={{fontWeight: 'bold', color: '#FFD700'}}>Promote this listing within the feed</label>
                        </div>
                        <p className="smallText" style={{textAlign: 'left', color: '#AAA'}}>Promoted listings get a gold border and appear higher in the Creator Connect feed.</p>
                    </div>
                )}

                <div className="formGroup"><label className="formLabel">Detailed Description</label><textarea className="formTextarea" value={description} onChange={e => setDescription(e.target.value)} required></textarea></div>
                <div className="formGroup"><label className="formLabel">How to Apply</label><textarea className="formTextarea" value={howToApply} onChange={e => setHowToApply(e.target.value)} required></textarea></div>
                
                <div className="formGroup">
                    <label className="formLabel">Upload Flyer/Thumbnail (Required)</label>
                    <input type="file" ref={flyerInputRef} onChange={handleFileSelect} accept="image/*" style={{display: 'none'}} />
                    <button type="button" className="button" onClick={() => flyerInputRef.current.click()} style={{ width: '100%', backgroundColor: '#3A3A3A' }}><span className="buttonText light">Upload Custom Image</span></button>
                    {flyerPreview && <img src={flyerPreview} alt="Flyer preview" style={{maxWidth: '200px', borderRadius: '8px', marginTop: '10px'}} />}
                </div>

                <button type="submit" className="button" disabled={isSubmitting}><span className="buttonText">{isSubmitting ? 'Submitting...' : 'Submit for Review'}</span></button>
            </form>
            {showImageAdjustModal && imageFileToAdjust && (
                <ProfilePictureAdjustModal
                    imageUrl={URL.createObjectURL(imageFileToAdjust)}
                    onSave={handleSaveAdjustedImage}
                    onCancel={handleCancelAdjust}
                    showMessage={showMessage}
                    isUploading={isSubmitting}
                />
            )}
        </div>
    );
};

// ======================================================================
// ========= END: PASTE THIS ENTIRE NEW BLOCK OF THREE COMPONENTS =========
// ======================================================================
                
            // ======================================================================
// ========= START: PASTE THE TWO CUT COMPONENTS HERE ===================
// ======================================================================

        const SavedOpportunitiesScreen = ({ showMessage, setActiveScreen, currentUser, setSelectedOpportunity }) => {
            const [savedOpportunities, setSavedOpportunities] = useState([]);
            const [loading, setLoading] = useState(true);

            useEffect(() => {
                if (!currentUser) {
                    setActiveScreen('Login');
                    return;
                }
                const savedRef = collection(db, "creators", currentUser.uid, "savedOpportunities");
                const unsubscribe = onSnapshot(savedRef, async (snapshot) => {
                    const savedIds = snapshot.docs.map(doc => doc.id);
                    if (savedIds.length > 0) {
                        const oppsRef = collection(db, "opportunities");
                        // We also need to add a listener to the opportunities themselves,
                        // so if a listing is deleted, it disappears from the saved list.
                        const q = query(oppsRef, where("__name__", "in", savedIds));
                        const unsubOpps = onSnapshot(q, (oppsSnapshot) => {
                             setSavedOpportunities(oppsSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
                             setLoading(false);
                        });
                        return () => unsubOpps(); // Return the inner unsubscribe
                    } else {
                        setSavedOpportunities([]);
                        setLoading(false);
                    }
                });
                return () => unsubscribe();
            }, [currentUser]);

            return (
                <div className="screenContainer">
                    <p className="heading">My Saved Opportunities</p>
                    <p className="subHeading">All the listings you've bookmarked. They will be removed from this list if they expire or are deleted.</p>
                    {loading ? <p>Loading saved listings...</p> : (
                        <div className="allCampaignsList">
                            {savedOpportunities.length === 0 ? <p className="dashboardItem">You have not saved any opportunities yet.</p> :
                                savedOpportunities.map(opp => (
                                    <div key={opp.id} className="allCampaignsListItem" >
                                        {/* Main content area is clickable to see details */}
                                        <div style={{flexGrow: 1}} onClick={() => { setSelectedOpportunity(opp); setActiveScreen('OpportunityDetails'); }}>
                                            <p className="campaignListTitle">{opp.title}</p>
                                            <p className="campaignListCreator">by {opp.providerName}</p>
                                        </div>
                                        {/* THIS IS THE FIX #2: The save/unsave button is now here */}
                                        <SaveOpportunityButton currentUser={currentUser} opportunityId={opp.id} showMessage={showMessage} />
                                    </div>
                                ))
                            }
                        </div>
                    )}
                    {/* THIS IS THE FIX #1: The button now correctly goes back to the Dashboard */}
                    <button className="button" onClick={() => setActiveScreen('CreatorDashboard')} style={{ backgroundColor: '#3A3A3A', marginTop: '30' }}>
                        <span className="buttonText light">Back to Dashboard</span>
                    </button>
                </div>
            );
        };

        const SaveOpportunityButton = ({ currentUser, opportunityId, showMessage }) => {
            const [isSaved, setIsSaved] = useState(false);
            const [isLoading, setIsLoading] = useState(true);

            useEffect(() => {
                if (!currentUser) { setIsLoading(false); return; }
                const savedDocRef = doc(db, "creators", currentUser.uid, "savedOpportunities", opportunityId);
                const unsubscribe = onSnapshot(savedDocRef, (docSnap) => {
                    setIsSaved(docSnap.exists());
                    setIsLoading(false);
                });
                return () => unsubscribe();
            }, [currentUser, opportunityId]);

            const handleToggleSave = async (e) => {
                e.stopPropagation();
                if (!currentUser || isLoading) return;
                setIsLoading(true);
                const savedDocRef = doc(db, "creators", currentUser.uid, "savedOpportunities", opportunityId);
                try {
                    if (isSaved) {
                        await deleteDoc(savedDocRef);
                        // THIS IS THE FIX: Show a message on success
                        if (showMessage) showMessage("Opportunity removed from Saved.");
                    } else {
                        await setDoc(savedDocRef, { savedAt: new Date() });
                        // THIS IS THE FIX: Show a message on success
                        if (showMessage) showMessage("Opportunity Saved!");
                    }
                } catch (error) {
                    console.error("Error toggling saved opportunity:", error);
                    if (showMessage) showMessage("An error occurred.");
                } finally {
                    setIsLoading(false);
                }
            };
            
            const bookmarkIconPath = "M17 3H7c-1.1 0-2 .9-2 2v16l7-3 7 3V5c0-1.1-.9-2-2-2z";

            return (
                <button 
                    onClick={handleToggleSave} 
                    disabled={isLoading} 
                    style={{ background: 'none', border: 'none', cursor: 'pointer', padding: '5px' }}
                    title={isSaved ? "Unsave this opportunity" : "Save this opportunity"}
                >
                    <svg viewBox="0 0 24 24" style={{ width: '24px', height: '24px', fill: isSaved ? '#FFD700' : '#FFF', opacity: isLoading ? 0.5 : 1 }}>
                        <path d={bookmarkIconPath}></path>
                    </svg>
                </button>
            );
        };

// ======================================================================
// ========== END: PASTE THE TWO CUT COMPONENTS HERE ====================
// ======================================================================

                // ======================================================================
// ========= START: ADD THE NEW PromotedStatusScreen COMPONENT ==============
// ======================================================================

        const PromotedStatusScreen = ({ showMessage, setActiveScreen, currentUser, creatorProfile, setShowConfirmationModal, setConfirmationTitle, setConfirmationMessage, setOnConfirmationAction }) => {
    const [myBookings, setMyBookings] = useState([]);
    const [loading, setLoading] = useState(true);
    const [selectedBooking, setSelectedBooking] = useState(null);

    const [title, setTitle] = useState('');
    const [mainUrl, setMainUrl] = useState('');
    const [flyerFile, setFlyerFile] = useState(null);
    const [flyerPreview, setFlyerPreview] = useState('');
    const [autoThumbnail, setAutoThumbnail] = useState('');
    const [isSubmitting, setIsSubmitting] = useState(false);
    const flyerInputRef = useRef(null);

    useEffect(() => {
        if (!currentUser) { setLoading(false); return; }
        const statusesRef = collection(db, "promotedStatuses");
        const q = query(statusesRef, where("postedByUid", "==", currentUser.uid), orderBy("startTime", "asc"));
        const unsubscribe = onSnapshot(q, (snapshot) => {
            setMyBookings(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
            setLoading(false);
        });
        return () => unsubscribe();
    }, [currentUser]);
    
    useEffect(() => {
        if (!mainUrl) { setAutoThumbnail(''); return; }
        const handler = setTimeout(async () => {
            const info = extractVideoInfo(mainUrl);
            if (info.platform === 'youtube') {
                setAutoThumbnail(info.thumbnailUrl);
            } else if (info.platform === 'tiktok' || info.platform === 'vimeo') {
                try {
                    const oEmbedProxyCallable = httpsCallable(functions, 'oEmbedProxy');
                    const result = await oEmbedProxyCallable({ url: mainUrl, platform: info.platform });
                    if (result.data?.thumbnail_url) setAutoThumbnail(result.data.thumbnail_url);
                } catch (error) { showMessage("Could not auto-fetch thumbnail."); }
            }
        }, 800);
        return () => clearTimeout(handler);
    }, [mainUrl]);

    const handleSelectBooking = (booking) => {
        setSelectedBooking(booking);
        setTitle(booking.content?.title || '');
        setMainUrl(booking.content?.destinationUrl || booking.content?.adVideoUrl || '');
        setFlyerFile(null);
        setFlyerPreview(booking.content?.flyerImageUrl || '');
        setAutoThumbnail('');
        if(flyerInputRef.current) flyerInputRef.current.value = null;
    };
    
    const handleSubmitContent = async (e) => {
        e.preventDefault();
        if (!selectedBooking || !title.trim() || !mainUrl.trim()) { showMessage("Ad Title and a URL are required."); return; }
        
        setIsSubmitting(true);
        let finalFlyerUrl = flyerPreview || autoThumbnail || '';

        if (flyerFile) {
            showMessage("Uploading flyer...");
            try {
                const filePath = `promo_flyers/${currentUser.uid}/${Date.now()}_${flyerFile.name}`;
                const storageRef = ref(storage, filePath);
                const snapshot = await uploadBytes(storageRef, flyerFile);
                finalFlyerUrl = await getDownloadURL(snapshot.ref);
            } catch (error) { showMessage(`Flyer upload failed: ${error.message}`); setIsSubmitting(false); return; }
        }

        if (!finalFlyerUrl) {
            showMessage("A thumbnail is required. Please upload one or use a link that provides a preview.");
            setIsSubmitting(false);
            return;
        }

        const info = extractVideoInfo(mainUrl);
        const submissionData = {
            bookingId: selectedBooking.id,
            title: title.trim(),
            destinationUrl: info.platform === 'generic' ? mainUrl : '',
            adVideoUrl: info.platform !== 'generic' ? mainUrl : '',
            flyerImageUrl: finalFlyerUrl
        };

        try {
            const submitContentFunction = httpsCallable(functions, 'submitStatusContent');
            await submitContentFunction(submissionData);
            showMessage("Content submitted successfully for review!");
            setSelectedBooking(null);
        } catch (error) { showMessage(`Submission failed: ${error.message}`);
        } finally { setIsSubmitting(false); }
    };

    const handleDeleteBooking = (booking) => {
        setConfirmationTitle("Delete Booking?");
        setConfirmationMessage(`Are you sure you want to permanently delete your booking for ${new Date(booking.startTime.toDate()).toLocaleDateString()}? This action cannot be undone.`);
        setOnConfirmationAction(() => async () => {
            try {
                const deleteFunction = httpsCallable(functions, 'deleteBooking');
                await deleteFunction({ bookingId: booking.id });
                showMessage("Booking deleted successfully.");
            } catch (error) {
                showMessage(`Error: ${error.message}`);
            }
        });
        setShowConfirmationModal(true);
    };
    
    const getStatusStyle = (status) => {
        switch (status) {
            case 'approved_and_scheduled': return { color: '#00FF00' };
            case 'content_review_pending': return { color: '#FFD700' };
            case 'content_pending': return { color: '#FFA500' };
            case 'expired': return { color: '#888' };
            case 'cancelled': return { color: '#AAA' };
            case 'rejected': return { color: '#DC3545' };
            default: return { color: '#CCC' };
        }
    };
    
    const finalPreview = flyerPreview || autoThumbnail;

    return (
        <div className="screenContainer">
            <p className="heading">My Promoted Status Bookings</p>
            <p className="subHeading">Manage content for your upcoming "Billboard" slots.</p>

            {loading ? <p>Loading your bookings...</p> : 
                myBookings.length === 0 ? (
                    <div className="dashboardSection" style={{textAlign: 'center'}}>
                        <p className="dashboardItem">You have no upcoming bookings.</p>
                        <button className="button" style={{ backgroundColor: '#0A0A0A', border: '1px solid #00FFFF', color: '#00FFFF' }} onClick={() => setActiveScreen('Premium')}>Book a New Slot</button>
                    </div>
                ) : (
                    <div className="dashboardContentList">
                        {myBookings.map(booking => {
                            const isOldBooking = booking.status === 'expired' || booking.status === 'cancelled';
                            let deletionDate = null;
                            if (isOldBooking) {
                                deletionDate = new Date(booking.startTime.toDate());
                                deletionDate.setDate(deletionDate.getDate() + 30);
                            }
                            return (
                                <div key={booking.id} className="adminDashboardItem" style={{flexDirection: 'column', alignItems: 'stretch'}}>
                                    <div className="flex justify-between items-center">
                                        <p className="adminDashboardItemTitle">Booking for: {new Date(booking.startTime.toDate()).toLocaleDateString()}</p>
                                        <span style={getStatusStyle(booking.status)}>{booking.status.replace(/_/g, ' ').toUpperCase()}</span>
                                    </div>
                                    <div style={{display: 'flex', gap: '10px', marginTop: '10px'}}>
                                        {booking.status === 'content_pending' && (
                                            <button className="button" style={{flex: 1}} onClick={() => handleSelectBooking(booking)}>
                                                <span className="buttonText">Submit Content Now</span>
                                            </button>
                                        )}
                                        {booking.status !== 'expired' && booking.status !== 'cancelled' && booking.status !== 'rejected' && (
                                            <button className="button" style={{flex: 1, backgroundColor: '#DC3545'}} onClick={() => handleDeleteBooking(booking)}>
                                                <span className="buttonText">Delete</span>
                                            </button>
                                        )}
                                    </div>
                                    {isOldBooking && (
                                        <p className="smallText" style={{textAlign: 'right', color: '#AAA', marginTop: '8px', marginBottom: 0}}>
                                            This record will be deleted on {deletionDate.toLocaleDateString()}.
                                        </p>
                                    )}
                                </div>
                            );
                        })}
                    </div>
                )
            }

            {selectedBooking && (
                <div className="confirmationModalOverlay" style={{zIndex: 2500}}>
                    <div className="confirmationModalContent" style={{textAlign: 'left', maxWidth: '500px'}}>
                        <p className="confirmationModalTitle">Submit Content for {new Date(selectedBooking.startTime.toDate()).toLocaleDateString()}</p>
                        <form onSubmit={handleSubmitContent}>
                            <div className="formGroup"><label className="formLabel">Ad Title</label><input type="text" className="formInput" value={title} onChange={e => setTitle(e.target.value)} required /></div>
                            <div className="formGroup"><label className="formLabel">URL (Video or External Link)</label><input type="url" className="formInput" value={mainUrl} onChange={e => setMainUrl(e.target.value)} placeholder="Paste your ad's main link here" required /></div>
                            <div className="formGroup">
                                <label className="formLabel">Thumbnail / Flyer</label>
                                {finalPreview && <img src={finalPreview} alt="Ad preview" style={{maxWidth: '200px', borderRadius: '8px', marginBottom: '10px'}} />}
                                <input type="file" className="formInput" ref={flyerInputRef} onChange={(e) => {const f=e.target.files[0]; if(f){setFlyerFile(f); setFlyerPreview(URL.createObjectURL(f))}}} accept="image/*" />
                                <p className="smallText" style={{textAlign: 'left'}}>Upload to override the auto-fetched preview.</p>
                            </div>
                            <div className="confirmationModalButtons">
                                <button type="button" className="confirmationButton cancel" onClick={() => setSelectedBooking(null)}>Cancel</button>
                                <button type="submit" className="confirmationButton confirm" disabled={isSubmitting}>{isSubmitting ? 'Submitting...' : 'Submit for Review'}</button>
                            </div>
                        </form>
                    </div>
                </div>
            )}

            <button className="button" onClick={() => setActiveScreen('CreatorDashboard')} style={{ backgroundColor: '#3A3A3A', marginTop: '30px' }}>
                <span className="buttonText light">Back to Dashboard</span>
            </button>
        </div>
    );
};

// ======================================================================
// ========== END: ADD THE NEW PromotedStatusScreen COMPONENT =============
// ======================================================================

            

        // ======================================================================
// =========== START: ADD THE NEW BookStatusScreen COMPONENT ==============
// ======================================================================

     const BookStatusScreen = ({ showMessage, setActiveScreen, setPledgeIdForConfirmation, currentUser, creatorProfile, selectedCurrency, currencyRates, opportunityToPromote, setOpportunityToPromote }) => {
    const [nextSlot, setNextSlot] = useState(null);
    const [bookingPrice, setBookingPrice] = useState(10.00);
    const [loading, setLoading] = useState(true);
    const [isSubmitting, setIsSubmitting] = useState(false);

    const [title, setTitle] = useState('');
    const [mainUrl, setMainUrl] = useState('');
    const [flyerFile, setFlyerFile] = useState(null);
    const [flyerPreview, setFlyerPreview] = useState('');
    const [autoThumbnail, setAutoThumbnail] = useState('');
    
    const [showImageAdjustModal, setShowImageAdjustModal] = useState(false);
    const [imageFileToAdjust, setImageFileToAdjust] = useState(null);
    const flyerInputRef = useRef(null);

    const isAuthorized = creatorProfile?.isVerifiedAdvertiser && creatorProfile.verifiedAdvertiserExpiresAt && creatorProfile.verifiedAdvertiserExpiresAt.toDate() > new Date();
    const isPromotingFromOpportunity = !!opportunityToPromote;

    const handleFileSelect = (e) => {
        const file = e.target.files[0];
        if (file) { setImageFileToAdjust(file); setShowImageAdjustModal(true); }
    };
    const handleSaveAdjustedImage = (adjustedBlob) => {
        const newFile = new File([adjustedBlob], "promo_flyer.png", { type: "image/png" });
        setFlyerFile(newFile);
        setFlyerPreview(URL.createObjectURL(newFile));
        setShowImageAdjustModal(false);
    };
    const handleCancelAdjust = () => {
        setImageFileToAdjust(null); setShowImageAdjustModal(false);
        if (flyerInputRef.current) flyerInputRef.current.value = null;
    };

    useEffect(() => {
        if (!currentUser || !isAuthorized) {
            setLoading(false);
            return;
        }
        const getSlotAndPrice = async () => {
            setLoading(true);
            try {
                const getSlotFunction = httpsCallable(functions, 'getNextAvailableStatusSlot');
                const slotResult = await getSlotFunction();
                setNextSlot(new Date(slotResult.data.nextAvailable));

                const settingsRef = doc(db, "settings", "socialLinks");
                const settingsSnap = await getDoc(settingsRef);
                if (settingsSnap.exists() && typeof settingsSnap.data().promotedStatusPrice === 'number') {
                    setBookingPrice(settingsSnap.data().promotedStatusPrice);
                }
            } catch (error) {
                showMessage("Could not fetch booking details. Please try again.");
            } finally {
                setLoading(false);
            }
        };
        getSlotAndPrice();
    }, [currentUser, isAuthorized]);

    useEffect(() => {
        if (isPromotingFromOpportunity) return;
        if (!mainUrl) { setAutoThumbnail(''); return; }
        const handler = setTimeout(() => {
            const info = extractVideoInfo(mainUrl);
            if (info && info.thumbnailUrl && info.thumbnailUrl !== GENERIC_THUMBNAIL_PLACEHOLDER) {
                setAutoThumbnail(info.thumbnailUrl);
            } else { setAutoThumbnail(''); }
        }, 800);
        return () => clearTimeout(handler);
    }, [mainUrl, isPromotingFromOpportunity]);

    const handleSubmit = async (e) => {
        e.preventDefault();
        setIsSubmitting(true);
        let bookingDetails = {
            scheduledStartTime: nextSlot.toISOString(),
            scheduledEndTime: new Date(nextSlot.getTime() + 24 * 60 * 60 * 1000).toISOString(),
            price: bookingPrice
        };
        let contentDetails = null;

        if (isPromotingFromOpportunity) {
            bookingDetails.sourceOpportunityId = opportunityToPromote;
        } else {
            // THIS IS THE NEW VALIDATION LOGIC FOR MANUAL MODE
            const finalThumbnail = flyerPreview || autoThumbnail;
            if (!title.trim() || !mainUrl.trim()) {
                showMessage("Ad Title and a valid URL are required to book.");
                setIsSubmitting(false);
                return;
            }
            if (!finalThumbnail) {
                showMessage("Could not get a thumbnail from this URL. Please upload a custom image to continue.");
                setIsSubmitting(false);
                return;
            }
            // END OF NEW VALIDATION LOGIC

            showMessage("Uploading and submitting...");
            let uploadedFlyerUrl = finalThumbnail;
            if (flyerFile) {
                try {
                    const filePath = `promo_flyers/${currentUser.uid}/${Date.now()}_booking.png`;
                    const storageRef = ref(storage, filePath);
                    const snapshot = await uploadBytes(storageRef, flyerFile);
                    uploadedFlyerUrl = await getDownloadURL(snapshot.ref);
                } catch (error) {
                    showMessage(`Flyer upload failed: ${error.message}`);
                    setIsSubmitting(false);
                    return;
                }
            }
            contentDetails = {
                title: title.trim(),
                mainUrl: mainUrl.trim(),
                flyerImageUrl: uploadedFlyerUrl
            };
        }

        try {
            const unifiedBookingFunction = httpsCallable(functions, 'createBookingAndPledge');
            const result = await unifiedBookingFunction({ bookingDetails, contentDetails });
            setPledgeIdForConfirmation(result.data.pledgeId);
            setOpportunityToPromote(null);
            setActiveScreen('PendingConfirmation');
        } catch (error) {
            showMessage(`Booking failed: ${error.message}`);
            setIsSubmitting(false);
        }
    };

    const finalPreview = flyerPreview || autoThumbnail;

    if (loading) { return <div className="screenContainer"><p className="heading">Loading Booking Information...</p></div>; }
    if (!currentUser) { showMessage("Please log in to book a slot."); setActiveScreen('Login'); return null; }
    if (!isAuthorized) { setActiveScreen('Premium'); return null; }

    return (
        <div className="screenContainer">
            <p className="heading">Book Promoted Billboard</p>
            <p className="subHeading">{isPromotingFromOpportunity ? "Promote your existing opportunity listing." : "Complete all details to submit your booking for review."}</p>
            <form onSubmit={handleSubmit}>
                <div className="dashboardSection">
                    <p className="dashboardSectionTitle">Step 1: Confirm Your Slot</p>
                    <p className="dashboardItem">Next Available 24-Hour Slot:</p>
                    <p className="heading" style={{color: '#FFF'}}>{nextSlot ? nextSlot.toLocaleString() : 'N/A'}</p>
                    <p className="dashboardItem" style={{marginTop: '10px'}}>Price:</p>
                    <p className="premiumFeatureDescription" style={{fontSize: '24px', fontWeight: 'bold', textAlign: 'center', color: '#FFF'}}>{formatCurrency(bookingPrice, selectedCurrency, currencyRates)}</p>
                </div>

                {isPromotingFromOpportunity ? (
                    <div className="dashboardSection" style={{marginTop: '20px'}}>
                        <p className="dashboardSectionTitle">Step 2: Content</p>
                        <p className="paragraph" style={{color: '#00FF00'}}>
                            The title and image from your opportunity listing will be used automatically for this promotion.
                        </p>
                    </div>
                ) : (
                    <div className="dashboardSection" style={{marginTop: '20px'}}>
                        <p className="dashboardSectionTitle">Step 2: Provide Ad Content</p>
                        <div className="formGroup"><label className="formLabel">Ad Title</label><input type="text" className="formInput" value={title} onChange={e => setTitle(e.target.value)} required /></div>
                        <div className="formGroup"><label className="formLabel">URL (Video or External Link)</label><input type="url" className="formInput" value={mainUrl} onChange={e => setMainUrl(e.target.value)} placeholder="Paste your ad's main link here" required /></div>
                        <div className="formGroup">
                            <label className="formLabel">Thumbnail / Flyer</label>
                            {finalPreview && <img src={finalPreview} alt="Ad preview" style={{maxWidth: '200px', borderRadius: '8px', marginBottom: '10px'}} />}
                            <input type="file" className="formInput" ref={flyerInputRef} style={{display:'none'}} onChange={handleFileSelect} accept="image/*" />
                            <button type="button" className="button" onClick={() => flyerInputRef.current.click()} style={{ width: '100%', backgroundColor: '#3A3A3A' }}><span className="buttonText light">Upload Custom Image</span></button>
                            <p className="smallText" style={{textAlign: 'left'}}>Upload to override the auto-fetched preview.</p>
                        </div>
                    </div>
                )}

                <div className="dashboardSection" style={{marginTop: '20px', textAlign: 'center'}}>
                    <p className="dashboardSectionTitle">Step 3: Submit</p>
                    <p className="paragraph">This is a manual payment process. You will be given instructions to complete your payment after submitting your booking and content.</p>
                    <button type="submit" className="button" style={{ backgroundColor: '#0A0A0A', border: '1px solid #333' }} disabled={isSubmitting}>
                        <span className="buttonText" style={{color: '#00FFFF'}}>{isSubmitting ? 'Submitting...' : 'Submit Booking & Get Payment Info'}</span>
                    </button>
                </div>
            </form>
            <button className="button" onClick={() => setActiveScreen('Premium')} style={{ backgroundColor: '#3A3A3A', marginTop: '30px' }}>
                <span className="buttonText light">Back</span>
            </button>
            {showImageAdjustModal && imageFileToAdjust && (
                <ProfilePictureAdjustModal
                    imageUrl={URL.createObjectURL(imageFileToAdjust)}
                    onSave={handleSaveAdjustedImage}
                    onCancel={handleCancelAdjust}
                    showMessage={showMessage}
                    isUploading={isSubmitting}
                />
            )}
        </div>
    );
};

// ======================================================================
// ============ END: ADD THE NEW BookStatusScreen COMPONENT ===============
// ======================================================================


            // ======================================================================
// ========= START: ADD THIS ENTIRE NEW AdminCampaignDetailsScreen COMPONENT =========
// ======================================================================

        const AdminCampaignDetailsScreen = ({ showMessage, setActiveScreen, currentUser, selectedAdminCampaignId, setShowConfirmationModal, setConfirmationTitle, setConfirmationMessage, setOnConfirmationAction, creatorProfile }) => {
            const [campaign, setCampaign] = useState(null);
            const [loading, setLoading] = useState(true);

            useEffect(() => {
                if (!selectedAdminCampaignId) {
                    showMessage("No campaign selected for review.");
                    setActiveScreen('AdminDashboard');
                    return;
                }
                const campaignDocRef = doc(db, `artifacts/${appId}/public/data/campaigns`, selectedAdminCampaignId);
                const unsubscribe = onSnapshot(campaignDocRef, (docSnap) => {
                    if (docSnap.exists()) {
                        setCampaign({ id: docSnap.id, ...docSnap.data() });
                    } else {
                        showMessage("Campaign not found.");
                        setActiveScreen('AdminDashboard');
                    }
                    setLoading(false);
                });
                return () => unsubscribe();
            }, [selectedAdminCampaignId]);

            const handleStatusUpdate = async (newStatus) => {
                if (!campaign || !currentUser) return;
                const actionText = newStatus === 'active' ? 'Approving' : 'Rejecting';
                showMessage(`${actionText} campaign...`);
                try {
                    const campaignDocRef = doc(db, `artifacts/${appId}/public/data/campaigns`, campaign.id);
                    await updateDoc(campaignDocRef, {
                        status: newStatus,
                        [`${newStatus}By`]: currentUser.uid,
                        [`${newStatus}At`]: new Date().toISOString(),
                        updatedAt: new Date().toISOString()
                    });
                    showMessage(`Campaign "${campaign.title}" has been ${newStatus}.`);
                    setActiveScreen('AdminDashboard');
                } catch (error) {
                    showMessage(`Failed to update campaign: ${error.message}`);
                }
            };
            
            const confirmAction = (status) => {
                const title = status === 'active' ? 'Approve Campaign?' : 'Reject Campaign?';
                const message = `Are you sure you want to ${status === 'active' ? 'APPROVE' : 'REJECT'} the campaign "${campaign.title}"?`;
                setConfirmationTitle(title);
                setConfirmationMessage(message);
                setOnConfirmationAction(() => () => handleStatusUpdate(status));
                setShowConfirmationModal(true);
            };

            if (loading) {
                return <div className="screenContainer" style={{ textAlign: 'center' }}><p className="heading">Loading Campaign for Review...</p></div>;
            }

            if (!campaign) return null;

            return (
                <div className="screenContainer">
                    <CampaignDetailsScreen 
                        showMessage={showMessage} 
                        setActiveScreen={setActiveScreen} 
                        selectedCampaignId={selectedAdminCampaignId} 
                        currentUser={currentUser} 
                        setPledgeContext={() => {}} 
                    />
                    <div className="dashboardSection" style={{ border: '2px solid #FFD700' }}>
                        <p className="dashboardSectionTitle">Admin Actions</p>
                        <div style={{ display: 'flex', justifyContent: 'space-around', marginTop: '20px' }}>
                            <button className="adminActionButton approve" onClick={() => confirmAction('active')}>Approve Campaign</button>
                            <button className="adminActionButton reject" onClick={() => confirmAction('rejected')}>Reject Campaign</button>
                        </div>
                    </div>
                     <button className="button" onClick={() => setActiveScreen('AdminDashboard')} style={{ backgroundColor: '#3A3A3A', marginTop: '30px' }}>
                        <span className="buttonText light">Back to Admin Dashboard</span>
                    </button>
                </div>
            );
        };

// ======================================================================
// ========== END: ADD THIS ENTIRE NEW AdminCampaignDetailsScreen COMPONENT ==========
// ======================================================================

                // ======================================================================
// ========= START: ADD THIS ENTIRE NEW DonationPledgeScreen COMPONENT =========
// ======================================================================

const DonationPledgeScreen = ({ showMessage, setActiveScreen, currentUser, creatorProfile, pledgeContext, setPledgeIdForConfirmation }) => {
    const [amount, setAmount] = useState('');
    const [userName, setUserName] = useState(creatorProfile?.creatorName || currentUser?.email.split('@')[0] || '');
    const [agreedToTerms, setAgreedToTerms] = useState(false);
    const [isSubmitting, setIsSubmitting] = useState(false);

    if (!pledgeContext || pledgeContext.type !== 'donation') {
        // Safety check to prevent rendering without proper context
        setActiveScreen('AllCampaigns');
        return null;
    }

    const handleSubmitPledge = async (e) => {
        e.preventDefault();
        const parsedAmount = parseFloat(amount);
        if (isNaN(parsedAmount) || parsedAmount <= 0) {
            showMessage("Please enter a valid, positive donation amount.");
            return;
        }
        if (!userName.trim()) {
            showMessage("Please enter your name.");
            return;
        }
        if (!agreedToTerms) {
            showMessage("You must agree to the payment terms.");
            return;
        }

        setIsSubmitting(true);
        const pledgeId = `NVA-${Date.now().toString().slice(-6).toUpperCase()}`;

        try {
            const pledgeRef = doc(collection(db, "paymentPledges"), pledgeId);
            await setDoc(pledgeRef, {
                pledgeId,
                userId: currentUser.uid,
                userName: userName.trim(),
                userEmail: currentUser.email,
                paymentType: 'donation',
                amount: parsedAmount,
                status: 'pending',
                targetCampaignId: pledgeContext.campaignId,
                targetCampaignTitle: pledgeContext.campaignTitle,
                createdAt: new Date().toISOString(),
            });
            
            setPledgeIdForConfirmation(pledgeId);
            setActiveScreen('PendingConfirmation');

        } catch (error) {
            showMessage(`An error occurred: ${error.message}`);
            setIsSubmitting(false);
        }
    };

    return (
        <div className="screenContainer">
            <p className="heading">Support Campaign</p>
            <p className="subHeading">You are supporting "{pledgeContext.campaignTitle}" by {pledgeContext.creatorName}.</p>
            
            <form onSubmit={handleSubmitPledge}>
                <div className="formGroup">
                    <label htmlFor="donationAmount" className="formLabel">Donation Amount (USD):</label>
                    <input
                        type="number"
                        id="donationAmount"
                        className="formInput"
                        value={amount}
                        onChange={(e) => setAmount(e.target.value)}
                        min="1"
                        step="any"
                        placeholder="e.g., 10.00"
                        required
                    />
                </div>
                <div className="formGroup">
                    <label htmlFor="pledgeName" className="formLabel">Your Name:</label>
                    <input
                        type="text"
                        id="pledgeName"
                        className="formInput"
                        value={userName}
                        onChange={(e) => setUserName(e.target.value)}
                        required
                    />
                </div>

                <div className="formGroup">
                    <p className="termsText" style={{textAlign: 'left', color: '#CCC'}}>
                        This is a manual payment process. After submitting your pledge, you will be given instructions to complete your payment via MMG.
                    </p>
                </div>

                <div className="formGroup">
                    <div className="checkboxItem">
                        <input
                            type="checkbox"
                            id="agreeToTerms"
                            checked={agreedToTerms}
                            onChange={(e) => setAgreedToTerms(e.target.checked)}
                            required
                        />
                        <label htmlFor="agreeToTerms">I understand and agree to the payment terms.</label>
                    </div>
                </div>

                <button type="submit" className="button" disabled={isSubmitting}>
                    <span className="buttonText">{isSubmitting ? "Generating..." : "Submit Pledge & Get Payment Info"}</span>
                </button>
            </form>

            <button
                className="button"
                onClick={() => setActiveScreen('CampaignDetails')}
                style={{ backgroundColor: '#3A3A3A', marginTop: '20px' }}
            >
                <span className="buttonText">Back to Campaign</span>
            </button>
        </div>
    );
};

// ======================================================================
// ========== END: ADD THIS ENTIRE NEW DonationPledgeScreen COMPONENT ==========
// ======================================================================

            // ======================================================================
// ========= START: ADD THIS ENTIRE NEW ReportContentModal COMPONENT ====
// ======================================================================

const ReportContentModal = ({ showMessage, onCancel, contentToReport }) => {
    const [reason, setReason] = useState('');
    const [note, setNote] = useState('');
    const [isSubmitting, setIsSubmitting] = useState(false);

    const reportReasons = [
        "Harassment or Bullying",
        "Hate Speech",
        "Nudity or Sexual Content",
        "Spam or Misleading",
        "Copyright Infringement",
        "Violent or Graphic Content",
        "Other"
    ];
    
    if (!contentToReport) return null;

    const handleSubmit = async (e) => {
        e.preventDefault();
        if (!reason) {
            showMessage("Please select a reason for the report.");
            return;
        }
        setIsSubmitting(true);
        try {
            const reportFunction = httpsCallable(functions, 'createContentReport');
            const result = await reportFunction({
                contentId: contentToReport.id,
                appId: appId,
                reason: reason,
                note: note
            });
            showMessage(result.data.message);
            onCancel(); // Close the modal on success
        } catch (error) {
            showMessage(`Error: ${error.message}`);
        } finally {
            setIsSubmitting(false);
        }
    };

    return (
        <div className="confirmationModalOverlay" style={{ zIndex: 3000 }}>
            <div className="confirmationModalContent" style={{ textAlign: 'left', maxWidth: '500px' }}>
                <p className="confirmationModalTitle">Report Content</p>
                <p className="subHeading" style={{textAlign: 'left', fontSize: '14px', margin: '0 0 15px 0'}}>
                    You are reporting: <strong>{contentToReport.title}</strong>
                </p>
                <form onSubmit={handleSubmit}>
                    <div className="formGroup">
                        <label className="formLabel">Reason:</label>
                        {reportReasons.map(r => (
                            <div key={r} className="checkboxItem">
                                <input type="radio" id={`reason-${r}`} name="report_reason" value={r} checked={reason === r} onChange={(e) => setReason(e.target.value)} />
                                <label htmlFor={`reason-${r}`} style={{marginLeft: '8px'}}>{r}</label>
                            </div>
                        ))}
                    </div>
                    <div className="formGroup">
                        <label className="formLabel">Additional Notes (Optional):</label>
                        <textarea 
                            className="formTextarea" 
                            value={note}
                            onChange={(e) => setNote(e.target.value)}
                            placeholder="Provide any additional context or timestamps." 
                        />
                    </div>
                    <div className="confirmationModalButtons">
                        <button type="button" className="confirmationButton cancel" onClick={onCancel}>Cancel</button>
                        <button type="submit" className="confirmationButton confirm" disabled={isSubmitting} style={{backgroundColor: '#DC3545'}}>
                            {isSubmitting ? 'Submitting...' : 'Submit Report'}
                        </button>
                    </div>
                </form>
            </div>
        </div>
    );
};

// ======================================================================
// ========== END: ADD THIS ENTIRE NEW ReportContentModal COMPONENT =====
// ======================================================================

// ======================================================================
// ========= START: ADD THIS ENTIRE NEW MODERATION QUEUE COMPONENT ======
// ======================================================================

const AdminModerationQueue = ({ showMessage, setActiveScreen, setSelectedReportGroup }) => {
    const [reports, setReports] = useState([]);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        const reportsRef = collection(db, "reports");
        const q = query(reportsRef, where("status", "==", "pending"), orderBy("createdAt", "asc"));
        
        const unsubscribe = onSnapshot(q, (snapshot) => {
            const fetchedReports = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            setReports(fetchedReports);
            setLoading(false);
        }, (error) => {
            console.error("Error fetching reports:", error);
            showMessage("Failed to load moderation queue.");
            setLoading(false);
        });

        return () => unsubscribe();
    }, []);

    // This useMemo hook performs the "smart grouping" from our blueprint.
    // It runs only when the raw reports list changes.
    const groupedReports = React.useMemo(() => {
        if (reports.length === 0) return [];
        
        const groups = new Map();
        reports.forEach(report => {
            const key = report.contentId;
            if (!groups.has(key)) {
                groups.set(key, {
                    contentId: report.contentId,
                    contentTitle: report.contentTitle,
                    reportedUserId: report.reportedUserId,
                    reportedUserName: report.reportedUserName,
                    reportCount: 0,
                    reports: []
                });
            }
            const group = groups.get(key);
            group.reportCount++;
            group.reports.push(report);
        });
        
        // Convert Map to an array and sort by the number of reports (most reported first)
        return Array.from(groups.values()).sort((a, b) => b.reportCount - a.reportCount);
    }, [reports]);

    return (
        <div className="screenContainer">
            <p className="heading">Moderation Queue</p>
            <p className="subHeading">Content reported by the community. Items with the most reports are shown first.</p>
            
            <div className="dashboardSection">
                {loading ? (
                    <p className="dashboardItem">Loading reports...</p>
                ) : groupedReports.length === 0 ? (
                    <p className="dashboardItem" style={{textAlign: 'center'}}>The queue is empty. No pending reports.</p>
                ) : (
                    <div className="dashboardContentList">
                        {groupedReports.map(group => (
                            <div key={group.contentId} className="adminDashboardItem" style={{ borderLeft: '4px solid #DC3545' }}>
                                <div style={{flexGrow: 1}}>
                                    <p className="adminDashboardItemTitle">{group.contentTitle}</p>
                                    <p style={{fontSize: '12px', color: '#CCC'}}>
                                        by {group.reportedUserName}
                                    </p>
                                </div>
                                <div style={{textAlign: 'center', margin: '0 15px'}}>
                                    <p className="adminDashboardItemTitle" style={{fontSize: '20px', color: '#FFD700'}}>{group.reportCount}</p>
                                    <p style={{fontSize: '12px', color: '#AAA'}}>Report(s)</p>
                                </div>
                                <button 
                                    className="adminActionButton approve"
                                    onClick={() => {
                                        setSelectedReportGroup(group);
                                        setActiveScreen('AdminReportReview');
                                    }}
                                >
                                    Review
                                </button>
                            </div>
                        ))}
                    </div>
                )}
            </div>
        </div>
    );
};

// ======================================================================
// ========== END: ADD THIS ENTIRE NEW MODERATION QUEUE COMPONENT =======
// ======================================================================

               // ======================================================================
// ========= START: ADD THIS ENTIRE NEW REPORT REVIEW SCREEN COMPONENT ==
// ======================================================================

const AdminReportReviewScreen = ({ showMessage, setActiveScreen, currentUser, creatorProfile, selectedReportGroup, setShowConfirmationModal, setConfirmationTitle, setConfirmationMessage, setOnConfirmationAction }) => {
    const [content, setContent] = useState(null);
    const [loadingContent, setLoadingContent] = useState(true);
    const [showSuspensionModal, setShowSuspensionModal] = useState(false);

    useEffect(() => {
        if (!selectedReportGroup) return;

        setLoadingContent(true);
        const fetchContent = async () => {
            try {
                const contentRef = doc(db, `artifacts/${appId}/public/data/content_items`, selectedReportGroup.contentId);
                const docSnap = await getDoc(contentRef);
                if (docSnap.exists()) {
                    setContent({ id: docSnap.id, ...docSnap.data() });
                } else {
                    showMessage("Could not find the reported content. It may have been deleted.");
                    setContent(null);
                }
            } catch (error) {
                showMessage("Error fetching content details.");
                console.error("Error fetching content:", error);
            } finally {
                setLoadingContent(false);
            }
        };

        fetchContent();
    }, [selectedReportGroup]);
    
    if (!selectedReportGroup) {
        setActiveScreen('AdminDashboard');
        return null;
    }

    const { contentId, reportedUserId, reportedUserName, reports } = selectedReportGroup;
    const reportIds = reports.map(r => r.id);

    const handleAction = async (action, details = {}) => {
        let functionName, payload, confirmationTitle, confirmationMessage;

        switch(action) {
            case 'dismiss':
                functionName = 'dismissContentReports';
                payload = { reportIds };
                confirmationTitle = "Dismiss Reports?";
                confirmationMessage = `Are you sure you want to dismiss all ${reportIds.length} report(s) for this content? This action implies the content is not in violation.`;
                break;
            case 'remove_content':
                functionName = 'removeReportedContent';
                payload = { contentId, appId, reportIds };
                confirmationTitle = "Remove Content?";
                confirmationMessage = `This will make the content unavailable to the public and resolve all reports. Are you sure?`;
                break;
            case 'suspend_user':
                setShowSuspensionModal(true);
                return;
            case 'confirm_suspend':
                functionName = 'suspendReportedUser';
                payload = { userId: reportedUserId, durationHours: details.duration, reportIds };
                confirmationTitle = `Suspend ${reportedUserName}?`;
                confirmationMessage = `This will suspend the user for ${details.duration} hours and resolve all reports. Proceed?`;
                break;
            default:
                return;
        }

        const actionLogic = async () => {
            try {
                const callable = httpsCallable(functions, functionName);
                const result = await callable(payload);
                showMessage(result.data.message);
                setActiveScreen('AdminDashboard');
            } catch (error) {
                showMessage(`Error: ${error.message}`);
            }
        };

        setConfirmationTitle(confirmationTitle);
        setConfirmationMessage(confirmationMessage);
        setOnConfirmationAction(() => actionLogic);
        setShowConfirmationModal(true);
    };

    const { embedUrl, isVertical } = content ? extractVideoInfo(content.mainUrl) : {};

    return (
        <>
            <div className="screenContainer">
                <div style={{ display: 'flex', alignItems: 'center', marginBottom: '10px' }}>
                    <button onClick={() => setActiveScreen('AdminDashboard')} style={{ background: 'none', border: '1px solid #FFD700', color: '#FFD700', borderRadius: '50%', width: '40px', height: '40px', display: 'flex', alignItems: 'center', justifyContent: 'center', cursor: 'pointer', marginRight: '15px' }}>
                        &#x2190;
                    </button>
                    <p className="heading" style={{ margin: 0, textAlign: 'left', flexGrow: 1 }}>Review Content</p>
                </div>

                <div className="dashboardSection" style={{marginBottom: '20px'}}>
                    <p className="dashboardItem"><strong>Content:</strong> {selectedReportGroup.contentTitle}</p>
                    <p className="dashboardItem"><strong>Creator:</strong> {reportedUserName}</p>
                    
                    {loadingContent ? (
                        <p className="dashboardItem">Loading content for review...</p>
                    ) : content ? (
                        <div className={`videoModalContent ${isVertical ? 'vertical' : ''}`} style={{position: 'relative', width: '100%', height: 'auto', minHeight: '300px', boxShadow: 'none', background: '#0A0A0A', marginTop: '15px', marginLeft: 'auto', marginRight: 'auto'}}>
                            <div className={`videoIframeContainer ${isVertical ? 'vertical' : ''}`}>
                                <iframe src={embedUrl || content.mainUrl} allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowFullScreen title="Reported Content"></iframe>
                            </div>
                        </div>
                    ) : (
                        <p className="dashboardItem" style={{color: '#DC3545', fontWeight: 'bold'}}>Could not load video player for this content.</p>
                    )}
                </div>

                <div className="dashboardSection" style={{border: '2px solid #DC3545'}}>
                    <p className="dashboardSectionTitle">Moderator Actions</p>
                    <div style={{ display: 'flex', justifyContent: 'space-around', gap: '10px', flexWrap: 'wrap', marginTop: '15px' }}>
                        <button className="button" style={{backgroundColor: '#008000'}} onClick={() => handleAction('dismiss')}>
                            <span className="buttonText">Dismiss All Reports</span>
                        </button>
                        <button className="button" style={{backgroundColor: '#FF8C00'}} onClick={() => handleAction('remove_content')}>
                            <span className="buttonText">Remove Content</span>
                        </button>
                        <button className="button" style={{backgroundColor: '#DC3545'}} onClick={() => handleAction('suspend_user')}>
                            <span className="buttonText">Suspend User</span>
                        </button>
                    </div>
                </div>

                <div className="dashboardSection" style={{marginTop: '20px'}}>
                    <p className="dashboardSectionTitle">Reports ({reports.length})</p>
                    <div className="dashboardContentList" style={{ maxHeight: '300px', overflowY: 'auto' }}>
                        {reports.map(report => (
                            <div key={report.id} className="adminDashboardItem" style={{flexDirection: 'column', alignItems: 'flex-start'}}>
                                <div style={{display: 'flex', justifyContent: 'space-between', width: '100%', alignItems: 'center'}}>
                                    <p className="adminDashboardItemTitle">{report.reason}</p>
                                    <p style={{fontSize: '12px', color: '#AAA'}}>{report.createdAt ? new Date(report.createdAt.toDate()).toLocaleString() : 'N/A'}</p>
                                </div>
                                <p style={{fontSize: '12px', color: '#CCC', margin: '5px 0'}}>by {report.reporterName || 'Unknown'} ({report.reporterEmail})</p>
                                {report.note && <p className="paragraph" style={{fontSize: '13px', backgroundColor: '#1A1A1A', padding: '8px', borderRadius: '5px', width: '100%', margin: '5px 0 0 0'}}>{report.note}</p>}
                            </div>
                        ))}
                    </div>
                </div>
            </div>

            {showSuspensionModal && (
                <SuspensionModal 
                    userName={reportedUserName}
                    onCancel={() => setShowSuspensionModal(false)}
                    onConfirm={(duration) => {
                        setShowSuspensionModal(false);
                        handleAction('confirm_suspend', { duration });
                    }}
                />
            )}
        </>
    );
};


// ======================================================================
// ========== END: ADD THIS ENTIRE NEW REPORT REVIEW SCREEN COMPONENT ===
// ====================================================================== 


// ======================================================================
// ========= START: ADD THIS ENTIRE NEW SUSPENSION MODAL COMPONENT ======
// ======================================================================

const SuspensionModal = ({ onConfirm, onCancel, userName }) => {
    const [duration, setDuration] = useState(24); // Default to 24 hours

    return (
        <div className="confirmationModalOverlay">
            <div className="confirmationModalContent">
                <p className="confirmationModalTitle">Suspend User</p>
                <p className="confirmationModalMessage">
                    Select a suspension duration for <strong>{userName}</strong>. They will be logged out and unable to log back in until the duration expires.
                </p>
                <div className="formGroup" style={{marginTop: '15px'}}>
                    <label className="formLabel">Suspension Duration:</label>
                    <select className="formInput" value={duration} onChange={(e) => setDuration(e.target.value)}>
                        <option value="24">24 Hours</option>
                        <option value="72">3 Days</option>
                        <option value="168">1 Week</option>
                        <option value="720">30 Days</option>
                    </select>
                </div>
                <div className="confirmationModalButtons">
                    <button className="confirmationButton cancel" onClick={onCancel}>
                        Cancel
                    </button>
                    <button className="confirmationButton confirm" onClick={() => onConfirm(duration)} style={{backgroundColor: '#DC3545'}}>
                        Confirm Suspension
                    </button>
                </div>
            </div>
        </div>
    );
};

// ======================================================================
// ========== END: ADD THIS ENTIRE NEW SUSPENSION MODAL COMPONENT =======
// ======================================================================

                // ======================================================================
// ========= START: ADD THIS ENTIRE NEW COMPONENT (Action 1 of 2) =======
// ======================================================================

const SetVerificationExpiryModal = ({ onConfirm, onCancel, userName }) => {
    const [duration, setDuration] = useState(1); // Default to 1 month

    return (
        <div className="confirmationModalOverlay">
            <div className="confirmationModalContent">
                <p className="confirmationModalTitle">Set Verification Duration</p>
                <p className="confirmationModalMessage">
                    Select an expiration duration for <strong>{userName}</strong>. Their Verified Advertiser status will automatically expire after this period.
                </p>
                <div className="formGroup" style={{marginTop: '15px'}}>
                    <label className="formLabel">Verification Duration:</label>
                    <select className="formInput" value={duration} onChange={(e) => setDuration(e.target.value)}>
                        <option value="1">1 Month</option>
                        <option value="3">3 Months</option>
                        <option value="6">6 Months</option>
                        <option value="12">1 Year</option>
                    </select>
                </div>
                <div className="confirmationModalButtons">
                    <button className="confirmationButton cancel" onClick={onCancel}>
                        Cancel
                    </button>
                    <button className="confirmationButton confirm" onClick={() => onConfirm(duration)}>
                        Confirm & Set
                    </button>
                </div>
            </div>
        </div>
    );
};

// ======================================================================
// ========== END: ADD THIS ENTIRE NEW COMPONENT (Action 1 of 2) ========
// ======================================================================

        // ======================================================================
// ========= START: ADD THIS ENTIRE NEW APPEALS QUEUE COMPONENT =========
// ======================================================================

const AdminAppealsQueue = ({ showMessage, setActiveScreen, setShowConfirmationModal, setConfirmationTitle, setConfirmationMessage, setOnConfirmationAction }) => {
    const [appeals, setAppeals] = useState([]);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        const appealsRef = collection(db, "appeals");
        const q = query(appealsRef, where("status", "==", "pending"), orderBy("createdAt", "asc"));
        
        const unsubscribe = onSnapshot(q, (snapshot) => {
            setAppeals(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
            setLoading(false);
        });

        return () => unsubscribe();
    }, []);

    const handleAction = (action, appeal) => {
        let functionName, confirmationTitle, confirmationMessage;
        const payload = { userId: appeal.userId, appealId: appeal.id };

        if (action === 'reinstate') {
            functionName = 'reinstateUser';
            confirmationTitle = "Reinstate User?";
            confirmationMessage = `This will immediately lift the suspension for ${appeal.userName} and resolve this appeal. Are you sure?`;
        } else {
            functionName = 'dismissAppeal';
            confirmationTitle = "Dismiss Appeal?";
            confirmationMessage = `This will dismiss the appeal from ${appeal.userName}, and their suspension will continue. Are you sure?`;
        }

        const actionLogic = async () => {
            try {
                const callable = httpsCallable(functions, functionName);
                const result = await callable(payload);
                showMessage(result.data.message);
            } catch (error) {
                showMessage(`Error: ${error.message}`);
            }
        };

        setConfirmationTitle(confirmationTitle);
        setConfirmationMessage(confirmationMessage);
        setOnConfirmationAction(() => actionLogic);
        setShowConfirmationModal(true);
    };

    return (
        <div className="screenContainer">
            <p className="heading">Appeals Queue</p>
            <p className="subHeading">Review appeals from users who have been temporarily suspended.</p>
            
            <div className="dashboardSection">
                {loading ? (
                    <p className="dashboardItem">Loading appeals...</p>
                ) : appeals.length === 0 ? (
                    <p className="dashboardItem" style={{textAlign: 'center'}}>The appeals queue is empty.</p>
                ) : (
                    <div className="dashboardContentList">
                        {appeals.map(appeal => (
                            <div key={appeal.id} className="adminDashboardItem" style={{flexDirection: 'column', alignItems: 'stretch', gap: '10px'}}>
                                <div style={{display: 'flex', justifyContent: 'space-between', width: '100%'}}>
                                    <p className="adminDashboardItemTitle">{appeal.userName} ({appeal.userEmail})</p>
                                    <p style={{fontSize: '12px', color: '#AAA'}}>{new Date(appeal.createdAt.toDate()).toLocaleString()}</p>
                                </div>
                                <p className="paragraph" style={{fontSize: '14px', backgroundColor: '#1A1A1A', padding: '10px', borderRadius: '5px', width: '100%', margin: '5px 0 0 0', whiteSpace: 'pre-wrap'}}>{appeal.message}</p>
                                <div style={{display: 'flex', justifyContent: 'flex-end', gap: '10px', marginTop: '10px'}}>
                                    <button className="adminActionButton reject" onClick={() => handleAction('dismiss', appeal)}>Dismiss Appeal</button>
                                    <button className="adminActionButton approve" onClick={() => handleAction('reinstate', appeal)}>Reinstate User</button>
                                </div>
                            </div>
                        ))}
                    </div>
                )}
            </div>
        </div>
    );
};

// ======================================================================
// ========== END: ADD THIS ENTIRE NEW APPEALS QUEUE COMPONENT ==========
// ======================================================================

        // ======================================================================
// ========= START: ADD THIS ENTIRE NEW MODERATION CENTER COMPONENT =====
// ======================================================================

const AdminModerationCenter = ({ showMessage, setActiveScreen, setSelectedReportGroup, setShowConfirmationModal, setConfirmationTitle, setConfirmationMessage, setOnConfirmationAction }) => {
    const [activeTab, setActiveTab] = useState('reports'); // 'reports' or 'appeals'

    return (
        <div className="screenContainer">
            <p className="heading">Moderation Center</p>
            <p className="subHeading">Manage community reports and user appeals.</p>

            {/* Sub-navigation for the moderation center */}
            <div style={{ display: 'flex', justifyContent: 'center', gap: '10px', marginBottom: '20px', borderBottom: '1px solid #333', paddingBottom: '15px' }}>
                <button className="button" onClick={() => setActiveTab('reports')} style={{ backgroundColor: activeTab === 'reports' ? '#FFD700' : '#3A3A3A', color: activeTab === 'reports' ? '#0A0A0A' : '#FFF' }}>
                    <span className="buttonText">Reports Queue</span>
                </button>
                <button className="button" onClick={() => setActiveTab('appeals')} style={{ backgroundColor: activeTab === 'appeals' ? '#FFD700' : '#3A3A3A', color: activeTab === 'appeals' ? '#0A0A0A' : '#FFF' }}>
                    <span className="buttonText">Appeals Queue</span>
                </button>
            </div>

            {/* Conditionally render the correct queue based on the active tab */}
            {activeTab === 'reports' && (
                <AdminModerationQueue
                    showMessage={showMessage}
                    setActiveScreen={setActiveScreen}
                    setSelectedReportGroup={setSelectedReportGroup}
                />
            )}
            {activeTab === 'appeals' && (
                <AdminAppealsQueue
                    showMessage={showMessage}
                    setActiveScreen={setActiveScreen}
                    setShowConfirmationModal={setShowConfirmationModal}
                    setConfirmationTitle={setConfirmationTitle}
                    setConfirmationMessage={setConfirmationMessage}
                    setOnConfirmationAction={setOnConfirmationAction}
                />
            )}
        </div>
    );
};

// ======================================================================
// ========== END: ADD THIS ENTIRE NEW MODERATION CENTER COMPONENT ======
// ======================================================================

// ======================================================================
// ========= START: ADD THIS ENTIRE NEW SUSPENDED SCREEN COMPONENT ======
// ======================================================================

const SuspendedScreen = ({ showMessage, setActiveScreen, suspensionDetails }) => {
    const [message, setMessage] = useState('');
    const [isSubmitting, setIsSubmitting] = useState(false);

    const handleSubmitAppeal = async (e) => {
        e.preventDefault();
        if (!message.trim()) {
            showMessage("Please provide a reason for your appeal.");
            return;
        }
        setIsSubmitting(true);
        try {
            const appealFunction = httpsCallable(functions, 'submitSuspensionAppeal');
            const result = await appealFunction({
                userEmail: suspensionDetails.email,
                message: message
            });
            showMessage(result.data.message);
        } catch (error) {
            showMessage(`Error: ${error.message}`);
        } finally {
            setIsSubmitting(false);
        }
    };

    if (!suspensionDetails) {
        setActiveScreen('Home');
        return null;
    }

    return (
        <div className="screenContainer" style={{textAlign: 'center', paddingTop: '50px'}}>
            <p className="heading" style={{color: '#DC3545'}}>Account Suspended</p>
            <p className="subHeading">
                Your account has been temporarily suspended.
            </p>
            <p className="paragraph">
                Reason: Violation of community guidelines. <br/>
                Your access will be restored on: <br/>
                <strong style={{color: '#FFD700', fontSize: '16px'}}>{suspensionDetails.expiryDate}</strong>
            </p>

            <div className="dashboardSection" style={{marginTop: '20px', textAlign: 'left'}}>
                <p className="dashboardSectionTitle">Submit an Appeal</p>
                <p className="dashboardItem" style={{color: '#AAA', lineHeight: 1.4, marginBottom: '15px'}}>
                    If you believe this suspension was made in error, you may submit one appeal for review.
                </p>
                <form onSubmit={handleSubmitAppeal}>
                    <div className="formGroup">
                        <label className="formLabel">Your Email:</label>
                        <input type="email" className="formInput" value={suspensionDetails.email} disabled />
                    </div>
                    <div className="formGroup">
                        <label className="formLabel">Reason for Appeal:</label>
                        <textarea 
                            className="formTextarea" 
                            value={message}
                            onChange={(e) => setMessage(e.target.value)}
                            placeholder="Please explain why you believe your suspension should be reviewed." 
                            required
                        ></textarea>
                    </div>
                    <button type="submit" className="button" disabled={isSubmitting}>
                        <span className="buttonText">{isSubmitting ? 'Submitting...' : 'Submit Appeal'}</span>
                    </button>
                </form>
            </div>
        </div>
    );
};

// ======================================================================
// ========== END: ADD THIS ENTIRE NEW SUSPENDED SCREEN COMPONENT =======
// ======================================================================```

// ======================================================================
// ========= START: ADD THE NEW MyListingsScreen COMPONENT ==============
// ======================================================================

        const MyListingsScreen = ({ showMessage, setActiveScreen, currentUser }) => {
            const [myListings, setMyListings] = useState([]);
            const [loading, setLoading] = useState(true);

            useEffect(() => {
                if (!currentUser) return;
                const opportunitiesRef = collection(db, "opportunities");
                const q = query(opportunitiesRef, where("postedByUid", "==", currentUser.uid), orderBy("createdAt", "desc"), limit(10));
                const unsubscribe = onSnapshot(q, (snapshot) => {
                    setMyListings(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
                    setLoading(false);
                });
                return () => unsubscribe();
            }, [currentUser]);
            
            const handleDelete = async (opportunityId) => {
                // This function's logic remains the same
                showMessage("Deleting listing...");
                try {
                    const deleteFunction = httpsCallable(functions, 'deleteOpportunity');
                    await deleteFunction({ opportunityId });
                    showMessage("Listing deleted successfully.");
                } catch (error) { showMessage(`Error: ${error.message}`); }
            };

            // --- NEW: Handler for closing a listing ---
            const handleClose = async (opportunityId) => {
                showMessage("Closing listing...");
                try {
                    const closeFunction = httpsCallable(functions, 'closeOpportunityListing');
                    await closeFunction({ opportunityId });
                    showMessage("Listing closed successfully.");
                } catch (error) { showMessage(`Error: ${error.message}`); }
            };

            const getStatusStyle = (status) => {
                switch (status) {
                    case 'active': return { color: '#00FF00', fontWeight: 'bold' };
                    case 'pending': return { color: '#FFD700', fontWeight: 'bold' };
                    case 'rejected': return { color: '#DC3545', fontWeight: 'bold' };
                    case 'expired': return { color: '#888', fontWeight: 'bold' };
                    default: return {};
                }
            };

            return (
                <div className="screenContainer">
                    <p className="heading">My Opportunity Listings</p>
                    <p className="subHeading">Track the status of your posts. Your 10 most recent listings are shown here.</p>
                    {loading ? <p>Loading your listings...</p> : (
                        <div className="allCampaignsList">
                            {myListings.length === 0 ? <p className="dashboardItem">You have not posted any opportunities yet.</p> :
                                myListings.map(opp => (
                                    <div key={opp.id} className="allCampaignsListItem" style={{alignItems: 'center'}}>
                                        <img 
                                            src={opp.flyerImageUrl || 'https://placehold.co/80x80/2A2A2A/FFF?text=N/A'} 
                                            alt={opp.title}
                                            style={{width: '80px', height: '80px', objectFit: 'cover', borderRadius: '8px', marginRight: '15px'}}
                                        />
                                        <div className="campaignListContent">
                                            <p className="campaignListTitle" style={{marginBottom: '5px'}}>{opp.title}</p>
                                            <p className="campaignListCreator" style={{marginBottom: '10px'}}>
                                                Status: <span style={getStatusStyle(opp.status)}>{opp.status.charAt(0).toUpperCase() + opp.status.slice(1)}</span>
                                            </p>
                                            <div className="videoActions" style={{justifyContent: 'flex-start'}}>
                                                {opp.status === 'active' && (
                                                    <button className="actionButton" style={{backgroundColor: '#FF8C00'}} onClick={() => handleClose(opp.id)}>Close Listing</button>
                                                )}
                                                <button className="actionButton remove" onClick={() => handleDelete(opp.id)}>Delete</button>
                                            </div>
                                        </div>
                                    </div>
                                ))
                            }
                        </div>
                    )}
                     <button className="button" onClick={() => setActiveScreen('CreatorDashboard')} style={{ backgroundColor: '#3A3A3A', marginTop: '30px' }}>
                        <span className="buttonText light">Back to Dashboard</span>
                    </button>
                </div>
            );
        };

// ======================================================================
// ========== END: ADD THE NEW MyListingsScreen COMPONENT ===============
// ======================================================================


    const PromotedSlot = ({ showMessage, handleVideoPress, currentUser }) => {
    const [livePromo, setLivePromo] = useState(null);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        const statusesRef = collection(db, "promotedStatuses");
        const now = new Date();
        const q = query(
            statusesRef,
            where("status", "==", "approved_and_scheduled"),
            where("startTime", "<=", now),
            where("expiresAt", ">", now),
            limit(1)
        );

        const unsubscribe = onSnapshot(q, (snapshot) => {
            if (!snapshot.empty) {
                setLivePromo({ id: snapshot.docs[0].id, ...snapshot.docs[0].data() });
            } else {
                setLivePromo(null);
            }
            setLoading(false);
        });

        return () => unsubscribe();
    }, []);

    const handlePromoClick = () => {
        if (!livePromo || !livePromo.content) return;
        const { content } = livePromo;

        if (content.adVideoUrl) {
            const { embedUrl } = extractVideoInfo(content.adVideoUrl);
            handleVideoPress(embedUrl || content.adVideoUrl, { id: livePromo.id, title: content.title });
        } else if (content.destinationUrl) {
            window.open(content.destinationUrl, '_blank');
        } else {
            showMessage("This promotion has no link attached.");
        }
    };

    if (loading || !livePromo) {
        return null; 
    }

    return (
        <div 
            className="allCampaignsListItem" 
            style={{border: '2px solid #00FFFF', background: 'rgba(0, 255, 255, 0.05)', cursor: 'pointer', marginBottom: '20px', alignItems: 'center'}}
            onClick={handlePromoClick}
        >
            <div style={{
                width: '80px',
                height: '80px',
                flexShrink: 0, 
                marginRight: '15px',
                borderRadius: '8px',
                overflow: 'hidden',
                backgroundColor: '#1A1A1A'
            }}>
                <img
                    src={livePromo.content.flyerImageUrl}
                    alt={livePromo.content.title}
                    style={{
                        width: '100%',
                        height: '100%',
                        objectFit: 'contain' // THIS IS THE FIX
                    }}
                    onError={(e) => { e.target.onerror = null; e.target.src='https://placehold.co/100x100/1A1A1A/00FFFF?text=Ad'; }}
                />
            </div>

            <div className="campaignListContent" style={{ minWidth: 0 }}>
                <div className="campaignListTitle" style={{display: 'flex', justifyContent: 'space-between', alignItems: 'center'}}>
                    <span style={{color: '#00FFFF'}}>{livePromo.content.title}</span> 
                    <span style={{fontSize: '12px', color: '#0A0A0A', backgroundColor: '#00FFFF', padding: '3px 8px', borderRadius: '10px', fontWeight: 'bold'}}>★ Promoted</span>
                </div>
                <p className="campaignListDescription" style={{ WebkitLineClamp: 2 }}>
                    Click to learn more.
                </p>
            </div>
        </div>
    );
};

                // ======================================================================
// ========= START: ADD THE NEW AdminOpportunityDetailsScreen COMPONENT =========
// ======================================================================

        const AdminOpportunityDetailsScreen = ({ showMessage, setActiveScreen, selectedOpportunity, setSelectedOpportunity }) => {
            const getStatusStyle = (status) => {
                switch (status) {
                    case 'active': return { color: '#00FF00', fontWeight: 'bold' };
                    case 'pending': return { color: '#FFD700', fontWeight: 'bold' };
                    case 'rejected': return { color: '#DC3545', fontWeight: 'bold' };
                    case 'expired': return { color: '#888', fontWeight: 'bold' };
                    default: return {};
                }
            };
            
            const handleReviewAction = async (action, functionName) => {
                showMessage(`Processing ${action}...`);
                try {
                    const reviewFunction = httpsCallable(functions, functionName);
                    const result = await reviewFunction({ opportunityId: selectedOpportunity.id });
                    showMessage(result.data.message);
                    setActiveScreen('AdminDashboard');
                } catch (error) {
                    showMessage(`Error: ${error.message}`);
                }
            };

            if (!selectedOpportunity) {
                return <div className="screenContainer"><p className="heading">Loading Opportunity...</p></div>;
            }
            
            return (
                <div className="screenContainer">
                    <div className="sectionHeaderWithButton" style={{ borderBottom: '1px solid #333', paddingBottom: '10px'}}>
                        <p className="heading" style={{margin: 0, textAlign: 'left'}}>Admin Review</p>
                        <span style={getStatusStyle(selectedOpportunity.status)}>
                            STATUS: {selectedOpportunity.status.toUpperCase()}
                        </span>
                    </div>

                    {/* Re-use the public details screen for a consistent look */}
                    <OpportunityDetailsScreen 
                        showMessage={showMessage} 
                        setActiveScreen={setActiveScreen} 
                        selectedOpportunity={selectedOpportunity} 
                    />

                    <div className="dashboardSection" style={{ border: '2px solid #FFD700' }}>
                        <p className="dashboardSectionTitle">Moderator Actions</p>
                        <div style={{ display: 'flex', justifyContent: 'space-around', marginTop: '20px' }}>
                            {/* Conditional Rendering of Buttons */}
                            {selectedOpportunity.status === 'pending' && (
                                <>
                                    <button className="adminActionButton approve" onClick={() => handleReviewAction('approval', 'approveOpportunity')}>Approve Listing</button>
                                    <button className="adminActionButton reject" onClick={() => handleReviewAction('rejection', 'rejectOpportunity')}>Reject Listing</button>
                                </>
                            )}
                            {selectedOpportunity.status === 'active' && (
                                <button className="adminActionButton" style={{backgroundColor: '#FF8C00'}} onClick={() => handleReviewAction('ending', 'endOpportunityByAdmin')}>End Listing Manually</button>
                            )}
                            {(selectedOpportunity.status === 'rejected' || selectedOpportunity.status === 'expired') && (
                                 <p className="dashboardItem">No actions available for this listing status.</p>
                            )}
                        </div>
                    </div>
                </div>
            );
        };



                    // ======================================================================
// ========= START: ADD THIS ENTIRE NEW COMPONENT =======================
// ======================================================================
const CompetitionHomeScreenBanner = ({ setActiveScreen }) => {
    const [liveCompetition, setLiveCompetition] = useState(null);
    const [countdown, setCountdown] = useState('');
    const [bannerText, setBannerText] = useState('');
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        const compRef = collection(db, "competitions");
        const q = query(
            compRef,
            where("status", "in", ["Accepting Entries", "Live Voting", "Judging", "Results Visible"]),
            orderBy("createdAt", "desc"),
            limit(1)
        );
        const unsubscribe = onSnapshot(q, (snapshot) => {
            if (!snapshot.empty) {
                setLiveCompetition({ id: snapshot.docs[0].id, ...snapshot.docs[0].data() });
            } else {
                setLiveCompetition(null);
            }
            setLoading(false);
        });
        return () => unsubscribe();
    }, []);

    useEffect(() => {
        if (!liveCompetition) {
            setCountdown('');
            setBannerText('');
            return;
        }

        const interval = setInterval(() => {
            const now = new Date();
            const entryDeadline = liveCompetition.entryDeadline?.toDate();
            const competitionEnd = liveCompetition.competitionEnd?.toDate();
            const resultsRevealTime = liveCompetition.resultsRevealTime?.toDate();

            // THIS IS THE FIX: We now derive the current state based on the current time,
            // making the banner text and countdown react instantly to deadlines.
            let currentStatus = liveCompetition.status;
            if (currentStatus === 'Accepting Entries' && entryDeadline && now > entryDeadline) currentStatus = 'Live Voting';
            if (currentStatus === 'Live Voting' && competitionEnd && now > competitionEnd) currentStatus = 'Judging';
            if (currentStatus === 'Judging' && resultsRevealTime && now > resultsRevealTime) currentStatus = 'Results Visible';

            let deadline = null;

            switch (currentStatus) {
                case 'Accepting Entries':
                    setBannerText("Entries close in");
                    deadline = entryDeadline;
                    break;
                case 'Live Voting':
                    setBannerText("Voting ends in");
                    deadline = competitionEnd;
                    break;
                case 'Judging':
                    if (resultsRevealTime) {
                        setBannerText("Results revealed in");
                        deadline = resultsRevealTime;
                    } else {
                        setBannerText("Judging in Progress");
                        setCountdown("Results Soon!");
                        return;
                    }
                    break;
                case 'Results Visible':
                    setBannerText("Results Are In!");
                    setCountdown("View Now!");
                    return;
                default:
                    setBannerText('');
                    setCountdown('');
                    return;
            }

            if (!deadline) {
                setCountdown('N/A');
                return;
            }

            const distance = deadline - now;
            if (distance < 0) {
                setCountdown("Time's Up!");
            } else {
                const days = Math.floor(distance / (1000 * 60 * 60 * 24));
                const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((distance % (1000 * 60)) / 1000);
                setCountdown(`${days}d ${hours}h ${minutes}m ${seconds}s`);
            }
        }, 1000);

        return () => clearInterval(interval);
    }, [liveCompetition]);

    if (loading || !liveCompetition) {
        return null;
    }

    return (
        <div
            onClick={() => setActiveScreen('CompetitionScreen')}
            className="header-live-button"
            style={{
                width: 'auto',
                maxWidth: '400px',
                backgroundColor: 'rgba(0, 255, 255, 0.8)',
                color: '#0A0A0A',
                cursor: 'pointer',
                justifyContent: 'center',
                margin: '0 auto 15px auto'
            }}
        >
            <span>🏆</span>
            <span>{liveCompetition.title}: {bannerText} {countdown}</span>
        </div>
    );
};
// ======================================================================
// =========== END: ADD THIS ENTIRE NEW COMPONENT =======================
// ======================================================================


        // ======================================================================
// ========= START: ADD THIS ENTIRE NEW COMPONENT =======================
// ======================================================================
const PrizesModal = ({ competition, onClose }) => {
    return (
        <div className="confirmationModalOverlay" style={{zIndex: 2500}}>
            <div className="confirmationModalContent" style={{textAlign: 'left', maxWidth: '500px'}}>
                <div style={{display: 'flex', justifyContent: 'space-between', alignItems: 'center'}}>
                    <p className="confirmationModalTitle">{competition.title}</p>
                    <button className="closeButton" onClick={onClose} style={{position: 'static'}}>×</button>
                </div>

                <div className="dashboardSection" style={{padding: '10px', border: '1px solid #00FFFF', margin: '15px 0'}}>
                    <p className="dashboardSectionTitle" style={{fontSize: '18px', color: '#00FFFF'}}>Prizes</p>
                    <p className="paragraph" style={{whiteSpace: 'pre-wrap', color: '#FFF'}}>
                        {competition.prizesText || "Prize information will be updated soon."}
                    </p>
                </div>

                <div className="dashboardSection" style={{padding: '10px', border: '1px solid #FFD700', margin: '15px 0'}}>
                    <p className="dashboardSectionTitle" style={{fontSize: '18px', color: '#FFD700'}}>Rules & Requirements</p>
                    <p className="paragraph" style={{whiteSpace: 'pre-wrap'}}>
                        {competition.rules || "No rules have been posted for this competition yet."}
                    </p>
                </div>
                
                <div className="confirmationModalButtons">
                    <button className="confirmationButton confirm" onClick={onClose}>
                        Close
                    </button>
                </div>
            </div>
        </div>
    );
};
// ======================================================================
// =========== END: ADD THIS ENTIRE NEW COMPONENT =======================
// ======================================================================


          // ======================================================================
// ========= START: ADD THIS ENTIRE NEW COMPONENT =======================
// ======================================================================
const CompetitionEntryForm = ({ competition, currentUser, creatorProfile, showMessage, onClose }) => {
    const [entryTitle, setEntryTitle] = useState('');
    const [contactNumber, setContactNumber] = useState('');
    const [bio, setBio] = useState('');
    const [submissionUrl, setSubmissionUrl] = useState('');
    const [agreedToTerms, setAgreedToTerms] = useState(false);
    const [isSubmitting, setIsSubmitting] = useState(false);

    // --- NEW UNIFIED STATE for all image sources ---
    const [photoFile, setPhotoFile] = useState(null);
    const [photoPreview, setPhotoPreview] = useState('');
    const [autoThumbnail, setAutoThumbnail] = useState('');
    const photoInputRef = useRef(null);

    // --- NEW STATE for Image Adjustment Modal ---
    const [showImageAdjustModal, setShowImageAdjustModal] = useState(false);
    const [imageFileToAdjust, setImageFileToAdjust] = useState(null);

    const handleFileSelect = (e) => {
        const file = e.target.files[0];
        if (file) {
            setImageFileToAdjust(file);
            setShowImageAdjustModal(true);
        }
    };
    const handleSaveAdjustedImage = (adjustedBlob) => {
        const newFile = new File([adjustedBlob], "competition_entry.png", { type: "image/png" });
        setPhotoFile(newFile);
        setPhotoPreview(URL.createObjectURL(newFile));
        setShowImageAdjustModal(false);
    };
    const handleCancelAdjust = () => {
        setImageFileToAdjust(null);
        setShowImageAdjustModal(false);
        if (photoInputRef.current) photoInputRef.current.value = null;
    };

    // Auto-fetch for Video/External types
    useEffect(() => {
        if (competition.competitionType === 'Photo' || !submissionUrl) {
            setAutoThumbnail('');
            return;
        }
        const handler = setTimeout(() => {
            const info = extractVideoInfo(submissionUrl);
            if (info && info.thumbnailUrl && info.thumbnailUrl !== GENERIC_THUMBNAIL_PLACEHOLDER) {
                setAutoThumbnail(info.thumbnailUrl);
            } else {
                setAutoThumbnail('');
            }
        }, 800);
        return () => clearTimeout(handler);
    }, [submissionUrl, competition.competitionType]);

    const handleSubmit = async (e) => {
        e.preventDefault();
        if (!agreedToTerms) { showMessage("You must agree to the competition terms."); return; }

        setIsSubmitting(true);
        showMessage("Submitting your entry...");
        
        let uploadedPhotoUrl = '';
        const isPhotoComp = competition.competitionType === 'Photo';
        const isVideoOrExternalComp = !isPhotoComp;
        const finalThumbnailPreview = photoPreview || autoThumbnail;

        // --- NEW, STRICT VALIDATION ---
        if (isPhotoComp && !photoFile) {
            showMessage("A photo upload is required for this competition.");
            setIsSubmitting(false); return;
        }
        if (isVideoOrExternalComp && !submissionUrl) {
            showMessage("A submission URL is required for this competition.");
            setIsSubmitting(false); return;
        }
        // For video comps, we now enforce a thumbnail
        if (isVideoOrExternalComp && !finalThumbnailPreview) {
             showMessage("Could not get a thumbnail from this URL. Please upload a custom image to proceed.");
             setIsSubmitting(false); return;
        }

        // --- UNIFIED UPLOAD LOGIC ---
        // Upload happens if it's a photo comp OR a video comp where the user provided a fallback image
        if (photoFile) {
            try {
                const filePath = `competition_entries/${competition.id}/${currentUser.uid}/${Date.now()}.png`;
                const storageRefPath = ref(storage, filePath);
                const snapshot = await uploadBytes(storageRefPath, photoFile);
                uploadedPhotoUrl = await getDownloadURL(snapshot.ref);
            } catch (error) {
                showMessage(`Photo upload failed: ${error.message}`);
                setIsSubmitting(false); return;
            }
        }
        
        try {
            const entryData = {
                competitionId: competition.id,
                title: entryTitle,
                contactNumber,
                bio,
                submissionUrl: submissionUrl,
                photoUrl: isPhotoComp ? uploadedPhotoUrl : (photoFile ? uploadedPhotoUrl : autoThumbnail)
            };

            const submitEntryFunction = httpsCallable(functions, 'submitCompetitionEntry');
            const result = await submitEntryFunction({ entryData });
            showMessage(result.data.message);
            onClose();
        } catch (error) {
            showMessage(`Submission failed: ${error.message}`);
        } finally {
            setIsSubmitting(false);
        }
    };
    
    const finalPreview = photoPreview || autoThumbnail;

    return (
        <div className="confirmationModalOverlay" style={{zIndex: 3000}}>
            <div className="confirmationModalContent" style={{textAlign: 'left', maxWidth: '500px'}}>
                <div style={{display: 'flex', justifyContent: 'space-between', alignItems: 'center'}}>
                    <p className="confirmationModalTitle">Enter: {competition.title}</p>
                    <button className="closeButton" onClick={onClose} style={{position: 'static'}}>×</button>
                </div>
                <form onSubmit={handleSubmit}>
                    <p className="subHeading" style={{textAlign: 'left', fontSize: '14px', margin: '0 0 15px 0'}}>Your entry will be publicly visible.</p>
                    
                    {competition.competitionType === 'Photo' && (
                         <div className="formGroup">
                            <label className="formLabel">Your Photo Submission (Required)</label>
                            <input type="file" ref={photoInputRef} onChange={handleFileSelect} accept="image/*" style={{display: 'none'}} required/>
                            <button type="button" className="button" onClick={() => photoInputRef.current.click()} style={{ width: '100%', backgroundColor: '#3A3A3A' }}><span className="buttonText light">Upload Photo</span></button>
                            {photoPreview && <img src={photoPreview} alt="Photo Preview" style={{maxWidth: '200px', borderRadius: '8px', marginTop: '10px'}} />}
                        </div>
                    )}

                    {(competition.competitionType === 'Video' || competition.competitionType === 'External') && (
                        <>
                            <div className="formGroup">
                                <label className="formLabel">Submission URL (Required)</label>
                                <input type="url" className="formInput" value={submissionUrl} onChange={e => setSubmissionUrl(e.target.value)} placeholder="https://youtube.com/your-video" required />
                            </div>
                            <div className="formGroup">
                                <label className="formLabel">Thumbnail</label>
                                <p className="smallText" style={{textAlign: 'left', color: '#AAA', marginTop: '5px'}}>We'll try to fetch one automatically. If we can't, please upload a custom image.</p>
                                <input type="file" ref={photoInputRef} onChange={handleFileSelect} accept="image/*" style={{display: 'none'}}/>
                                <button type="button" className="button" onClick={() => photoInputRef.current.click()} style={{ width: '100%', backgroundColor: '#3A3A3A' }}><span className="buttonText light">Upload Custom Thumbnail</span></button>
                                {finalPreview && <img src={finalPreview} alt="Thumbnail Preview" style={{maxWidth: '200px', borderRadius: '8px', marginTop: '10px'}} />}
                            </div>
                        </>
                    )}

                    <div className="formGroup"><label className="formLabel">Entry Title (Public)</label><input type="text" className="formInput" value={entryTitle} onChange={e => setEntryTitle(e.target.value)} placeholder="e.g., Sunset Over the Demerara" required /></div>
                    <div className="formGroup"><label className="formLabel">Contact Number (Mandatory)</label><input type="tel" className="formInput" value={contactNumber} onChange={e => setContactNumber(e.target.value)} placeholder="e.g., 592-600-1234" required /></div>
                    <div className="formGroup"><label className="formLabel">Brief Bio (Optional, Public)</label><textarea className="formTextarea" value={bio} onChange={e => setBio(e.target.value)} placeholder="Tell us about yourself or your entry." /></div>
                    <div className="formGroup"><div className="checkboxItem"><input type="checkbox" id="agreeCompTerms" checked={agreedToTerms} onChange={(e) => setAgreedToTerms(e.target.checked)} required /><label htmlFor="agreeCompTerms">I have read and agree to the competition rules.</label></div></div>

                    <div className="confirmationModalButtons">
                        <button type="button" className="confirmationButton cancel" onClick={onClose}>Cancel</button>
                        <button type="submit" className="confirmationButton confirm" disabled={isSubmitting}>{isSubmitting ? 'Submitting...' : 'Submit Entry'}</button>
                    </div>
                </form>
                 {showImageAdjustModal && imageFileToAdjust && (
                    <ProfilePictureAdjustModal
                        imageUrl={URL.createObjectURL(imageFileToAdjust)}
                        onSave={handleSaveAdjustedImage}
                        onCancel={handleCancelAdjust}
                        showMessage={showMessage}
                        isUploading={isSubmitting}
                    />
                )}
            </div>
        </div>
    );
};
// ======================================================================
// =========== END: ADD THIS ENTIRE NEW COMPONENT =======================
// ======================================================================  


// ======================================================================
// ========= START: ADD THIS ENTIRE NEW COMPONENT =======================
// ======================================================================
const CompetitionScreen = ({ showMessage, setActiveScreen, currentUser, creatorProfile }) => {
    const [competition, setCompetition] = useState(null);
    const [loading, setLoading] = useState(true);
    const [searchTerm, setSearchTerm] = useState('');
    const [showPrizesModal, setShowPrizesModal] = useState(false);
    const [showEntryForm, setShowEntryForm] = useState(false);
    const [entries, setEntries] = useState([]);
    const [loadingEntries, setLoadingEntries] = useState(true);
    const [selectedEntry, setSelectedEntry] = useState(null);
    const [resultsCountdown, setResultsCountdown] = useState('');

    useEffect(() => {
        setLoading(true);
        const compRef = collection(db, "competitions");
        const q = query(
            compRef,
            where("status", "in", ["Accepting Entries", "Live Voting", "Judging", "Results Visible"]),
            orderBy("createdAt", "desc"),
            limit(1)
        );
        const unsubscribe = onSnapshot(q, (snapshot) => {
            if (!snapshot.empty) {
                setCompetition({ id: snapshot.docs[0].id, ...snapshot.docs[0].data() });
            } else {
                setCompetition(null);
            }
            setLoading(false);
        });
        return () => unsubscribe();
    }, []);

    useEffect(() => {
        if (!competition) {
            setEntries([]);
            setLoadingEntries(false);
            return;
        }
        setLoadingEntries(true);
        const entriesRef = collection(db, "competitions", competition.id, "entries");
        const q = query(entriesRef, orderBy("createdAt", "desc"));
        const unsubscribe = onSnapshot(q, (snapshot) => {
            setEntries(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
            setLoadingEntries(false);
        });
        return () => unsubscribe();
    }, [competition]);
    
    useEffect(() => {
        if (competition?.status !== 'Judging' || !competition.resultsRevealTime) {
            setResultsCountdown('');
            return;
        }
        const interval = setInterval(() => {
            const now = new Date();
            const targetDate = competition.resultsRevealTime.toDate();
            const distance = targetDate - now;
            if (distance < 0) {
                setResultsCountdown("Revealing results now...");
                clearInterval(interval);
            } else {
                const days = Math.floor(distance / (1000 * 60 * 60 * 24));
                const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((distance % (1000 * 60)) / 1000);
                setResultsCountdown(`${days}d ${hours}h ${minutes}m ${seconds}s`);
            }
        }, 1000);
        return () => clearInterval(interval);
    }, [competition]);

    const rankedEntries = useMemo(() => {
        return entries
            .filter(entry => entry.title.toLowerCase().includes(searchTerm.toLowerCase()) || entry.userName.toLowerCase().includes(searchTerm.toLowerCase()))
            .sort((a, b) => {
                const scoreA = (a.likeCount || 0) * 5 + (a.viewCount || 0);
                const scoreB = (b.likeCount || 0) * 5 + (b.viewCount || 0);
                return scoreB - scoreA;
            });
    }, [entries, searchTerm]);

    // --- ENHANCED STATUS FLAGS WITH REAL-TIME DERIVATION ---
    const now = new Date();
    let derivedStatus = competition?.status;
    if (derivedStatus === 'Accepting Entries' && competition?.entryDeadline?.toDate() < now) derivedStatus = 'Live Voting';
    if (derivedStatus === 'Live Voting' && competition?.competitionEnd?.toDate() < now) derivedStatus = 'Judging';
    if (derivedStatus === 'Judging' && competition?.resultsRevealTime?.toDate() < now) derivedStatus = 'Results Visible';
    
    const isAcceptingEntries = derivedStatus === 'Accepting Entries';
    const isLiveVoting = derivedStatus === 'Live Voting';
    const isJudging = derivedStatus === 'Judging';
    const isResultsView = derivedStatus === 'Results Visible';
    const isEntryDisabled = !isAcceptingEntries;

    if (loading) {
        return <div className="screenContainer" style={{textAlign: 'center'}}><p className="heading">Loading Competition...</p></div>;
    }

    if (!competition) {
        return (
            <div className="screenContainer" style={{textAlign: 'center', paddingTop: '50px'}}>
                <p className="heading">No Active Competition</p>
                <p className="subHeading">There is no competition running at the moment. Please check back later!</p>
                 <button className="button" onClick={() => setActiveScreen('Home')} style={{ backgroundColor: '#3A3A3A' }}>
                    <span className="buttonText light">Back to Home</span>
                </button>
            </div>
        );
    }

    return (
        <div className="screenContainer" style={{ display: 'flex', flexDirection: 'column', height: '100%' }}>
            <div style={{ flexShrink: 0, paddingBottom: '10px' }}>
                <div style={{ display: 'flex', alignItems: 'center', marginBottom: '10px' }}>
                    <button 
                        onClick={() => setActiveScreen('Home')} 
                        style={{ background: 'none', border: '1px solid #00FFFF', color: '#00FFFF', borderRadius: '50%', width: '40px', height: '40px', display: 'flex', alignItems: 'center', justifyContent: 'center', cursor: 'pointer', marginRight: '15px' }}
                    >
                        &#x2190;
                    </button>
                    <p className="heading" style={{ margin: 0, textAlign: 'center', flexGrow: 1, color: '#00FFFF' }}>{competition.title}</p>
                    <div style={{ width: '40px' }}></div>
                </div>

                {competition.noticeText && (
                    <div className="dashboardSection" style={{padding: '10px', border: '1px solid #FFD700', margin: '0 0 10px 0'}}>
                        <p className="dashboardSectionTitle" style={{fontSize: '14px', marginBottom: '5px'}}>Notice</p>
                        <p className="dashboardItem" style={{fontSize: '12px', color: '#CCC', margin: 0, whiteSpace: 'pre-wrap'}}>{competition.noticeText}</p>
                    </div>
                )}
                <div className="formGroup" style={{marginBottom: '10px'}}>
                    <input type="text" className="formInput" placeholder="Search entries by name or title..." value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} />
                </div>
                <div style={{display: 'flex', gap: '10px'}}>
                    <button 
                        className="button" 
                        onClick={() => {
                            if (!currentUser) { showMessage("Please log in to enter the competition."); setActiveScreen('Login'); return; }
                            if (!isAcceptingEntries) { showMessage("This competition is no longer accepting new entries."); return; }
                            setShowEntryForm(true);
                        }} 
                        style={{flex: 1, margin: 0, ...(isEntryDisabled && { backgroundColor: '#555', color: '#AAA', cursor: 'default' })}}
                        disabled={isEntryDisabled}
                    >
                        <span className="buttonText">{isResultsView ? 'Results Are Final' : (isAcceptingEntries ? 'Enter Competition' : 'Entries Closed')}</span>
                    </button>
                    <button className="button" onClick={() => setShowPrizesModal(true)} style={{flex: 1, margin: 0, backgroundColor: '#3A3A3A'}}>
                        <span className="buttonText light">View Prizes & Rules</span>
                    </button>
                </div>
            </div>

            <div style={{ flex: '1 1 auto', overflowY: 'auto', paddingTop: '15px' }}>
                {isJudging ? (
                    <div style={{textAlign: 'center', paddingTop: '50px'}}>
                        <p className="heading">Judging In Progress</p>
                        {resultsCountdown ? (
                            <><p className="subHeading">Results will be revealed in:</p><p className="heading" style={{color: '#FFD700', fontSize: '28px'}}>{resultsCountdown}</p></>
                        ) : (
                            <p className="subHeading">The competition has ended. Results will be out soon!</p>
                        )}
                    </div>
                ) : loadingEntries ? (
                    <p className="dashboardItem" style={{textAlign: 'center'}}>Loading entries...</p>
                ) : rankedEntries.length === 0 ? (
                    <p className="dashboardItem" style={{textAlign: 'center'}}>
                        {searchTerm ? `No entries match "${searchTerm}".` : "No entries have been submitted yet. Be the first!"}
                    </p>
                ) : (
                    <div className="allCampaignsList">
                        {rankedEntries.map((entry, index) => {
                            // THIS IS THE FIX #3: An entry is now ONLY clickable during Live Voting.
                            const isClickable = isLiveVoting;
                            return (
                                <div 
                                    key={entry.id} 
                                    className="allCampaignsListItem" 
                                    style={{
                                        borderLeft: '5px solid #00FFFF', 
                                        position: 'relative', 
                                        cursor: isClickable ? 'pointer' : 'default',
                                        // THIS IS THE FIX #2: The opacity style has been removed.
                                    }}
                                    onClick={() => {
                                        if (!isClickable) return;
                                        if (!currentUser) { showMessage("Please log in or sign up to view entries."); setActiveScreen('Login'); return; }
                                        setSelectedEntry(entry);
                                    }}
                                >
                                    <div style={{position: 'absolute', top: '-1px', left: '-1px', backgroundColor: '#00FFFF', color: '#0A0A0A', padding: '5px 10px', borderTopLeftRadius: '8px', borderBottomRightRadius: '8px', fontWeight: 'bold'}}>
                                        #{index + 1}
                                    </div>
                                    <img src={entry.photoUrl || entry.userProfilePicture} alt={entry.title} className="creator-campaign-thumbnail" style={{width: '120px', height: '70px', objectFit: 'cover'}}/>
                                    <div className="campaignListContent">
                                        <p className="campaignListTitle" style={{color: '#FFF'}}>{entry.title}</p>
                                        <div className="campaignListCreator">
                                            <img src={entry.userProfilePicture || 'https://placehold.co/24x24/555/FFF?text=P'} alt={entry.userName} className="campaignListCreatorProfilePic"/>
                                            <span>by {entry.userName}</span>
                                        </div>
                                        <div className="campaignListStats" style={{display: 'flex', justifyContent: 'space-between', alignItems: 'center'}}>
                                            <div>
                                                <span>Likes: <span className="campaignListGoal">{entry.likeCount || 0}</span></span>
                                                {competition.competitionType === 'Video' && (
                                                    <span style={{marginLeft: '10px'}}>Views: <span className="campaignListRaised">{entry.viewCount || 0}</span></span>
                                                )}
                                            </div>
                                            {isLiveVoting && (
                                                <CompetitionLikeButton competition={competition} entry={entry} currentUser={currentUser} showMessage={showMessage} />
                                            )}
                                        </div>
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                )}
            </div>

            {showPrizesModal && <PrizesModal competition={competition} onClose={() => setShowPrizesModal(false)} />}
            {showEntryForm && <CompetitionEntryForm competition={competition} currentUser={currentUser} creatorProfile={creatorProfile} showMessage={showMessage} onClose={() => setShowEntryForm(false)} />}
            {selectedEntry && <EnlargedPhotoViewer competition={competition} entry={selectedEntry} currentUser={currentUser} showMessage={showMessage} onClose={() => setSelectedEntry(null)} />}
        </div>
    );
};
// ======================================================================
// =========== END: ADD THIS ENTIRE NEW COMPONENT =======================
// ======================================================================

                // ======================================================================
// ========= START: ADD THIS ENTIRE NEW COMPONENT =======================
// ======================================================================
const CompetitionLikeButton = ({ competition, entry, currentUser, showMessage }) => {
    const [isLiked, setIsLiked] = useState(false);
    const [likeCount, setLikeCount] = useState(entry.likeCount || 0);
    const [isLoading, setIsLoading] = useState(true);
    const [isProcessing, setIsProcessing] = useState(false);

    useEffect(() => {
        if (!currentUser) {
            setIsLoading(false);
            return;
        }
        const likeRef = doc(db, `competitions/${competition.id}/entries/${entry.id}/likes`, currentUser.uid);
        const unsubscribeLike = onSnapshot(likeRef, (docSnap) => {
            setIsLiked(docSnap.exists());
            setIsLoading(false);
        });

        // Also listen to the main entry document for live like count updates
        const entryRef = doc(db, `competitions/${competition.id}/entries/${entry.id}`);
        const unsubscribeEntry = onSnapshot(entryRef, (docSnap) => {
            if (docSnap.exists()) {
                setLikeCount(docSnap.data().likeCount || 0);
            }
        });

        return () => {
            unsubscribeLike();
            unsubscribeEntry();
        };
    }, [competition.id, entry.id, currentUser]);

    const handleLike = async (e) => {
        e.stopPropagation();
        if (!currentUser) { showMessage("Please log in to like entries."); return; }
        if (isLoading || isProcessing) return;

        setIsProcessing(true);
        const newLikedState = !isLiked;
        
        // Optimistic UI update
        setIsLiked(newLikedState);
        setLikeCount(prev => newLikedState ? prev + 1 : prev - 1);

        try {
            const likeFunction = httpsCallable(functions, 'incrementCompetitionLike');
            await likeFunction({
                competitionId: competition.id,
                entryId: entry.id,
                isLiking: newLikedState
            });
        } catch (error) {
            showMessage(`Error: ${error.message}`);
            // Revert optimistic update on failure
            setIsLiked(!newLikedState);
            setLikeCount(prev => newLikedState ? prev - 1 : prev + 1);
        } finally {
            setIsProcessing(false);
        }
    };

    return (
        <button
            onClick={handleLike}
            disabled={isLoading || isProcessing}
            className="like-button" // We can reuse some styling if a global class exists
            style={{
                background: 'rgba(10, 10, 10, 0.7)',
                border: '1px solid #00FFFF',
                borderRadius: '50px',
                padding: '0 10px',
                height: '32px',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                gap: '6px',
                cursor: 'pointer'
            }}
        >
            <svg viewBox="0 0 24 24" style={{ width: '18px', height: '18px', fill: isLiked ? '#00FFFF' : '#FFF' }}>
                <path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"></path>
            </svg>
            <span style={{ color: '#FFF', fontSize: '12px', fontWeight: 'bold' }}>{likeCount}</span>
        </button>
    );
};
// ======================================================================
// =========== END: ADD THIS ENTIRE NEW COMPONENT =======================
// ======================================================================


                   // ======================================================================
// ========= START: ADD THIS ENTIRE NEW COMPONENT =======================
// ======================================================================
const EnlargedPhotoViewer = ({ competition, entry, currentUser, showMessage, onClose }) => {
    const viewCountedRef = useRef(false);

    useEffect(() => {
        if (competition.competitionType !== 'Video' || !currentUser) return;
        if (currentUser.uid === entry.userId) {
            console.log("Creator is viewing their own entry. View will not be counted.");
            return;
        }
        const timer = setTimeout(() => {
            if (viewCountedRef.current) return;
            viewCountedRef.current = true;
            const viewFunction = httpsCallable(functions, 'incrementCompetitionView');
            viewFunction({ competitionId: competition.id, entryId: entry.id })
                .catch(err => console.error("Failed to increment view count:", err.message));
        }, 10000);
        return () => clearTimeout(timer);
    }, [competition, entry, currentUser]);

    const handleOverlayClick = (e) => {
        if (e.target === e.currentTarget) {
            onClose();
        }
    };
    
    // THIS IS THE CRITICAL FIX: We now check isVertical for the video entry
    const { embedUrl, isVertical } = extractVideoInfo(entry.submissionUrl);

    let contentElement;
    if (competition.competitionType === 'Photo') {
        contentElement = <img src={entry.photoUrl} alt={entry.title} className="pfpModalImage" />;
    } else if (competition.competitionType === 'Video') {
        contentElement = (
            // The 'vertical' class will now be correctly applied here
            <div className={`videoIframeContainer ${isVertical ? 'vertical' : ''}`}>
                <iframe
                    src={embedUrl ? `${embedUrl}?autoplay=1` : entry.submissionUrl}
                    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
                    allowFullScreen
                    title={entry.title}
                ></iframe>
            </div>
        );
    } else {
        contentElement = (
             <div style={{textAlign: 'center', padding: '20px'}}>
                <p className="heading">External Link</p>
                <p className="subHeading">Click the button below to visit the submission.</p>
                <a href={entry.submissionUrl} target="_blank" rel="noopener noreferrer" className="button">
                    <span className="buttonText">Visit Link</span>
                </a>
            </div>
        );
    }

    return (
        <div className="videoModalOverlay" onClick={handleOverlayClick}>
             {/* The 'vertical' class will also be correctly applied here */}
            <div className={`videoModalContent ${isVertical ? 'vertical' : ''}`}>
                <button className="closeButton" onClick={onClose}>×</button>
                {contentElement}
                <div style={{ position: 'absolute', bottom: '20px', right: '15px' }}>
                    <CompetitionLikeButton 
                        competition={competition}
                        entry={entry}
                        currentUser={currentUser}
                        showMessage={showMessage}
                    />
                </div>
            </div>
        </div>
    );
};
// ======================================================================
// =========== END: ADD THIS ENTIRE NEW COMPONENT =======================
// ====================================================================== 


// ======================================================================
// ========== END: ADD THE NEW AdminOpportunityDetailsScreen COMPONENT ==========
// ======================================================================

                        const AdminStatusReviewScreen = ({ showMessage, setActiveScreen, selectedStatus, setSelectedStatus }) => {
    const handleReviewAction = async (action) => {
        const functionName = action === 'approve' ? 'approveStatusContent' : 'rejectStatusContent'; // We'll need to create rejectStatusContent
        showMessage(`Processing ${action}...`);
        try {
            const reviewFunction = httpsCallable(functions, functionName);
            const result = await reviewFunction({ bookingId: selectedStatus.id });
            showMessage(result.data.message);
            setActiveScreen('AdminDashboard');
        } catch (error) {
            showMessage(`Error: ${error.message}`);
        }
    };

    if (!selectedStatus) {
        return <div className="screenContainer"><p className="heading">Loading Booking Details...</p></div>;
    }
    
    const { content } = selectedStatus;

    return (
        <div className="screenContainer">
            <p className="heading">Review Billboard Content</p>
            <p className="subHeading">Booking for: {new Date(selectedStatus.startTime.toDate()).toLocaleDateString()}</p>
            
            <div className="dashboardSection">
                <p className="dashboardSectionTitle">Submitted Ad Details</p>
                <p className="dashboardItem"><strong>Ad Title:</strong> {content.title}</p>
                <p className="dashboardItem"><strong>Destination URL:</strong> <a href={content.destinationUrl} target="_blank" className="termsLink">{content.destinationUrl}</a></p>
                <p className="dashboardItem"><strong>Ad Video URL:</strong> {content.adVideoUrl ? <a href={content.adVideoUrl} target="_blank" className="termsLink">{content.adVideoUrl}</a> : "Not Provided"}</p>
                {content.flyerImageUrl && (
                    <div style={{marginTop: '15px'}}>
                        <p className="formLabel"><strong>Submitted Flyer / Thumbnail:</strong></p>
                        <img src={content.flyerImageUrl} alt="Ad Flyer" style={{maxWidth: '100%', borderRadius: '8px', marginTop: '5px'}}/>
                    </div>
                )}
            </div>

            <div className="dashboardSection" style={{ border: '2px solid #FFD700' }}>
                <p className="dashboardSectionTitle">Moderator Actions</p>
                <div style={{ display: 'flex', justifyContent: 'space-around', marginTop: '20px' }}>
                    <button className="adminActionButton reject" onClick={() => handleReviewAction('reject')}>Reject Content</button>
                    <button className="adminActionButton approve" onClick={() => handleReviewAction('approve')}>Approve & Schedule</button>
                </div>
            </div>
             <button className="button" onClick={() => setActiveScreen('AdminDashboard')} style={{ backgroundColor: '#3A3A3A', marginTop: '30px' }}>
                <span className="buttonText light">Back to Admin Dashboard</span>
            </button>
        </div>
    );
};

// ======================================================================
// ========= START: ADD THIS ENTIRE NEW ProfilePictureModal COMPONENT =========
// ======================================================================

const ProfilePictureModal = ({ imageUrl, onClose }) => {
    // This allows the user to click the background to close, but not the image itself.
    const handleOverlayClick = (e) => {
        if (e.target === e.currentTarget) {
            onClose();
        }
    };

    return (
        <div className="pfpModalOverlay" onClick={handleOverlayClick}>
            <div className="pfpModalContent">
                <img src={imageUrl} alt="Enlarged profile picture" className="pfpModalImage" />
                <button className="closeButton" onClick={onClose}>×</button>
            </div>
        </div>
    );
};

// ======================================================================
// ========== END: ADD THIS ENTIRE NEW ProfilePictureModal COMPONENT ==========
// ======================================================================


        // REPLACE THE ENTIRE AdminCategoryManagerScreen COMPONENT WITH THIS FINAL VERSION
        const AdminCategoryManagerScreen = ({
    showMessage,
    setActiveScreen,
    setShowConfirmationModal,
    setConfirmationTitle,
    setConfirmationMessage,
    setOnConfirmationAction
}) => {
    const [categories, setCategories] = useState([]);
    const [loading, setLoading] = useState(true);
    const [newCategoryName, setNewCategoryName] = useState('');
    const [newCategoryOrder, setNewCategoryOrder] = useState(100);
    const [editingCategory, setEditingCategory] = useState(null);

    // State for Live Premiere Management
    const [liveCategoryDoc, setLiveCategoryDoc] = useState(null);
    const [liveUrlInput, setLiveUrlInput] = useState('');
    const [liveStartTimeInput, setLiveStartTimeInput] = useState('');
    const [liveEventId, setLiveEventId] = useState('');
    const [liveEventTitle, setLiveEventTitle] = useState('');
    const [liveEventDescription, setLiveEventDescription] = useState('');
    const [isTicketedEvent, setIsTicketedEvent] = useState(false); // NEW STATE
    const [ticketPrice, setTicketPrice] = useState(5.00); // NEW STATE
    
    const [liveCustomThumbnailFile, setLiveCustomThumbnailFile] = useState(null);
    const [liveCustomThumbnailPreview, setLiveCustomThumbnailPreview] = useState('');
    const [liveAutoThumbnailPreview, setLiveAutoThumbnailPreview] = useState('');
    const liveThumbnailInputRef = useRef(null);
    const [isSaving, setIsSaving] = useState(false);

    // State for Box Office Stats
    const [boxOfficeStats, setBoxOfficeStats] = useState({ ticketsSold: 0, totalRevenue: 0 });
    const [recentPurchases, setRecentPurchases] = useState([]);
    const [loadingStats, setLoadingStats] = useState(true);

    useEffect(() => {
        const categoriesRef = collection(db, "content_categories");
        const q = query(categoriesRef, orderBy("orderIndex", "asc"));
        const unsubscribe = onSnapshot(q, (snapshot) => {
            const fetchedCategories = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            setCategories(fetchedCategories);
            const liveDoc = fetchedCategories.find(cat => cat.name === 'Live Premieres');
            if (liveDoc) {
                setLiveCategoryDoc(liveDoc);
                setLiveUrlInput(liveDoc.liveStreamUrl || '');
                setLiveCustomThumbnailPreview(liveDoc.liveStreamThumbnailUrl || '');
                setLiveEventId(liveDoc.liveStreamEventId || '');
                setLiveEventTitle(liveDoc.liveStreamEventTitle || '');
                setLiveEventDescription(liveDoc.liveStreamEventDescription || '');
                setIsTicketedEvent(liveDoc.isTicketedEvent || false); // NEW
                setTicketPrice(liveDoc.ticketPrice || 5.00); // NEW
                if (liveDoc.liveStreamStartTime) {
                    const date = liveDoc.liveStreamStartTime.toDate();
                    date.setMinutes(date.getMinutes() - date.getTimezoneOffset());
                    setLiveStartTimeInput(date.toISOString().slice(0, 16));
                } else {
                    setLiveStartTimeInput('');
                }
            }
            setLoading(false);
        });
        return () => unsubscribe();
    }, []);

    useEffect(() => {
        if (!liveEventId) {
            setBoxOfficeStats({ ticketsSold: 0, totalRevenue: 0 });
            setRecentPurchases([]);
            setLoadingStats(false);
            return;
        }
        setLoadingStats(true);
        const statsDocRef = doc(db, "statistics", "events", "data", liveEventId);
        const purchasesRef = collection(db, "statistics", "events", "data", liveEventId, "recentPurchases");
        const qPurchases = query(purchasesRef, orderBy("approvedAt", "desc"), limit(5));
        const unsubscribeStats = onSnapshot(statsDocRef, (docSnap) => { if (docSnap.exists()) { setBoxOfficeStats(docSnap.data()); } else { setBoxOfficeStats({ ticketsSold: 0, totalRevenue: 0 }); } setLoadingStats(false); });
        const unsubscribePurchases = onSnapshot(qPurchases, (snapshot) => { setRecentPurchases(snapshot.docs.map(doc => doc.data())); });
        return () => { unsubscribeStats(); unsubscribePurchases(); };
    }, [liveEventId]);

    useEffect(() => { if (!liveUrlInput) { setLiveAutoThumbnailPreview(''); return; } const handler = setTimeout(() => { const { thumbnailUrl } = extractVideoInfo(liveUrlInput); setLiveAutoThumbnailPreview(thumbnailUrl || ''); }, 500); return () => clearTimeout(handler); }, [liveUrlInput]);
    const handlePremiereThumbFileChange = (e) => { const file = e.target.files[0]; if (file) { setLiveCustomThumbnailFile(file); setLiveCustomThumbnailPreview(URL.createObjectURL(file)); } };
    
    const handleSetLiveEvent = async () => {
        setIsSaving(true);
        const liveDocRef = doc(db, "content_categories", liveCategoryDoc.id);
        let updatedData = {
            liveStreamUrl: liveUrlInput,
            liveStreamStartTime: liveStartTimeInput ? new Date(liveStartTimeInput) : null,
            liveStreamEventId: liveEventId.trim(),
            liveStreamEventTitle: liveEventTitle.trim(),
            liveStreamEventDescription: liveEventDescription.trim(),
            isTicketedEvent: isTicketedEvent, // NEW
            ticketPrice: parseFloat(ticketPrice), // NEW
            liveStreamThumbnailUrl: liveCustomThumbnailPreview || liveAutoThumbnailPreview || ''
        };
        if (liveCustomThumbnailFile) { try { showMessage("Uploading..."); const filePath = `premiere_thumbnails/${Date.now()}_${liveCustomThumbnailFile.name}`; const storageRef = ref(storage, filePath); const snapshot = await uploadBytes(storageRef, liveCustomThumbnailFile); updatedData.liveStreamThumbnailUrl = await getDownloadURL(snapshot.ref); } catch (error) { showMessage(`Upload failed: ${error.message}`); setIsSaving(false); return; } }
        try { await updateDoc(liveDocRef, updatedData); showMessage("Live Premiere Event has been updated!"); } catch (error) { showMessage(`Error: ${error.message}`); } 
        finally { setLiveCustomThumbnailFile(null); if (liveThumbnailInputRef.current) liveThumbnailInputRef.current.value = ''; setIsSaving(false); }
    };

    const handleClearLiveEvent = async () => { setIsSaving(true); try { await updateDoc(doc(db, "content_categories", liveCategoryDoc.id), { liveStreamUrl: '', liveStreamStartTime: null, liveStreamThumbnailUrl: '', liveStreamEventId: '', liveStreamEventTitle: '', liveStreamEventDescription: '', isTicketedEvent: false }); showMessage("Live Premiere has been cleared."); } catch (error) { showMessage(`Error: ${error.message}`); } finally { setIsSaving(false); } };
    const handleAddCategory = async (e) => { e.preventDefault(); if (!newCategoryName.trim()) return; try { await addDoc(collection(db, "content_categories"), { name: newCategoryName.trim(), orderIndex: parseInt(newCategoryOrder, 10), isActive: true, createdAt: new Date().toISOString() }); setNewCategoryName(''); setNewCategoryOrder(100); } catch (error) { showMessage(`Error: ${error.message}`); } };
    const deleteLogic = async (cat) => { try { await deleteDoc(doc(db, "content_categories", cat.id)); showMessage(`Category "${cat.name}" deleted.`); } catch (error) { showMessage(`Error: ${error.message}`); } };
    const handleDeleteCategory = (category) => { if (category.name === "Live Premieres") { showMessage("This category cannot be deleted."); return; } setConfirmationTitle("Delete Category?"); setConfirmationMessage(`Are you sure you want to permanently delete "${category.name}"?`); setOnConfirmationAction(() => () => deleteLogic(category)); setShowConfirmationModal(true); };
    const handleToggleActive = async (category) => { try { await updateDoc(doc(db, "content_categories", category.id), { isActive: !category.isActive }); } catch (error) { showMessage(`Error: ${error.message}`); } };
    const handleSaveEdit = async () => { try { await updateDoc(doc(db, "content_categories", editingCategory.id), { name: editingCategory.name, orderIndex: parseInt(editingCategory.orderIndex, 10) }); setEditingCategory(null); } catch (error) { showMessage(`Error: ${error.message}`); } };
    const finalThumbnailPreview = liveCustomThumbnailPreview || liveAutoThumbnailPreview;

    return (
        <div className="screenContainer">
            <p className="heading">Manage Categories</p>
            <p className="subHeading">Control the tabs for the Discover screen and manage live events.</p>
            <div className="dashboardSection" style={{border: '2px solid #FFD700'}}><p className="dashboardSectionTitle">Live Premiere Event Hub</p>
                 {loading ? <p>Loading controls...</p> : (
                    <div style={{display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '20px'}}>
                        <div> {/* Column 1: Event Setup */}
                            <p className="dashboardSectionTitle" style={{fontSize: '16px', color: '#FFF'}}>Event Setup</p>
                            <div className="adminDashboardItem" style={{flexDirection: 'column', alignItems: 'stretch', gap: '10px'}}><p className="formLabel" style={{marginBottom: 0}}>Enable Ticket Sales</p><label className="flex items-center cursor-pointer"><span className="mr-3 text-sm font-medium text-gray-300">{isTicketedEvent ? 'Enabled' : 'Disabled'}</span><div className="relative"><input type="checkbox" className="sr-only" checked={isTicketedEvent} onChange={(e) => setIsTicketedEvent(e.target.checked)} /><div className={`block w-14 h-8 rounded-full ${isTicketedEvent ? 'bg-green-500' : 'bg-gray-600'}`}></div><div className={`dot absolute left-1 top-1 bg-white w-6 h-6 rounded-full transition-transform ${isTicketedEvent ? 'transform translate-x-6' : ''}`}></div></div></label></div>
                            <div className="adminDashboardItem" style={{marginTop: '10px'}}><p className="formLabel" style={{marginBottom: 0, flexGrow: 1}}>Ticket Price (USD)</p><input type="number" className="formInput" value={ticketPrice} onChange={(e) => setTicketPrice(e.target.value)} style={{width: '100px', textAlign: 'right'}} disabled={!isTicketedEvent}/></div>
                            <div className="formGroup"><label className="formLabel">Event ID (Internal, No Spaces):</label><input type="text" className="formInput" value={liveEventId} onChange={(e) => setLiveEventId(e.target.value)} placeholder="e.g., SUMMER_SLAM_2025"/></div>
                            <div className="formGroup"><label className="formLabel">Event Title (Public):</label><input type="text" className="formInput" value={liveEventTitle} onChange={(e) => setLiveEventTitle(e.target.value)} placeholder="e.g., NVA Summer Comedy Slam"/></div>
                            <div className="formGroup"><label className="formLabel">Event Description (Public):</label><textarea className="formTextarea" style={{minHeight: '60px'}} value={liveEventDescription} onChange={(e) => setLiveEventDescription(e.target.value)} placeholder="A short, catchy description."></textarea></div>
                            <div className="formGroup"><label className="formLabel">Scheduled Start Time:</label><input type="datetime-local" className="formInput" value={liveStartTimeInput} onChange={(e) => setLiveStartTimeInput(e.target.value)} /></div>
                            <div className="formGroup"><label className="formLabel">Embed URL:</label><input type="url" className="formInput" value={liveUrlInput} onChange={(e) => setLiveUrlInput(e.target.value)} /></div>
                            <div className="formGroup"><label className="formLabel">Thumbnail Preview:</label>{finalThumbnailPreview ? <img src={finalThumbnailPreview} alt="Premiere thumbnail" style={{maxWidth: '200px', borderRadius: '8px', margin: '10px 0', border: '1px solid #444'}}/> : <p className="smallText" style={{textAlign: 'left', color: '#AAA'}}>Paste URL or upload image.</p>}<input type="file" ref={liveThumbnailInputRef} onChange={handlePremiereThumbFileChange} accept="image/*" style={{display: 'none'}} /><button type="button" className="button" style={{backgroundColor: '#3A3A3A', width: 'auto'}} onClick={() => liveThumbnailInputRef.current.click()}><span className="buttonText">Upload Image</span></button></div>
                            <div className="flex gap-4 mt-4"><button onClick={handleSetLiveEvent} className="button" disabled={isSaving}><span className="buttonText">{isSaving ? 'Saving...' : 'Save Event Settings'}</span></button><button onClick={handleClearLiveEvent} className="button" style={{backgroundColor: '#555'}} disabled={isSaving}><span className="buttonText">{isSaving ? 'Clearing...' : 'Clear All'}</span></button></div>
                        </div>
                        <div> {/* Column 2: Box Office Stats */}
                            <p className="dashboardSectionTitle" style={{fontSize: '16px', color: '#FFF'}}>Box Office: <span style={{color: '#FFD700'}}>{liveEventTitle || 'No Event Set'}</span></p>
                            {loadingStats ? <p>Loading stats...</p> : (<>
                                <div className="adminDashboardItem" style={{flexDirection: 'column', alignItems: 'flex-start', background: '#1A1A1A'}}><p className="dashboardItem" style={{fontSize: '12px', color: '#AAA'}}>Total Tickets Sold</p><p className="premiumFeatureTitle" style={{fontSize: '28px'}}>{(boxOfficeStats.ticketsSold || 0).toLocaleString()}</p></div>
                                <div className="adminDashboardItem" style={{flexDirection: 'column', alignItems: 'flex-start', background: '#1A1A1A', marginTop: '10px'}}><p className="dashboardItem" style={{fontSize: '12px', color: '#AAA'}}>Total Gross Revenue (USD)</p><p className="premiumFeatureTitle" style={{fontSize: '28px'}}>${(boxOfficeStats.totalRevenue || 0).toFixed(2)}</p></div>
                                <p className="dashboardSectionTitle" style={{fontSize: '14px', color: '#FFF', marginTop: '20px'}}>Recent Purchases</p>
                                <div className="dashboardContentList">{recentPurchases.length === 0 ? <p className="dashboardItem">No recent purchases for this event.</p> : recentPurchases.map(p => (<div key={p.pledgeId} className="dashboardContentListItem" style={{fontSize: '12px'}}><span>{p.userName}</span><span style={{color: '#AAA'}}>{new Date(p.approvedAt.toDate()).toLocaleString()}</span></div>))}</div>
                            </>)}
                        </div>
                    </div>
                )}
            </div>
            <div className="dashboardSection"><p className="dashboardSectionTitle">Add New Category</p><form onSubmit={handleAddCategory} className="flex items-end gap-4"><div className="formGroup flex-grow mb-0"><label className="formLabel">Category Name:</label><input type="text" className="formInput" value={newCategoryName} onChange={(e) => setNewCategoryName(e.target.value)} required /></div><div className="formGroup mb-0"><label className="formLabel">Order:</label><input type="number" className="formInput" value={newCategoryOrder} onChange={(e) => setNewCategoryOrder(e.target.value)} style={{width: '80px'}} /></div><button type="submit" className="button m-0"><span className="buttonText">Add</span></button></form></div>
            <div className="dashboardSection"><p className="dashboardSectionTitle">Existing Categories</p>
                {loading ? <p>Loading...</p> : (
                    <div className="dashboardContentList">{categories.map(cat => (
                            <div key={cat.id} className="adminDashboardItem" style={{alignItems: 'center', gap: '10px'}}>{editingCategory && editingCategory.id === cat.id ? (<><input type="text" value={editingCategory.name} onChange={(e) => setEditingCategory({...editingCategory, name: e.target.value})} className="formInput flex-grow" disabled={cat.name === "Live Premieres"} /><input type="number" value={editingCategory.orderIndex} onChange={(e) => setEditingCategory({...editingCategory, orderIndex: e.target.value})} className="formInput w-20" /><button onClick={handleSaveEdit} className="adminActionButton approve">Save</button><button onClick={() => setEditingCategory(null)} className="adminActionButton">Cancel</button></>) : (<><span className="flex-grow font-bold">{cat.name}</span><span className="text-sm text-gray-400">Order: {cat.orderIndex}</span><span className={`font-bold ${cat.isActive ? 'text-green-400' : 'text-red-400'}`}>{cat.isActive ? 'Active' : 'Inactive'}</span><button onClick={() => handleToggleActive(cat)} className="adminActionButton">{cat.isActive ? 'Deactivate' : 'Activate'}</button><button onClick={() => setEditingCategory({...cat})} className="adminActionButton" disabled={cat.name === "Live Premieres"}>Edit</button><button onClick={() => handleDeleteCategory(cat)} className="adminActionButton reject" disabled={cat.name === "Live Premieres"}>Delete</button></>)}</div>))}
                    </div>)}
            </div>
            <button className="button" onClick={() => setActiveScreen('AdminDashboard')} style={{ backgroundColor: '#3A3A3A', color: '#FFF' }}><span className="buttonText">Back to Admin Dashboard</span></button>
        </div>
    );
};
        
        // New UserSignUpScreen component
        const UserSignUpScreen = ({ showMessage, setActiveScreen }) => {
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const [agreedToTerms, setAgreedToTerms] = useState(false);

    const handleSubmit = async (e) => {
        e.preventDefault();
        if (!agreedToTerms) {
            showMessage('Please agree to the Terms & Conditions to sign up.');
            return;
        }
        if (password.length < 8 || !/\d/.test(password) || !/[A-Z]/.test(password)) {
            showMessage('Password must be at least 8 characters, with a number and a capital letter.');
            return;
        }

        try {
            const userCredential = await createUserWithEmailAndPassword(auth, email, password);
            const user = userCredential.user;
            await sendEmailVerification(user);
            const creatorRef = doc(db, "creators", user.uid);
            await setDoc(creatorRef, {
                email: user.email,
                creatorName: user.email.split('@')[0] || "", // Default name from email
                bio: "",
                categories: [],
                existingWorkLink: "",
                profilePictureUrl: '',
                uploadedVideos: { youtube: null, facebook: null, tiktok: null },
                createdAt: new Date().toISOString(),
                role: 'user', // Explicitly set role to 'user'
                banned: false
            });

            showMessage(`Account created successfully for ${email}! Please check your inbox to verify your account.`);
            // Correctly redirects to the verification screen after successful signup.
            setActiveScreen('VerifyEmail');
        }
        catch (error) {
            console.error("Error signing up user:", error);
            let errorMessage = "Failed to sign up. Please try again.";
            if (error.code === 'auth/email-already-in-use') {
                errorMessage = "This email is already in use. Please use a different email or sign in.";
            } else if (error.code === 'auth/invalid-email') {
                errorMessage = "Invalid email address format.";
            } else if (error.code === 'auth/weak-password') {
                errorMessage = "Password is too weak. Please choose a stronger password.";
            }
            showMessage(errorMessage);
        }
    };

    return (
        <div className="screenContainer">
            <p className="heading">Create Your Account</p>
            <p className="subHeading">Sign up to access exclusive content and support creators!</p>

            <form onSubmit={handleSubmit}>
                <div className="formGroup">
                    <label htmlFor="userEmail" className="formLabel">Email:</label>
                    <input
                        type="email"
                        id="userEmail"
                        className="formInput"
                        value={email}
                        onChange={(e) => setEmail(e.target.value)}
                        required
                    />
                </div>

                <div className="formGroup">
                    <label htmlFor="userPassword" className="formLabel">Password:</label>
                    <input
                        type="password"
                        id="userPassword"
                        className="formInput"
                        value={password}
                        onChange={(e) => setPassword(e.target.value)}
                        required
                    />
                    <p className="smallText" style={{ textAlign: 'left', color: '#FFD700', marginTop: '5px' }}>
                        Password must be at least 8 characters long, include at least one number and one capital letter.
                    </p>
                </div>

                <div className="formGroup">
                    <div className="checkboxItem">
                        <input
                            type="checkbox"
                            id="agreeUserTerms"
                            checked={agreedToTerms}
                            onChange={(e) => setAgreedToTerms(e.target.checked)}
                            required
                        />
                        <label htmlFor="agreeUserTerms">
                            I agree to the <a href="#" className="termsLink" onClick={(e) => { e.preventDefault(); showMessage('Simulating opening User Terms & Conditions...'); }}>Terms & Conditions</a>.
                        </label>
                    </div>
                </div>

                <button type="submit" className="button">
                    <span className="buttonText">Sign Up</span>
                </button>
            </form>

            <p className="smallText" style={{ marginTop: '20px' }}>
                Already have an account?{' '}
                <a href="#" className="termsLink" onClick={(e) => { e.preventDefault(); setActiveScreen('Login'); }}>Login Here</a>
            </p>

            <button
                className="button"
                onClick={() => setActiveScreen('Home')}
                style={{ backgroundColor: '#3A3A3A', color: '#FFF', marginTop: '30px' }}
            >
                <span className="buttonText">Back to Home</span>
            </button>
        </div>
    );
};
        
        // --- FIND and REPLACE the ENTIRE CategoriesScreen component with this block ---

    const CategoriesScreen = ({ showMessage, isLive, countdownText, liveThumbnail, currentUser, creatorProfile, setActiveScreen, 
    handleVideoPress }) => {
    const [categories, setCategories] = useState([]);
    const [activeCategory, setActiveCategory] = useState('Live Premieres');
    const [content, setContent] = useState([]);
    const [loadingCategories, setLoadingCategories] = useState(true);
    const [loadingContent, setLoadingContent] = useState(false);
    
    const [liveEventSettings, setLiveEventSettings] = useState(null);
    const [showMore, setShowMore] = useState(false);

    useEffect(() => {
        const categoriesRef = collection(db, "content_categories");
        const q = query(categoriesRef, where("isActive", "==", true), orderBy("orderIndex", "asc"));
        const unsubscribe = onSnapshot(q, (snapshot) => {
            const fetchedCategories = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            setCategories(fetchedCategories);
            setLoadingCategories(false);
            
            const liveDoc = fetchedCategories.find(cat => cat.name === 'Live Premieres');
            setLiveEventSettings(liveDoc || null);
        });
        return () => unsubscribe();
    }, []);

    useEffect(() => {
        if (!activeCategory || activeCategory === 'Live Premieres') {
            setContent([]); setLoadingContent(false); return;
        }
        setLoadingContent(true);
        const contentRef = collection(db, `artifacts/${appId}/public/data/content_items`);
        const q = query(contentRef, where('contentType', '==', activeCategory), where('isActive', '==', true), orderBy('createdAt', 'desc'));
        const unsubscribe = onSnapshot(q, (snapshot) => {
            setContent(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
            setLoadingContent(false);
        });
        return () => unsubscribe();
    }, [activeCategory]);
    
    const handleCategoryClick = (categoryName) => {
        setActiveCategory(categoryName);
        setShowMore(false);
    };

    const LiveStreamPlayer = () => {
        const hasAccess = () => {
            if (!liveEventSettings?.isTicketedEvent) return true;
            if (!currentUser || !creatorProfile) return false;
            if (creatorProfile.premiumExpiresAt && creatorProfile.premiumExpiresAt.toDate() > new Date()) return true;
            const eventId = liveEventSettings.liveStreamEventId;
            if (eventId && creatorProfile.purchasedTickets && creatorProfile.purchasedTickets[eventId]) return true;
            return false;
        };

        const canViewStream = hasAccess();

        if (!isLive) {
             if (countdownText) {
                return ( <div style={{textAlign: 'center', paddingTop: '50px', position: 'relative'}}> {liveThumbnail ? ( <img src={liveThumbnail} alt="Coming Soon" style={{ display: 'block', margin: '0 auto', width: '100%', maxWidth: '480px', borderRadius: '10px', boxShadow: '0 4px 15px rgba(0,0,0,0.5)'}} /> ) : ( <div style={{ margin: '0 auto', width: '100%', maxWidth: '480px', height: '250px', backgroundColor: '#2A2A2A', borderRadius: '10px', display: 'flex', alignItems: 'center', justifyContent: 'center'}}><p className="heading">Coming Soon</p></div> )} <p className="heading" style={{marginTop: '20px'}}>Premiere Begins In:</p> <p className="subHeading" style={{color: '#FFD700', fontSize: '28px'}}>{countdownText}</p> </div> );
            }
            return ( <div style={{textAlign: 'center', paddingTop: '50px'}}> <p className="heading">Stream Offline</p> <p className="subHeading">No live premiere is currently scheduled.</p> </div> );
        }

        if (isLive) {
            if (canViewStream) {
                const { embedUrl, isVertical } = extractVideoInfo(liveEventSettings?.liveStreamUrl || '');
                const finalEmbedUrl = embedUrl || `${liveEventSettings?.liveStreamUrl}?autoplay=1`;
                return ( <div style={{ display: 'flex', justifyContent: 'center' }}> <div className={`videoModalContent`} style={{position: 'relative', width: '100%', maxWidth: '900px', height: 'calc(100vh - 300px)', minHeight: '400px', boxShadow: 'none', background: 'transparent'}}> <div className={`videoIframeContainer ${isVertical ? 'vertical' : ''}`} style={{height: '100%', paddingBottom: 0}}> <iframe src={finalEmbedUrl} allow="autoplay; fullscreen" title="Live Premiere Content"></iframe> </div> </div> </div> );
            } else {
                return ( <div style={{textAlign: 'center', paddingTop: '50px'}}> {liveThumbnail && <img src={liveThumbnail} alt="Event" style={{ display: 'block', margin: '0 auto', width: '100%', maxWidth: '480px', borderRadius: '10px', boxShadow: '0 4px 15px rgba(0,0,0,0.5)', opacity: 0.3}} />} <p className="heading" style={{color: '#FFD700'}}>This is a Premium Event</p> <p className="subHeading">The live stream has started. Please purchase a ticket or subscribe to view.</p> <button className="button" style={{ backgroundColor: '#0A0A0A', border: '1px solid #333', color: '#00FFFF' }} onClick={() => setActiveScreen('Premium')}>Book a New Slot</button>
 </div> );
            }
        }
        return null;
    };
    
    const visibleCategories = categories.slice(0, 2);
    const dropdownCategories = categories.slice(2);

    return (
        <div className="screenContainer">
            <p className="sectionTitle">Discover Content</p>
            {loadingCategories ? <p>Loading categories...</p> : (
                <div className="categoryTabs">
                    {visibleCategories.map(category => (
                        <button key={category.id} className={`categoryTab ${activeCategory === category.name ? 'activeCategoryTab' : ''}`} onClick={() => handleCategoryClick(category.name)}>
                            <span className={`categoryTabText ${activeCategory === category.name ? 'activeCategoryTabText' : ''}`}>{category.name}</span>
                        </button>
                    ))}
                    {dropdownCategories.length > 0 && (
                        <div className="more-content-button">
                            <button className="categoryTab" onClick={() => setShowMore(!showMore)}>
                                <span className="categoryTabText">More Content ▼</span>
                            </button>
                            {showMore && (
                                <div className="more-content-dropdown">
                                    {dropdownCategories.map(category => (
                                        <button key={category.id} className={`categoryTab ${activeCategory === category.name ? 'activeCategoryTab' : ''}`} onClick={() => handleCategoryClick(category.name)}>
                                            <span className={`categoryTabText ${activeCategory === category.name ? 'activeCategoryTabText' : ''}`}>{category.name}</span>
                                        </button>
                                    ))}
                                </div>
                            )}
                        </div>
                    )}
                </div>
            )}
            
            <div className="categoryContent">
                {activeCategory === 'Live Premieres' ? (
                    <LiveStreamPlayer />
                ) : loadingContent ? (
                    <p className="paragraph" style={{textAlign: 'center'}}>Loading content...</p>
                ) : content.length === 0 ? (
                    <p className="paragraph" style={{textAlign: 'center'}}>There is no content in this category yet.</p>
                ) : (
                    <div className="contentGrid">
                        {content.map((item) => (
                            <div key={item.id} className="contentCard" onClick={() => handleVideoPress(item.embedUrl || item.mainUrl, item)}>
                                <div className="thumbnailPlaceholder" style={{backgroundImage: `url(${item.customThumbnailUrl})`, backgroundSize: 'cover', backgroundPosition: 'center', position: 'relative'}}>
                                    <svg className="playIcon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"></path></svg>
                                </div>
                                <p className="contentTitle">{item.title}</p>
                            </div>
                        ))}
                    </div>
                )}
            </div>
        </div>
    );
};

        
        // --- NEW HeaderLiveButton Component ---
const HeaderLiveButton = ({ isLive, countdownText, onClick }) => {
    if (!isLive && !countdownText) {
        return null; // The button remains invisible if no event is set
    }

    return (
        <button className={`header-live-button ${isLive ? 'live' : 'countdown'}`} onClick={onClick}>
            <span>{isLive ? '🔴' : '⏳'}</span>
            {/* This text is now more descriptive */}
            <span>{isLive ? 'Live Premieres: LIVE NOW' : `Live Premieres In: ${countdownText}`}</span>
        </button>
    );
};

        // --- NEW COMPONENT ---
        const LivePremiereBanner = ({ isLive, countdownText, onClick }) => {
            if (!isLive && !countdownText) {
                return null; // Don't render anything if there's no event
            }

            return (
                <div className={`live-premiere-banner ${isLive ? 'live' : ''}`} onClick={onClick}>
                    <span className="live-premiere-banner-icon">{isLive ? '🔴' : '⏳'}</span>
                    <span>{isLive ? 'LIVE NOW! Click to Watch!' : `Live Premiere In: ${countdownText}`}</span>
                </div>
            );
        };


        // --- NEW LEADERBOARD SCREEN ---
        const TopCreatorsScreen = ({ featuredContentSlots, handleVideoPress, setActiveScreen, currentUser, showMessage }) => {
    if (!featuredContentSlots) {
        return (
            <div className="screenContainer" style={{ textAlign: 'center', paddingTop: '50px' }}>
                <p className="heading">Loading Top Creators...</p>
            </div>
        );
    }

    const slots = Object.keys(featuredContentSlots)
        .sort() // Sort keys alphabetically (slot_1, slot_2, etc.)
        .map(key => featuredContentSlots[key]);

    return (
        <div className="screenContainer">
            <p className="heading">Top Creators</p>
            <p className="subHeading">The most engaging content from our top creators this week.</p>
            
            <div className="allCampaignsList">
                {slots.map((slot, index) => {
                    if (!slot || !slot.content) {
                        return (
                            <div key={index} className="allCampaignsListItem" style={{justifyContent: 'center', alignItems: 'center', minHeight: '120px'}}>
                                <p className="dashboardItem">Slot #{index + 1} is currently empty.</p>
                            </div>
                        );
                    }
                    const item = slot.content;
                    return (
                        <div key={item.id} className="allCampaignsListItem" onClick={() => handleVideoPress(item.embedUrl || item.mainUrl, item)} style={{borderLeft: '5px solid #FFD700', position: 'relative'}}>
                            <div style={{position: 'absolute', top: '-1px', left: '-1px', backgroundColor: '#FFD700', color: '#0A0A0A', padding: '5px 10px', borderTopLeftRadius: '8px', borderBottomRightRadius: '8px', fontWeight: 'bold'}}>
                                #{index + 1}
                            </div>
                            <img src={item.customThumbnailUrl} alt={item.title} className="creator-campaign-thumbnail" style={{width: '120px', height: '70px'}}/>
                            <div className="campaignListContent">
                                <p className="campaignListTitle" style={{color: '#FFF'}}>{item.title}</p>
                                <div className="campaignListCreator">
                                    <img src={item.creatorProfilePictureUrl || 'https://placehold.co/24x24/555/FFF?text=P'} alt={item.creatorName} className="campaignListCreatorProfilePic"/>
                                    <span>by {item.creatorName}</span>
                                </div>
                                <div className="campaignListStats">
                                    <span>Views: <span className="campaignListRaised">{item.viewCount || 0}</span></span>
                                    <span>Likes: <span className="campaignListGoal">{item.likeCount || 0}</span></span>
                                </div>
                            </div>
                        </div>
                    );
                })}
            </div>
            
            <button className="button" onClick={() => setActiveScreen('Home')} style={{ backgroundColor: '#3A3A3A', color: '#FFF', marginTop: '30px' }}>
                <span className="buttonText">Back to Home</span>
            </button>
        </div>
    );
};
// ======================================================================

        // --- NEW: My Follows Screen ---
        const MyFollowsScreen = ({ currentUser, setActiveScreen, setSelectedUserId, showMessage }) => {
    const [followedCreators, setFollowedCreators] = useState([]);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        if (!currentUser) {
            setActiveScreen('Login');
            return;
        }

        const fetchFollowedCreators = async () => {
            setLoading(true);
            try {
                // 1. Get the list of IDs from the user's "following" subcollection
                const followingRef = collection(db, "creators", currentUser.uid, "following");
                const followingSnapshot = await getDocs(followingRef);
                const followedIds = followingSnapshot.docs.map(doc => doc.id);

                if (followedIds.length > 0) {
                    // 2. Fetch the full profile for each ID
                    const creatorsRef = collection(db, "creators");
                    const q = query(creatorsRef, where("__name__", "in", followedIds));
                    const creatorsSnapshot = await getDocs(q);
                    const creatorsData = creatorsSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    setFollowedCreators(creatorsData);
                } else {
                    setFollowedCreators([]);
                }

            } catch (error) {
                console.error("Error fetching followed creators:", error);
                showMessage("Failed to load your followed creators list.");
            } finally {
                setLoading(false);
            }
        };

        fetchFollowedCreators();
    }, [currentUser]);

    const viewProfile = (userId) => {
        setSelectedUserId(userId);
        setActiveScreen('UserProfile');
    };

    if (loading) {
        return <div className="screenContainer"><p className="heading">Loading Followed Creators...</p></div>;
    }

    return (
        <div className="screenContainer">
            <p className="heading">Creators You Follow</p>
            <p className="subHeading">Here is a list of all the creators you are currently following.</p>

            <div className="user-search-list">
                {followedCreators.length === 0 ? (
                    <p className="dashboardItem" style={{textAlign: 'center'}}>You are not following any creators yet.</p>
                ) : (
                    followedCreators.map(user => (
                        <div key={user.id} className="user-search-item" style={{cursor: 'pointer'}} onClick={() => viewProfile(user.id)}>
                            <img src={user.profilePictureUrl || 'https://placehold.co/100x100/555/FFF?text=P'} alt={user.creatorName} className="user-search-pfp"/>
                            <div className="user-search-info">
                                <p className="user-search-name">{user.creatorName}</p>
                                <p className="user-search-role">Role: {user.role}</p>
                            </div>
                        </div>
                    ))
                )}
            </div>

            <button className="button" onClick={() => setActiveScreen('CreatorDashboard')} style={{ backgroundColor: '#3A3A3A', color: '#FFF', marginTop: '30px' }}>
                <span className="buttonText">Back to Dashboard</span>
            </button>
        </div>
    );
};

const FollowersScreen = ({ currentUser, setActiveScreen, setSelectedUserId, showMessage }) => {
    const [followers, setFollowers] = useState([]);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        if (!currentUser) {
            setActiveScreen('Login');
            return;
        }

        const fetchFollowers = async () => {
            setLoading(true);
            try {
                // Fetch from the 'followers' subcollection instead of 'following'
                const followersRef = collection(db, "creators", currentUser.uid, "followers");
                const followersSnapshot = await getDocs(followersRef);
                const followerIds = followersSnapshot.docs.map(doc => doc.id);

                if (followerIds.length > 0) {
                    const creatorsRef = collection(db, "creators");
                    const q = query(creatorsRef, where("__name__", "in", followerIds));
                    const creatorsSnapshot = await getDocs(q);
                    const followersData = creatorsSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    setFollowers(followersData);
                } else {
                    setFollowers([]);
                }

            } catch (error) {
                console.error("Error fetching followers:", error);
                showMessage("Failed to load your followers list.");
            } finally {
                setLoading(false);
            }
        };

        fetchFollowers();
    }, [currentUser]);

    const viewProfile = (userId) => {
        setSelectedUserId(userId);
        setActiveScreen('UserProfile');
    };

    if (loading) {
        return <div className="screenContainer"><p className="heading">Loading Your Followers...</p></div>;
    }

    return (
        <div className="screenContainer">
            <p className="heading">Your Followers</p>
            <p className="subHeading">This is a list of all the creators and users following you.</p>

            <div className="user-search-list">
                {followers.length === 0 ? (
                    <p className="dashboardItem" style={{textAlign: 'center'}}>You don't have any followers yet.</p>
                ) : (
                    followers.map(user => (
                        <div key={user.id} className="user-search-item" style={{cursor: 'pointer'}} onClick={() => viewProfile(user.id)}>
                            <img src={user.profilePictureUrl || 'https://placehold.co/100x100/555/FFF?text=P'} alt={user.creatorName} className="user-search-pfp"/>
                            <div className="user-search-info">
                                <p className="user-search-name">{user.creatorName}</p>
                                <p className="user-search-role">Role: {user.role}</p>
                            </div>
                        </div>
                    ))
                )}
            </div>

            <button className="button" onClick={() => setActiveScreen('CreatorDashboard')} style={{ backgroundColor: '#3A3A3A', color: '#FFF', marginTop: '30px' }}>
                <span className="buttonText">Back to Dashboard</span>
            </button>
        </div>
    );
};

// ===================== START: FULL COMPONENT REPLACEMENT =====================
const PremiumMembersScreen = ({ setActiveScreen, setSelectedUserId, showMessage }) => {
    const [allPremiumUsers, setAllPremiumUsers] = useState([]);
    const [searchTerm, setSearchTerm] = useState('');
    
    const [loading, setLoading] = useState(true);

    // This useEffect now runs once on load to get ALL premium users.
    useEffect(() => {
        const fetchPremiumUsers = async () => {
            setLoading(true);
            try {
                const creatorsRef = collection(db, "creators");
                const q = query(
                    creatorsRef,
                    where('premiumExpiresAt', '>', new Date()),
                    orderBy('premiumExpiresAt', 'desc')
                );

                const querySnapshot = await getDocs(q);
                const usersData = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                setAllPremiumUsers(usersData); // Store the full list

            } catch (error) {
                console.error("Error fetching premium members:", error);
                showMessage("Failed to load premium members list.");
            } finally {
                setLoading(false);
            }
        };

        fetchPremiumUsers();
    }, []);

    const viewProfile = (userId) => {
        setSelectedUserId(userId);
        setActiveScreen('UserProfile');
    };

    // This is NOT state. It's a derived value calculated on every render.
    // It filters the full list based on the current searchTerm state.
    const filteredUsers = allPremiumUsers.filter(user =>
        user.creatorName.toLowerCase().includes(searchTerm.toLowerCase())
    );

    if (loading) {
        return <div className="screenContainer"><p className="heading">Loading Premium Members...</p></div>;
    }

    return (
        <div className="screenContainer">
            <p className="heading">Premium Members</p>
            <p className="subHeading">A list of all users currently supporting the platform.</p>

            {/* This is the new real-time search/filter input */}
            <div className="formGroup" style={{ marginTop: '10px', marginBottom: '20px' }}>
                <input
                    type="text"
                    className="formInput"
                    placeholder="Filter by name..."
                    value={searchTerm}
                    onChange={(e) => setSearchTerm(e.target.value)}
                />
            </div>

            <div className="user-search-list">
                {allPremiumUsers.length === 0 ? (
                     <p className="dashboardItem" style={{textAlign: 'center'}}>There are currently no active premium members.</p>
                ) : filteredUsers.length === 0 ? (
                    <p className="dashboardItem" style={{textAlign: 'center'}}>No premium members match your filter "{searchTerm}".</p>
                ) : (
                    filteredUsers.map(user => (
                        <div key={user.id} className="user-search-item" style={{cursor: 'pointer'}} onClick={() => viewProfile(user.id)}>
                            <img src={user.profilePictureUrl || 'https://placehold.co/100x100/555/FFF?text=P'} alt={user.creatorName} className="user-search-pfp"/>
                            <div className="user-search-info">
                                <p className="user-search-name" style={{display: 'flex', alignItems: 'center'}}>
                                    {user.creatorName}
                                    <span style={{marginLeft: '10px', fontSize: '14px'}}>👑</span>
                                </p>
                                <p className="user-search-role">
                                    Premium Expires: {new Date(user.premiumExpiresAt.toDate()).toLocaleDateString()}
                                </p>
                            </div>
                        </div>
                    ))
                )}
            </div>

            <button className="button" onClick={() => setActiveScreen('AdminDashboard')} style={{ backgroundColor: '#3A3A3A', color: '#FFF', marginTop: '30px' }}>
                <span className="buttonText">Back to Admin Dashboard</span>
            </button>
        </div>
    );
};


// --- UPDATED ANALYTICS DASHBOARD ---
       const AnalyticsDashboardScreen = ({ showMessage, setActiveScreen }) => {
    // State for the new high-level stats
    const [platformStats, setPlatformStats] = useState(null);
    const [loadingStats, setLoadingStats] = useState(true);
    const [isRefreshing, setIsRefreshing] = useState(false); // For the manual trigger button

    // State for the existing creator performance table
    const [creators, setCreators] = useState([]);
    const [loadingCreators, setLoadingCreators] = useState(true);
    const [sortBy, setSortBy] = useState('lifetimeViews'); // Default sort

    // Fetch the pre-aggregated platform overview stats in real-time
    useEffect(() => {
        const statsDocRef = doc(db, "statistics", "platformOverview");
        const unsubscribeStats = onSnapshot(statsDocRef, (docSnap) => {
            if (docSnap.exists()) {
                setPlatformStats(docSnap.data());
            } else {
                setPlatformStats({ notGenerated: true });
            }
            setLoadingStats(false);
        }, (error) => {
            console.error("Error fetching platform stats:", error);
            showMessage("Could not load platform overview statistics.");
            setLoadingStats(false);
        });
        return () => unsubscribeStats();
    }, []);

    // Fetch the detailed creator list for the performance table
    useEffect(() => {
        const creatorsQuery = query(collection(db, "creators"));
        const unsubscribeCreators = onSnapshot(creatorsQuery, (snapshot) => {
            setCreators(snapshot.docs.map(d => ({ id: d.id, ...d.data() })));
            setLoadingCreators(false);
        }, (error) => {
            console.error("Error fetching creator list:", error);
            showMessage("Could not load creator performance data.");
            setLoadingCreators(false);
        });
        return () => unsubscribeCreators();
    }, []);

    // The new on-demand trigger function
    const handleManualRefresh = async () => {
        setIsRefreshing(true);
        showMessage("Requesting immediate stats refresh...");
        try {
            // THE FIX: Use the 'functions' constant instead of 'window.firebaseFunctions'
            const triggerUpdateCallable = httpsCallable(functions, 'triggerPlatformStatsUpdate');
            const result = await triggerUpdateCallable();
            showMessage(result.data.message);
        } catch (error) {
            console.error("Error triggering stats update:", error);
            showMessage(`Error: ${error.message}`);
        } finally {
            setIsRefreshing(false);
        }
    };

    const StatCard = ({ title, value, isLoading }) => (
        <div className="dashboardSection" style={{ flex: 1, textAlign: 'center', minWidth: '200px' }}>
            <p className="dashboardItem" style={{ color: '#AAA', marginBottom: '5px' }}>{title}</p>
            <p className="premiumFeatureTitle" style={{ fontSize: '28px', margin: 0 }}>
                {isLoading ? '...' : (value ?? 0).toLocaleString()}
            </p>
        </div>
    );

    const BreakdownTable = ({ title, data }) => (
        <div className="dashboardSection" style={{ flex: 1, minWidth: '300px' }}>
            <p className="dashboardSectionTitle">{title}</p>
            {Object.entries(data).map(([key, value]) => (
                <div key={key} style={{ display: 'flex', justifyContent: 'space-between', padding: '5px 0', borderBottom: '1px solid #3A3A3A' }}>
                    <span style={{ textTransform: 'capitalize' }}>{key}</span>
                    <span style={{ fontWeight: 'bold' }}>{value.toLocaleString()}</span>
                </div>
            ))}
        </div>
    );
    
    const sortedCreators = [...creators].sort((a, b) => (b[sortBy] || 0) - (a[sortBy] || 0));

    if (loadingStats) {
        return (
            <div className="screenContainer" style={{ textAlign: 'center', paddingTop: '50px' }}>
                <p className="heading">Loading Platform Health...</p>
            </div>
        );
    }

    if (platformStats?.notGenerated) {
        return (
            <div className="screenContainer" style={{ textAlign: 'center', paddingTop: '50px' }}>
                <p className="heading">Generating Analytics</p>
                <p className="subHeading">
                    The first batch of platform statistics is being compiled.
                    <br />
                    This dashboard will be populated after the next scheduled run (within 24 hours).
                </p>
                <button className="button" onClick={handleManualRefresh} disabled={isRefreshing} style={{backgroundColor: '#008000'}}>
                    <span className="buttonText">{isRefreshing ? 'Processing...' : 'Generate Now'}</span>
                </button>
                <button className="button" onClick={() => setActiveScreen('AdminDashboard')} style={{margin: '20px 0 0 0', backgroundColor: '#555'}}>
                    <span className="buttonText">Back to Admin</span>
                </button>
            </div>
        );
    }

    const { totalUsers = 0, activeUsers30Days = 0, newUsers7Days = 0 } = platformStats || {};

    return (
        <div className="screenContainer">
            <div className="flex justify-between items-center mb-4">
                <p className="heading" style={{margin:0}}>Platform Health Dashboard</p>
                <div>
                    <button className="button" onClick={handleManualRefresh} disabled={isRefreshing} style={{margin: '0 10px 0 0', backgroundColor: '#FF8C00'}}>
                         <span className="buttonText">{isRefreshing ? '...' : 'Refresh Stats'}</span>
                    </button>
                    <button className="button" onClick={() => setActiveScreen('AdminDashboard')} style={{margin: 0, backgroundColor: '#555'}}>
                        <span className="buttonText">Back</span>
                    </button>
                </div>
            </div>
            <p className="subHeading" style={{textAlign: 'left'}}>A high-level overview of platform activity. Last updated: {platformStats?.lastUpdated ? new Date(platformStats.lastUpdated).toLocaleString() : 'N/A'}</p>

            <div style={{ display: 'flex', gap: '15px', flexWrap: 'wrap' }}>
                <StatCard title="Total Users" value={totalUsers} isLoading={loadingStats} />
                <StatCard title="Active Users (30d)" value={activeUsers30Days} isLoading={loadingStats} />
                <StatCard title="Inactive Users" value={totalUsers - activeUsers30Days} isLoading={loadingStats} />
                <StatCard title="New Users (7d)" value={newUsers7Days} isLoading={loadingStats} />
            </div>

            <div style={{ display: 'flex', gap: '15px', marginTop: '20px', flexWrap: 'wrap' }}>
                {platformStats?.userRoleBreakdown && <BreakdownTable title="User Roles" data={platformStats.userRoleBreakdown} />}
                {platformStats?.campaignStatusBreakdown && <BreakdownTable title="Campaign Funnel" data={platformStats.campaignStatusBreakdown} />}
            </div>

            <div className="dashboardSection" style={{ marginTop: '20px' }}>
                <p className="dashboardSectionTitle">Creator Performance (Lifetime)</p>
                {loadingCreators ? <p>Loading creator data...</p> : (
                    <table style={{width: '100%', borderCollapse: 'collapse'}}>
                        <thead>
                            <tr style={{borderBottom: '1px solid #FFD700'}}>
                                <th style={{textAlign: 'left', paddingBottom: '10px'}}>Creator</th>
                                <th onClick={() => setSortBy('lifetimeViews')} style={{cursor: 'pointer', textAlign: 'right'}}>Views {sortBy === 'lifetimeViews' && '▼'}</th>
                                <th onClick={() => setSortBy('lifetimeLikes')} style={{cursor: 'pointer', textAlign: 'right'}}>Likes {sortBy === 'lifetimeLikes' && '▼'}</th>
                            </tr>
                        </thead>
                        <tbody>
                            {sortedCreators.map(creator => (
                                <tr key={creator.id} style={{borderBottom: '1px solid #3A3A3A'}}>
                                    <td style={{padding: '10px 0', display: 'flex', alignItems: 'center', gap: '10px'}}>
                                        <img src={creator.profilePictureUrl || 'https://placehold.co/40x40/555/FFF?text=P'} alt={creator.creatorName} style={{width: '40px', height: '40px', borderRadius: '50%', objectFit: 'cover'}} />
                                        <span style={{fontWeight: 'bold'}}>{creator.creatorName}</span>
                                    </td>
                                    <td style={{textAlign: 'right', fontSize: '16px', fontWeight: 'bold', color: sortBy === 'lifetimeViews' ? '#FFD700' : '#FFF'}}>{(creator.lifetimeViews || 0).toLocaleString()}</td>
                                    <td style={{textAlign: 'right', fontSize: '16px', fontWeight: 'bold', color: sortBy === 'lifetimeLikes' ? '#FFD700' : '#FFF'}}>{(creator.lifetimeLikes || 0).toLocaleString()}</td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                )}
            </div>
        </div>
    );
};
        // REPLACE THE ENTIRE FollowingFeedScreen COMPONENT

const FollowingFeedScreen = ({ currentUser, setActiveScreen, showMessage, handleVideoPress }) => {
    const [loading, setLoading] = useState(true);
    const [feedItems, setFeedItems] = useState([]);

    // Helper function to create relative timestamps
    const timeAgo = (date) => {
        const seconds = Math.floor((new Date() - new Date(date)) / 1000);
        let interval = seconds / 31536000;
        if (interval > 1) return Math.floor(interval) + " years ago";
        interval = seconds / 2592000;
        if (interval > 1) return Math.floor(interval) + " months ago";
        interval = seconds / 86400;
        if (interval > 1) return Math.floor(interval) + " days ago";
        interval = seconds / 3600;
        if (interval > 1) return Math.floor(interval) + " hours ago";
        interval = seconds / 60;
        if (interval > 1) return Math.floor(interval) + " minutes ago";
        return Math.floor(seconds) + " seconds ago";
    };

    useEffect(() => {
        if (!currentUser) return;
        const feedRef = collection(db, "creators", currentUser.uid, "feed");
        const q = query(feedRef, orderBy("createdAt", "desc"), limit(50));
        const unsubscribeFeed = onSnapshot(q, (feedSnapshot) => {
            setFeedItems(feedSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
            setLoading(false);
        }, (error) => {
            console.error("Error fetching following feed: ", error);
            showMessage("Could not load your feed. Please try again.");
            setLoading(false);
        });
        return () => unsubscribeFeed();
    }, [currentUser]);

    if (loading) { return <div className="screenContainer" style={{ textAlign: 'center', paddingTop: '50px' }}><p className="heading">Loading My Feed...</p></div>; }
    
    return (
        // THIS IS THE FIX: This container now defines a strict flexbox column layout.
        <div className="screenContainer" style={{ display: 'flex', flexDirection: 'column', height: '100%' }}>
            {/* THIS IS THE FIXED HEADER. It has a static size ('flex-shrink: 0') and will not scroll. */}
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '20px', flexShrink: 0 }}>
                <button 
                    onClick={() => setActiveScreen('Home')} 
                    style={{ background: 'none', border: '1px solid #FFD700', color: '#FFD700', borderRadius: '50%', width: '40px', height: '40px', display: 'flex', alignItems: 'center', justifyContent: 'center', cursor: 'pointer' }}
                >
                    &#x2190;
                </button>
                <p className="heading" style={{ margin: 0, textAlign: 'center', flexGrow: 1 }}>My Feed</p>
                <div style={{ width: '40px' }}></div> {/* Spacer to keep title centered */}
            </div>

            {/* THIS IS THE NEW SCROLLABLE WRAPPER. It takes up the remaining space ('flex: 1') and scrolls internally. */}
            <div style={{ flex: '1 1 auto', overflowY: 'auto', paddingRight: '10px' }}>
                {feedItems.length === 0 ? (
                    <div style={{ textAlign: 'center', paddingTop: '50px' }}>
                        <p className="heading">Your Feed is Empty</p>
                        <p className="subHeading">Follow creators to see their latest content here.</p>
                        <button className="button" onClick={() => setActiveScreen('DiscoverUsers')}><span className="buttonText">Discover Creators</span></button>
                    </div>
                ) : (
                    <div style={{ display: 'flex', flexDirection: 'column', gap: '20px' }}>
                        {feedItems.map((item) => (
                            <div key={item.id} className="dashboardSection" style={{ padding: 0, overflow: 'hidden' }}>
                                {/* Card Header */}
                                <div style={{ display: 'flex', alignItems: 'center', gap: '10px', padding: '10px' }}>
                                    <img src={item.creatorProfilePictureUrl || 'https://placehold.co/40x40/555/FFF?text=P'} alt={item.creatorName} style={{ width: '40px', height: '40px', borderRadius: '50%', objectFit: 'cover' }} />
                                    <div>
                                        <p style={{ fontWeight: 'bold', color: '#FFF', margin: 0 }}>{item.creatorName}</p>
                                        <p style={{ fontSize: '12px', color: '#AAA', margin: 0 }}>{timeAgo(item.createdAt)}</p>
                                    </div>
                                </div>
                                {/* Card Image/Thumbnail */}
                                <div style={{ cursor: 'pointer', position: 'relative' }} onClick={() => handleVideoPress(item.embedUrl || item.mainUrl, item)}>
                                    <img src={item.customThumbnailUrl} alt={item.title} style={{ width: '100%', display: 'block' }} />
                                    <div style={{ position: 'absolute', top: 0, left: 0, right: 0, bottom: 0, background: 'rgba(0,0,0,0.2)', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                                        <svg className="playIcon" viewBox="0 0 24 24" style={{width: '60px', height: '60px', opacity: 0.8}}><path d="M8 5v14l11-7z"></path></svg>
                                    </div>
                                </div>
                                {/* Card Action Bar & Title */}
                                <div style={{ padding: '10px', position: 'relative' }}>
                                    <div style={{ position: 'absolute', right: '10px', top: '15px' }}>
                                        <LikeButton contentItem={item} currentUser={currentUser} showMessage={showMessage} />
                                    </div>
                                    <p className="contentTitle" style={{ padding: 0, marginBottom: '5px' }}>{item.title}</p>
                                    <div style={{ display: 'flex', alignItems: 'center', gap: '5px', color: '#AAA', fontSize: '12px' }}>
                                        <svg viewBox="0 0 24 24" style={{ width: '16px', height: '16px', fill: 'currentColor' }}><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5C21.27 7.61 17 4.5 12 4.5zm0 10c-2.48 0-4.5-2.02-4.5-4.5S9.52 5.5 12 5.5s4.5 2.02 4.5 4.5-2.02 4.5-4.5 4.5zM12 8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"></path></svg>
                                        <span>{(item.viewCount || 0).toLocaleString()} views</span>
                                    </div>
                                </div>
                            </div>
                        ))}
                    </div>
                )}
            </div>
        </div>
    );
};
// --- END OF NEW COMPONENT DEFINITIONS ---


        // ADD THIS ENTI-RE NEW COMPONENT DEFINITION

    const ContactScreen = ({ setActiveScreen, showMessage, currentUser }) => {
    const [socialLinks, setSocialLinks] = useState([]);
    const [isLoading, setIsLoading] = useState(true);
    const [mmgNumber, setMmgNumber] = useState('');
    const [userName, setUserName] = useState('');
    const [userEmail, setUserEmail] = useState('');
    const [queryType, setQueryType] = useState('General Question');
    const [message, setMessage] = useState('');
    const [isSubmitting, setIsSubmitting] = useState(false);

    useEffect(() => {
        if (currentUser) {
            // Note: displayName is not a field in the 'creators' collection, so we use creatorName
            // We need to fetch the profile to get the most accurate name.
            const userDocRef = doc(db, "creators", currentUser.uid);
            getDoc(userDocRef).then(docSnap => {
                if (docSnap.exists()) {
                    setUserName(docSnap.data().creatorName || currentUser.email.split('@')[0]);
                } else {
                    setUserName(currentUser.email.split('@')[0]);
                }
            });
            setUserEmail(currentUser.email);
        }

        const socialLinksDocRef = doc(db, "settings", "socialLinks");
        getDoc(socialLinksDocRef).then(docSnap => {
            if (docSnap.exists()) {
                const data = docSnap.data();
                  setMmgNumber(data.mmgNumber || '');
                if (data && Array.isArray(data.links)) {
                    const enabledLinks = data.links.filter(link => link.isEnabled === true);
                    setSocialLinks(enabledLinks);
                }
            }
            setIsLoading(false);
        }).catch(error => { setIsLoading(false); });
    }, [currentUser]);

    const handleSubmit = async (e) => {
        e.preventDefault();
        if (!userName || !userEmail || !message) {
            showMessage("Please fill in all required fields.");
            return;
        }
        if (!currentUser) {
            showMessage("You must be logged in to send a message.");
            setActiveScreen('Login');
            return;
        }
        
        setIsSubmitting(true);

        try {
            // Step 1: Check the user's last submission timestamp from their profile
            const userDocRef = doc(db, "creators", currentUser.uid);
            const userDocSnap = await getDoc(userDocRef);

            if (userDocSnap.exists()) {
                const userData = userDocSnap.data();
                if (userData.lastSubmissionTimestamp) {
                    const lastSubmitTime = userData.lastSubmissionTimestamp.toDate();
                    const twentyFourHoursAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);

                    // If the last submission was within the last 24 hours, block it.
                    if (lastSubmitTime > twentyFourHoursAgo) {
                        showMessage("You can only send one message every 24 hours. Please try again later.");
                        setIsSubmitting(false);
                        return;
                    }
                }
            }

            // Step 2: If the check passes, proceed with submitting the message
            showMessage("Submitting your message...");
            await addDoc(collection(db, "contactSubmissions"), {
                userName: userName,
                userEmail: userEmail,
                queryType: queryType,
                message: message,
                submittedAt: new Date().toISOString(),
                status: 'New',
                userId: currentUser.uid
            });

            // Step 3: After successful submission, update the user's timestamp on their profile
            await updateDoc(userDocRef, {
                lastSubmissionTimestamp: new Date()
            });

            showMessage("Your message has been sent successfully!");
            // Reset form for future use
            setMessage('');
            setQueryType('General Question');
        } catch (error) {
            console.error("Error submitting contact form:", error);
            showMessage(`An error occurred: ${error.message}`);
        } finally {
            setIsSubmitting(false);
        }
    };

    const SocialIcon = ({ url, svgPath, name }) => (
        <a href={url} target="_blank" rel="noopener noreferrer" title={name} style={{ color: '#FFD700' }}>
            <svg viewBox="0 0 24 24" style={{ width: '40px', height: '40px', fill: 'currentColor' }}>
                <path d={svgPath}></path>
            </svg>
        </a>
    );

    return (
        <div className="screenContainer">
            <p className="heading">Get In Touch</p>
            <p className="subHeading">Connect with us on social media or send us a message below.</p>

            <div className="dashboardSection">
                <p className="dashboardSectionTitle" style={{ textAlign: 'center' }}>Follow Us</p>
                {isLoading ? ( <p style={{ textAlign: 'center' }}>Loading social links...</p> ) : (
                    <div style={{ display: 'flex', justifyContent: 'center', gap: '20px', flexWrap: 'wrap', marginTop: '20px' }}>
                        {socialLinks.map(link => (
                            <SocialIcon key={link.name} url={link.url} svgPath={link.iconSvgPath} name={link.name} />
                        ))}
                    </div>
                )}
            </div>

            <div className="dashboardSection" style={{ marginTop: '20px' }}>
                <p className="dashboardSectionTitle">Send a Message</p>
                <form onSubmit={handleSubmit}>
                    <div className="formGroup">
                        <label htmlFor="contactName" className="formLabel">Your Name:</label>
                        <input type="text" id="contactName" className="formInput" value={userName} onChange={(e) => setUserName(e.target.value)} required />
                    </div>
                    <div className="formGroup">
                        <label htmlFor="contactEmail" className="formLabel">Your Email:</label>
                        <input type="email" id="contactEmail" className="formInput" value={userEmail} onChange={(e) => setUserEmail(e.target.value)} required />
                    </div>
                    <div className="formGroup">
                        <label htmlFor="contactQueryType" className="formLabel">Reason for Contact:</label>
                        <select id="contactQueryType" className="formInput" value={queryType} onChange={(e) => setQueryType(e.target.value)}>
                            <option>General Question</option>
                            <option>Bug Report</option>
                            <option>Partnership Inquiry</option>
                            <option>Feedback & Suggestions</option>
                        </select>
                    </div>
                    <div className="formGroup">
                        <label htmlFor="contactMessage" className="formLabel">Message:</label>
                        <textarea id="contactMessage" className="formTextarea" value={message} onChange={(e) => setMessage(e.target.value)} required></textarea>
                    </div>
                    <button type="submit" className="button" disabled={isSubmitting}>
                        <span className="buttonText">{isSubmitting ? 'Sending...' : 'Send Message'}</span>
                    </button>
                </form>
            </div>
        </div>
    );
};

const VerificationScreen = ({ currentUser, showMessage, handleLogout, setActiveScreen }) => {
    const [isSending, setIsSending] = useState(false);
    const [isChecking, setIsChecking] = useState(false);
    const handleResend = async () => {
        if (!currentUser) return;
        setIsSending(true);
        showMessage("Resending verification email...");
        try {
            await sendEmailVerification(currentUser);
            showMessage("A new verification email has been sent.");
        } catch (error) {
            console.error("Error resending verification email:", error);
            showMessage("Failed to resend email. Please try again in a few moments.");
        } finally { setIsSending(false); }
    };
    const handleCheckVerification = async () => {
        if (!currentUser) return;
        setIsChecking(true);
        await currentUser.reload();
        if (auth.currentUser.emailVerified) {
            showMessage("Thank you for verifying! Redirecting...");
            setActiveScreen('CreatorDashboard');
        } else {
            showMessage("Email has not been verified yet. Please click the link in your email.");
        }
        setIsChecking(false);
    };
    return (
        <div className="screenContainer" style={{textAlign: 'center', paddingTop: '50px'}}>
            <p className="heading">Please Verify Your Email</p>
            <p className="subHeading">A verification link has been sent to: <br/><strong style={{color: '#FFD700'}}>{currentUser?.email}</strong></p>
            <p className="paragraph">Please check your inbox (and spam folder) and click the link to activate your account.</p>
            <button className="button" onClick={handleCheckVerification} disabled={isChecking}><span className="buttonText">{isChecking ? 'Checking...' : 'I Have Verified My Email'}</span></button>
            <p className="smallText" style={{marginTop: '20px'}}>Didn't receive an email?</p>
            <button className="button" onClick={handleResend} disabled={isSending} style={{backgroundColor: '#3A3A3A'}}><span className="buttonText">{isSending ? 'Sending...' : 'Resend Verification Email'}</span></button>
            <button className="button" onClick={handleLogout} style={{backgroundColor: '#555', marginTop: '40px'}}><span className="buttonText">Logout</span></button>
        </div>
    );
};
     // ======================================================================
// ========= START: ADD THIS ENTIRE NEW COMPONENT =======================
// ======================================================================

const PostSubmissionUpsellScreen = ({ showMessage, setActiveScreen, opportunityToPromote, setOpportunityToPromote }) => {
    // Safety check in case the user navigates here directly
    if (!opportunityToPromote) {
        setActiveScreen('CreatorDashboard');
        return null;
    }

    const handleBookSlot = () => {
        // The opportunityToPromote state is already set, so we just need to navigate.
        // The BookStatusScreen will now be "smart" and use this state.
        setActiveScreen('BookStatus');
    };

    const handleNoThanks = () => {
        // Clear the state and navigate to My Listings as per our enhanced plan.
        setOpportunityToPromote(null);
        setActiveScreen('MyListings');
    };

    return (
        <div className="screenContainer" style={{textAlign: 'center', paddingTop: '50px'}}>
            <p className="heading" style={{color: '#00FF00'}}>Success!</p>
            <p className="subHeading">Your opportunity listing has been submitted for review.</p>
            
            <div className="dashboardSection" style={{border: '1px solid #FFD700', marginTop: '30px'}}>
                <p className="dashboardSectionTitle">Want to Maximize Visibility?</p>
                <p className="paragraph">
                    Give your listing a massive boost by promoting it on the homepage "Billboard" for 24 hours.
                </p>
                <button className="button" onClick={handleBookSlot}>
                    <span className="buttonText">Book Billboard Slot</span>
                </button>
            </div>

            <button
                className="button"
                onClick={handleNoThanks}
                style={{ backgroundColor: '#3A3A3A', marginTop: '20px' }}
            >
                <span className="buttonText light">No, Thanks (View My Listings)</span>
            </button>
        </div>
    );
};

// ======================================================================
// =========== END: ADD THIS ENTIRE NEW COMPONENT =======================
// ======================================================================

// ======================================================================
// --- Your App component should start on the very next line ---
// ======================================================================
        

        function App() {
            const [isVideoFinished, setIsVideoFinished] = useState(false); // NEW state for video splash screen

// =========== START REPLACEMENT ===========
            const [currentUser, setCurrentUser] = useState(null);
            const [currencyRates, setCurrencyRates] = useState(null);
            const [selectedCurrency, setSelectedCurrency] = useState('USD');
            // NOTE: Replace this placeholder URL with the actual URL of your hosted notification sound file.
            const notificationSoundRef = useRef(new Audio('https://firebasestorage.googleapis.com/v0/b/nvanetworkapp.firebasestorage.app/o/Notification%202.mp3?alt=media&token=0befabd3-3c9d-4aa4-a990-5681591d201a'));
            const [activeScreen, setActiveScreen] = useState('Home');
            const [pledgeContext, setPledgeContext] = useState(null);
            const [pledgeIdForConfirmation, setPledgeIdForConfirmation] = useState(null);
            const [canExit, setCanExit] = useState(false);
            const exitTimer = useRef(null);
            const [showMoreMenu, setShowMoreMenu] = useState(false);
            const [hasNewFollowerContent, setHasNewFollowerContent] = useState(false);
            // ======================= START: NEW CODE =======================
            // Call our new hook to get a live list of notifications
            const { notifications: unreadNotifications, isLoading: notificationsLoading, dismissNotification, markBroadcastAsSeen, markNotificationAsRead } = 
            useNotifications(currentUser);
            // ======================== END: NEW CODE ========================
            
              // ======================= START: NEW TOAST STATE AND LOGIC =======================
            const [toastQueue, setToastQueue] = useState([]);
            const [currentToast, setCurrentToast] = useState(null);
            const processedToastIds = useRef(new Set());

            useEffect(() => {
                // This effect now correctly filters for notifications that are NOT marked as read.
                const newNotifications = unreadNotifications.filter(n => !processedToastIds.current.has(n.id) && n.isRead === false);
                if (newNotifications.length > 0) {
                    setToastQueue(prev => [...prev, ...newNotifications]);
                    newNotifications.forEach(n => processedToastIds.current.add(n.id));
                }
            }, [unreadNotifications]);

                    useEffect(() => {
                const openModalHandler = (event) => {
                    setContentToReport(event.detail);
                    setShowReportModal(true);
                };
                window.addEventListener('openReportModal', openModalHandler);
                return () => {
                    window.removeEventListener('openReportModal', openModalHandler);
                };
            }, []);

            useEffect(() => {
                // Process the toast queue
                if (!currentToast && toastQueue.length > 0) {
                    const nextToast = toastQueue[0];
                    setCurrentToast(nextToast);
                    setToastQueue(prev => prev.slice(1));
                    // Play the notification sound
                    if (notificationSoundRef.current) {
                        notificationSoundRef.current.play().catch(error => {
                            // This catch block gracefully handles the browser's autoplay policy
                            // without crashing the app. It's expected to trigger on the first notification.
                            console.log("Audio play was blocked by the browser, which is expected on first load. Sound will play on subsequent notifications after user interaction.");
                        });
                    }
                    // THE DEFINITIVE FIX:
                    // If it's a broadcast, mark it as "seen" in its own subcollection.
                    if (nextToast.isBroadcast) {
                        markBroadcastAsSeen(nextToast.id);
                    // If it's a private notification, update its document to set isRead = true.
                    } else {
                        markNotificationAsRead(nextToast.id);
                    }
                }
            }, [currentToast, toastQueue, markBroadcastAsSeen, markNotificationAsRead]);

            // ADD this entire useEffect block
            useEffect(() => {
                const openModalHandler = (event) => {
                    setContentForLikes(event.detail.contentItem);
                    setShowLikesModal(true);
                };
                window.addEventListener('openLikesModal', openModalHandler);
                return () => {
                    window.removeEventListener('openLikesModal', openModalHandler);
                };
            }, []);

                useEffect(() => {
                const navigateHandler = (event) => {
                    const { userId } = event.detail;
                    // This function will close ALL modals and then navigate.
                    setShowVideoModal(false);
                    setShowLikesModal(false); 
                    setSelectedUserId(userId);
                    setActiveScreen('UserProfile');
                };
                window.addEventListener('navigateToUserProfile', navigateHandler);
                return () => {
                    window.removeEventListener('navigateToUserProfile', navigateHandler);
                };
            }, []); // Empty dependency array ensures this runs once.

            // ADD this entire useEffect block
            useEffect(() => {
                const openCommentsHandler = (event) => {
                    setItemForComments(event.detail.item);
                    setItemTypeForComments(event.detail.itemType);
                    setShowCommentsModal(true);
                };
                window.addEventListener('openCommentsModal', openCommentsHandler);
                return () => {
                    window.removeEventListener('openCommentsModal', openCommentsHandler);
                };
            }, []);

            // This function now ONLY handles clicks, for navigation.
            const handleToastClick = () => {
                if(currentToast?.link) {
                    const screen = currentToast.link.replace('/', '');
                    setActiveScreen(screen);
                }
                setCurrentToast(null);
            };
            
            // This function handles the timeout, ONLY dismissing the toast.
            const handleToastTimeout = () => {
                setCurrentToast(null);
            };
// END of REPLACEMENT Block

            const [activeCategory, setActiveCategory] = useState('Skits');
            const [message, setMessage] = useState('');
            const [showVideoModal, setShowVideoModal] = useState(false);
            const [currentVideoUrl, setCurrentVideoUrl] = useState('');
            const isInitialLoad = useRef(true);
// =========== END REPLACEMENT ===========

             // This effect MANAGES the back button and history stack.
            useEffect(() => {
                const handlePopState = (event) => {
                    // The #1 priority is the modal. If it's open, the back button should ONLY close it.
                    if (showVideoModal) {
                        setShowVideoModal(false);
                        setCurrentVideoUrl('');
                        return;
                    }

                    // If the modal is not open, check if we are on the Home screen.
                    if (activeScreen === 'Home') {
                         if (canExit) {
                            // If they already pressed once, allow the app to close.
                            window.history.back();
                            return;
                        }

                        // First press on the Home screen: prevent exit and show message.
                        showMessage('Press back again to exit.');
                        setCanExit(true);
                        window.history.pushState({ screen: 'Home' }, ''); // Re-add 'Home' to history
                        
                        exitTimer.current = setTimeout(() => setCanExit(false), 2000); // 2-sec window
                        return;
                    }

                    // If we're on any other screen, perform normal back navigation.
                    if (event.state?.screen) {
                        clearTimeout(exitTimer.current);
                        setCanExit(false);
                        setActiveScreen(event.state.screen);
                    }
                };
                
                window.addEventListener('popstate', handlePopState);
                return () => {
                    window.removeEventListener('popstate', handlePopState);
                    clearTimeout(exitTimer.current);
                };
            }, [activeScreen, canExit, showVideoModal]); // This hook is now aware of all relevant states.

            // This effect PUSHES to the history stack when navigating FORWARD.
            useEffect(() => {
                if (window.history.state?.screen !== activeScreen) {
                    window.history.pushState({ screen: activeScreen }, '');
                }
            }, [activeScreen]);

            // This effect handles pushing a state when the video modal opens.
            useEffect(() => {
                if (showVideoModal) {
                    // Push a generic state to represent the modal being open.
                    // This allows the back button to have an entry to "pop".
                    window.history.pushState({ modal: 'video' }, '');
                }
            }, [showVideoModal]);
            // --- END: Comprehensive History, Navigation, and Modal Management Logic ---
            
            const [currentContentItem, setCurrentContentItem] = useState(null);
            const [showImageAdjustModal, setShowImageAdjustModal] = useState(false);
            const [imageFileToAdjust, setImageFileToAdjust] = useState(null);
            const [isUploadingPFP, setIsUploadingPFP] = useState(false);    
            const [creatorProfile, setCreatorProfile] = useState(null);
            const [authLoading, setAuthLoading] = useState(true);
            
            const [selectedCampaignId, setSelectedCampaignId] = useState(null);
            const [selectedUserId, setSelectedUserId] = useState(null);

            // New state for admin-selected campaign details
            const [selectedAdminCampaignId, setSelectedAdminCampaignId] = useState(null);
            const [selectedStatus, setSelectedStatus] = useState(null);
            const [selectedCompAdmin, setSelectedCompAdmin] = useState(null);
            const [selectedEntry, setSelectedEntry] = useState(null);
            const [selectedAdminSubScreen, setSelectedAdminSubScreen] = useState('Overview'); // 'Overview', 'ContentManagement'
            const [selectedOpportunity, setSelectedOpportunity] = useState(null);

            const [opportunityToPromote, setOpportunityToPromote] = useState(null);

            // New state variables for custom confirmation modal
            const [showConfirmationModal, setShowConfirmationModal] = useState(false);
            const [confirmationTitle, setConfirmationTitle] = useState('');
            const [confirmationMessage, setConfirmationMessage] = useState('');
            const [onConfirmationAction, setOnConfirmationAction] = useState(null);
            const [featuredContentSlots, setFeaturedContentSlots] = useState(null);
            
            const [showLikesModal, setShowLikesModal] = useState(false);
            const [contentForLikes, setContentForLikes] = useState(null);
            
            // ADD these three lines
            const [showCommentsModal, setShowCommentsModal] = useState(false);
            const [itemForComments, setItemForComments] = useState(null);
            const [itemTypeForComments, setItemTypeForComments] = useState(''); // 'content' or 'opportunity'

            const [showReportModal, setShowReportModal] = useState(false);
            const [contentToReport, setContentToReport] = useState(null);
            const [selectedReportGroup, setSelectedReportGroup] = useState(null);
            const [suspensionDetails, setSuspensionDetails] = useState(null);

            // --- MOVED FROM CategoriesScreen to App (GLOBAL STATE) ---
            const [isLive, setIsLive] = useState(false);
            const [countdownText, setCountdownText] = useState('');
            const [liveThumbnail, setLiveThumbnail] = useState('');

           // --- PASTE THIS ENTIRE CORRECTED BLOCK ---

useEffect(() => {
                let unsubscribeProfile = () => {};
                const unsubscribeAuth = onAuthStateChanged(auth, (user) => {
                    setAuthLoading(true);
                    setCurrentUser(user);
                    unsubscribeProfile();

                    if (user) {
                        const creatorDocRef = doc(db, "creators", user.uid);
                        unsubscribeProfile = onSnapshot(creatorDocRef, (docSnap) => {
                            if (docSnap.exists()) {
                                const profileData = docSnap.data();
                                setCreatorProfile(profileData);
                            } else {
                                setCreatorProfile(null);
                            }
                            setAuthLoading(false);
                        });
                    } else {
                        setCreatorProfile(null);
                        setAuthLoading(false);
                    }
                });
                return () => {
                    unsubscribeAuth();
                    unsubscribeProfile();
                };
            }, []);
           
                useEffect(() => {
                // If we are still loading the user's profile, do nothing.
                if (authLoading) return;

                // Scenario 1: User is logged in.
                if (currentUser && creatorProfile) {
                    if (creatorProfile.banned) {
                        showMessage("Your account has been banned.");
                        signOut(auth);
                        return;
                    }
                    if (creatorProfile.suspendedUntil && creatorProfile.suspendedUntil.toDate() > new Date()) {
                        const expiryDate = creatorProfile.suspendedUntil.toDate().toLocaleString();
                        setSuspensionDetails({ email: creatorProfile.email, expiryDate });
                        setActiveScreen('Suspended');
                        signOut(auth);
                        return;
                    }
                    if (!currentUser.emailVerified) {
                        // If email is not verified, force them to the verification screen.
                        if (activeScreen !== 'VerifyEmail') setActiveScreen('VerifyEmail');
                        return;
                    }
                    // If they are verified and on a login/signup/verify page, redirect them to their dashboard.
                    const authScreens = ['Login', 'UserSignUp', 'CreatorSignUp', 'VerifyEmail', 'ForgotPassword', 'Suspended'];
                    if (authScreens.includes(activeScreen)) {
                        setActiveScreen('CreatorDashboard');
                    }
                }
                // Scenario 2: User is logged out.
                else if (!currentUser) {
                    setSuspensionDetails(null);
                    // If they are on a page that requires login, redirect to Home.
                    const protectedScreens = ['CreatorDashboard', 'AdminDashboard', 'FollowingFeed', 'MyFollows', 'Followers', 'MyContentLibrary', 'CreateCampaign', 'MyListings', 'SavedOpportunities', 'PromotedStatus', 'BookStatus'];
                    if (protectedScreens.includes(activeScreen)) {
                        setActiveScreen('Home');
                    }
                }
            }, [currentUser, creatorProfile, authLoading, activeScreen]); 

            // --- NEW GLOBAL useEffect for Countdown Logic ---
            useEffect(() => {
    const categoriesRef = collection(db, "content_categories");
    const q = query(categoriesRef, where("name", "==", "Live Premieres"));
    let countdownInterval = null;

    const unsubscribe = onSnapshot(q, (snapshot) => {
    console.log('%cLive Premieres data updated in Firestore.', 'color: cyan; font-weight: bold;');
        clearInterval(countdownInterval);

        if (snapshot.empty) {
            setIsLive(false);
            setCountdownText('');
            setLiveThumbnail(''); // Clear thumbnail
            return;
        }

        const liveDocData = snapshot.docs[0].data();
        const startTime = liveDocData.liveStreamStartTime ? liveDocData.liveStreamStartTime.toDate() : null;
        const liveUrl = liveDocData.liveStreamUrl || '';
        setLiveThumbnail(liveDocData.liveStreamThumbnailUrl || ''); // Get thumbnail

        if (!startTime) {
            setIsLive(false);
            setCountdownText('');
            return;
        }

        countdownInterval = setInterval(() => {
            const now = new Date();
            const distance = startTime - now;

            if (distance < 0) {
                clearInterval(countdownInterval);
                setCountdownText('');
                setIsLive(liveUrl.trim() !== '');
            } else {
                setIsLive(false);
                const days = Math.floor(distance / (1000 * 60 * 60 * 24));
                const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((distance % (1000 * 60)) / 1000);
                
                let parts = [];
                if (days > 0) parts.push(`${days}d`);
                if (hours > 0) parts.push(`${hours}h`);
                if (minutes > 0) parts.push(`${minutes}m`);
                if (days === 0 && hours === 0 && minutes < 1) parts.push(`${seconds}s`);
                else if(days === 0 && hours === 0) parts.push(`${minutes}m`);

                setCountdownText(parts.join(' '));
            }
        }, 1000);
    });

    return () => {
        unsubscribe();
        clearInterval(countdownInterval);
    };
}, []);

           useEffect(() => {
                let unsubscribe = () => {};
                if (currentUser) {
                    const followingRef = collection(db, "creators", currentUser.uid, "following");
                    const q = query(followingRef, where("hasNewContent", "==", true));
                    unsubscribe = onSnapshot(q, (snapshot) => {
                        setHasNewFollowerContent(!snapshot.empty);
                    });
                } else {
                    setHasNewFollowerContent(false);
                }
                return () => unsubscribe();
            }, [currentUser]);

            // This new useEffect hook fetches the currency rates when the app loads.
            useEffect(() => {
                const fetchRates = async () => {
                    try {
                        const getRatesFunction = httpsCallable(functions, 'getExchangeRates');
                        const result = await getRatesFunction();
                        if (result.data && result.data.rates) {
                            setCurrencyRates(result.data.rates);
                            console.log("Successfully fetched currency exchange rates.");
                        }
                    } catch (error) {
                        console.error("Could not fetch currency rates:", error);
                        showMessage("Currency conversion is currently unavailable.");
                    }
                };
                fetchRates();
            }, []); // The empty dependency array ensures this runs only once on app load.

            const showMessage = (msg) => {
                setMessage(msg);
                setTimeout(() => setMessage(''), 3000);
            };

          // --- UPDATED CLICK HANDLING LOGIC ---
            const handleVideoPress = (url, contentItem) => {
            if (!currentUser) {
            showMessage("Please sign up or log in to engage with content!");
        return;
            }
            setCurrentVideoUrl(url);
            setCurrentContentItem(contentItem); // Remember which item was clicked
            setShowVideoModal(true);
            };
            const closeVideoModal = () => {
                // If the modal is open, pressing 'X' should be the same as going "back" once in history.
                if (showVideoModal) {
                    window.history.back();
                }
                setShowVideoModal(false);
                setCurrentVideoUrl('');
            };

            const handleLogout = async () => {
                try {
                    await signOut(auth);
                    showMessage('Logged out successfully!');
                    setActiveScreen('Home');
                } catch (error) {
                    console.error("Error logging out:", error);
                    showMessage('Failed to log out. Please try again.');
                }
            };

// START: REPLACEMENT (Your HomeScreen with the Live Feed Fix)
               const HomeScreen = ({ currentUser, showMessage, handleVideoPress, handleLogout, featuredContentSlots }) => {
    const [enrichedLayout, setEnrichedLayout] = useState({ featured: [], trending: [] });
    const [displayFeatured, setDisplayFeatured] = useState([]);
    const [displayLiveFeed, setDisplayLiveFeed] = useState([]);
    const horizontalCarouselRef = useRef(null);
    const verticalCarouselRef = useRef(null);

    const [isLayoutLoading, setIsLayoutLoading] = useState(true);
    const [isLiveFeedLoading, setIsLiveFeedLoading] = useState(true);
    const loading = isLayoutLoading || isLiveFeedLoading;

    // State for the two separate data sources for the vertical feed
    const [adminLiveFeed, setAdminLiveFeed] = useState([]);
    const [creatorFeaturedFeed, setCreatorFeaturedFeed] = useState([]);

    // This useEffect handles fetching for ALL carousels now
    useEffect(() => {
        const layoutDocRef = doc(db, "settings", "homeScreenLayout");
        let cachedData = { layout: null, autoSlots: featuredContentSlots };

        const processManualContent = async () => {
            if (cachedData.layout === null || cachedData.autoSlots === null) return;
            const manualTrending = cachedData.layout.trendingItems || [];
            const autoSlots = [cachedData.autoSlots.slot_1, cachedData.autoSlots.slot_2, cachedData.autoSlots.slot_3]
                .filter(slot => slot && slot.content).map(slot => ({ type: 'internal', contentId: slot.content.id, isAuto: true, orderIndex: -1 }));
            const manualTrendingIds = new Set(manualTrending.filter(i => i.type === 'internal').map(i => i.contentId));
            const uniqueAutoSlots = autoSlots.filter(slot => !manualTrendingIds.has(slot.contentId));
            const combinedTrending = [...uniqueAutoSlots, ...manualTrending];
            const allItems = { featured: cachedData.layout.featuredItems || [], trending: combinedTrending };
            const contentIds = [...new Set(Object.values(allItems).flat().filter(i => i.type === 'internal' && i.contentId).map(i => i.contentId))];

            if (contentIds.length === 0) {
                const finalLayout = { 
                    featured: (allItems.featured || []).filter(item => item.type === 'external').sort((a,b) => (a.orderIndex || 99) - (b.orderIndex || 99)), 
                    trending: (allItems.trending || []).filter(item => item.type === 'external').sort((a,b) => (a.orderIndex || 99) - (b.orderIndex || 99))
                };
                setEnrichedLayout(finalLayout);
                setDisplayFeatured(finalLayout.featured);
                setIsLayoutLoading(false);
                return;
            }

            const promises = contentIds.map(id => getDoc(doc(db, `artifacts/${appId}/public/data/content_items`, id)).catch(() => null));
            const docSnapshots = await Promise.all(promises);
            const allContentData = docSnapshots.filter(snap => snap && snap.exists()).map(snap => ({id: snap.id, ...snap.data()}));
            const contentMap = new Map(allContentData.map(c => [c.id, c]));
            const enrich = (items) => items.map(item => {
                if (item.type === 'internal') return contentMap.has(item.contentId) ? { ...item, ...contentMap.get(item.contentId) } : null;
                return item;
            }).filter(Boolean).sort((a,b) => (a.orderIndex || 99) - (b.orderIndex || 99));

            const finalLayout = { featured: enrich(allItems.featured), trending: enrich(allItems.trending) };
            setEnrichedLayout(finalLayout);
            const numFeaturedClones = 3;
            if (finalLayout.featured.length > numFeaturedClones) {
                setDisplayFeatured([...finalLayout.featured, ...finalLayout.featured.slice(0, numFeaturedClones)]);
            } else {
                setDisplayFeatured(finalLayout.featured);
            }
            setIsLayoutLoading(false);
        };
        
        const unsubLayout = onSnapshot(layoutDocRef, (docSnap) => {
            cachedData.layout = docSnap.exists() ? docSnap.data() : { featuredItems: [], trendingItems: [] };
            processManualContent();
        }, (error) => {
            console.error("Layout fetch failed:", error);
            cachedData.layout = { featuredItems: [], trendingItems: [] };
            processManualContent();
        });

        cachedData.autoSlots = featuredContentSlots || { slot_1: null, slot_2: null, slot_3: null };
        processManualContent();

        // Query 1: Admin-curated Live Feed
        const liveFeedQuery = query(collection(db, `artifacts/${appId}/public/data/content_items`), where('isActive', '==', true), where('contentType', '==', 'Live Feed'), orderBy('createdAt', 'desc'), limit(20));
        const unsubLiveFeed = onSnapshot(liveFeedQuery, (snapshot) => {
            setAdminLiveFeed(snapshot.docs.map(d => ({ id: d.id, ...d.data() })));
        }, (error) => {
            console.error("Admin Live Feed fetch failed:", error);
            setAdminLiveFeed([]);
        });

        // Query 2: Creator-selected Featured items
        const creatorFeaturedQuery = query(collection(db, `artifacts/${appId}/public/data/content_items`), where('isActive', '==', true), where('isFeatured', '==', true), orderBy('createdAt', 'desc'), limit(20));
        const unsubCreatorFeatured = onSnapshot(creatorFeaturedQuery, (snapshot) => {
            setCreatorFeaturedFeed(snapshot.docs.map(d => ({ id: d.id, ...d.data() })));
        }, (error) => {
            console.error("Creator Featured Feed fetch failed:", error);
            setCreatorFeaturedFeed([]);
        });
        
        return () => {
            unsubLayout();
            unsubLiveFeed();
            unsubCreatorFeatured();
        };
    }, [featuredContentSlots]);

    // This new useEffect is responsible for COMBINING the two feeds into one display list
    useEffect(() => {
        setIsLiveFeedLoading(true);
        const combined = [...adminLiveFeed, ...creatorFeaturedFeed];
        const uniqueItems = Array.from(new Map(combined.map(item => [item.id, item])).values());
        uniqueItems.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
        
        const numLiveFeedClones = 4;
        if (uniqueItems.length > numLiveFeedClones) {
            setDisplayLiveFeed([...uniqueItems, ...uniqueItems.slice(0, numLiveFeedClones)]);
        } else {
            setDisplayLiveFeed(uniqueItems);
        }
        setIsLiveFeedLoading(false);
    }, [adminLiveFeed, creatorFeaturedFeed]);

   // THIS EFFECT MANAGES THE HORIZONTAL CAROUSEL
    useEffect(() => {
        const horizontalCarousel = horizontalCarouselRef.current;
        let horizontalInterval = null; // Initialize to null

        const startHorizontalAutoscroll = () => {
            // Always clear any previous timer to prevent duplicates
            clearInterval(horizontalInterval);

            // Guard Clause: Don't start if we don't have enough items to scroll
            if (!horizontalCarousel || !horizontalCarousel.children[0] || displayFeatured.length <= 3) {
                return;
            }

            const itemWidth = horizontalCarousel.children[0].offsetWidth + 15;
            if (itemWidth <= 15) return; // Wait for proper rendering

            const originalItemCount = displayFeatured.length - 3;
            const originalContentWidth = originalItemCount * itemWidth;

            horizontalInterval = setInterval(() => {
                if (horizontalCarousel.scrollLeft >= originalContentWidth - 1) {
                    // Instantly jump back to the start
                    horizontalCarousel.scrollTo({ left: 0, behavior: 'instant' });
                    // Give the browser a tiny moment to process the jump, then scroll again
                    setTimeout(() => {
                        horizontalCarousel.scrollBy({ left: itemWidth, behavior: 'smooth' });
                    }, 50);
                } else {
                    horizontalCarousel.scrollBy({ left: itemWidth, behavior: 'smooth' });
                }
            }, 3000);
        };

        // This is the trigger. It runs whenever displayFeatured changes.
        startHorizontalAutoscroll();

        // This is the cleanup. It runs before the effect runs again, or when the component unmounts.
        return () => clearInterval(horizontalInterval);

    }, [displayFeatured]); // The key change: This effect is now correctly dependent ONLY on its own data.

    // THIS EFFECT MANAGES THE VERTICAL CAROUSEL (UNCHANGED LOGIC, BUT NOW SAFELY SEPARATED)
    useEffect(() => {
        const verticalCarousel = verticalCarouselRef.current;
        let verticalInterval = null;

        const startVerticalAutoscroll = () => {
            clearInterval(verticalInterval);
            if (!verticalCarousel || !verticalCarousel.children[0] || displayLiveFeed.length <= 4) return;
            const itemHeight = verticalCarousel.children[0].offsetHeight + 15;
            if (itemHeight <= 15) return;

            const originalItemCount = displayLiveFeed.length - 4;
            const originalContentHeight = originalItemCount * itemHeight;

            verticalInterval = setInterval(() => {
                if (verticalCarousel.scrollTop >= originalContentHeight - 1) {
                    verticalCarousel.scrollTo({ top: 0, behavior: 'instant' });
                } else {
                    verticalCarousel.scrollBy({ top: itemHeight, behavior: 'smooth' });
                }
            }, 3000);
        };

        startVerticalAutoscroll();
        return () => clearInterval(verticalInterval);

    }, [displayLiveFeed]); // This effect correctly depends ONLY on the live feed data.
    
    const handleHorizontalScroll = (direction) => { const carousel = horizontalCarouselRef.current; if (carousel) { const itemWidth = carousel.children[0]?.offsetWidth + 15; carousel.scrollBy({ left: direction === 'prev' ? -itemWidth : itemWidth, behavior: 'smooth' }); } };
    const handleVerticalScroll = (direction) => { const carousel = verticalCarouselRef.current; if (carousel) { const itemHeight = carousel.children[0]?.offsetHeight + 15; carousel.scrollBy({ top: direction === 'up' ? -itemHeight : itemHeight, behavior: 'smooth' }); } };
    
    const handleItemClick = (item) => {
        if (!currentUser) { showMessage("Please sign up or log in to engage with content!"); return; }
        let urlToTest = (item.type === 'external') ? item.externalLink : (item.mainUrl || item.url);
        if (!urlToTest) { showMessage("This item has no valid link to play."); return; }
        const { embedUrl } = extractVideoInfo(urlToTest);
        if (embedUrl) { handleVideoPress(embedUrl, item); } 
        else { if (item.type === 'external') { window.open(urlToTest, '_blank'); } else { showMessage("This video cannot be played in-app. It might be from an unsupported source."); } }
    };

    return (
        <div className="screenContainer">
            
             <PromotedSlot showMessage={showMessage} handleVideoPress={handleVideoPress} currentUser={currentUser} />

            <CompetitionHomeScreenBanner setActiveScreen={setActiveScreen} />

            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                <p className="sectionTitle" style={{ margin: 0, fontSize: '18px', marginTop: '20px' }}>Featured Highlights</p>
                <div className="topRightButtonContainer" style={{ position: 'static', top: 'auto', right: 'auto' }}>
                    {currentUser && (<button className="topButton" onClick={() => setActiveScreen('TopCreators')}>Top Creators</button>)}
                    <button className="topButton" onClick={() => setActiveScreen('SupportUsScreen')}>Support Us</button>                    {currentUser ? (<button className="topButton" onClick={handleLogout}>Logout</button>) : (<button className="topButton" onClick={() => setActiveScreen('Login')}>Login</button>)}
                </div>
            </div>
            <div className="carousel-wrapper">
                {displayFeatured.length > 3 && (<><button className="carousel-nav-btn prev-horizontal" onClick={() => handleHorizontalScroll('prev')}>◀</button><button className="carousel-nav-btn next-horizontal" onClick={() => handleHorizontalScroll('next')}>▶</button></>)}
                <div className="horizontal-carousel-container" ref={horizontalCarouselRef}>
                    {isLayoutLoading ? Array.from({ length: 5 }).map((_, i) => <div key={i} className="horizontal-carousel-item" style={{ backgroundColor: '#2A2A2A' }}></div>)
                    : displayFeatured.map((item, index) => (
                        <div key={`${item.id || item.title}-${index}`} className="horizontal-carousel-item" onClick={() => handleItemClick(item)} style={{cursor: 'pointer'}}>
                            <img src={item.customThumbnailUrl || item.imageUrl} alt={item.title} className="carousel-image" />
                            {currentUser && item.type === 'internal' && item.id && <LikeButton contentItem={item} currentUser={currentUser} showMessage={showMessage} />}
                        </div>
                    ))}
                </div>
            </div>
            <div className="sectionHeaderWithButton">
                <p className="sectionTitle" style={{ marginBottom: '0' }}>Trending</p>
                {!currentUser && <div style={{display: 'flex', gap: '10px'}}><button className="sectionHeaderButton" onClick={() => setActiveScreen('UserSignUp')}>User Sign Up</button><button className="sectionHeaderButton" onClick={() => setActiveScreen('CreatorSignUp')}>Creator Sign Up</button></div>}
            </div>
            {isLayoutLoading ? <p>Loading trending...</p> : (
                <div className="contentGrid">
                    {enrichedLayout.trending.map((item) => (
                            <div key={item.id || item.title} className="contentCard">
                                {/* This is the line where the new component is correctly used */}
                                <DynamicThumbnail item={item} onClick={() => handleItemClick(item)} />

                                <p className="contentTitle">{item.title}</p>
                                {item.type === 'internal' && (
                                    <div style={{ padding: '0 10px 10px 10px', display: 'flex', alignItems: 'center', gap: '5px', color: '#AAA', fontSize: '12px' }}>
                                        <svg viewBox="0 0 24 24" style={{ width: '16px', height: '16px', fill: 'currentColor' }}><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5C21.27 7.61 17 4.5 12 4.5zm0 10c-2.48 0-4.5-2.02-4.5-4.5S9.52 5.5 12 5.5s4.5 2.02 4.5 4.5-2.02 4.5-4.5 4.5zM12 8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"></path></svg>
                                        <span>{item.viewCount || 0} views</span>
                                    </div>
                                )}
                            </div>
                        )
                    )}
                </div>
            )}
            <div className="sectionHeaderWithButton">
                <p className="sectionTitle" style={{ marginBottom: '0' }}>Live Feed</p>
                {currentUser && <div style={{display: 'flex', gap: '10px'}}><button className="sectionHeaderButton" onClick={() => setActiveScreen('DiscoverUsers')}>Find Creators</button><button className="sectionHeaderButton" onClick={() => setActiveScreen('Discover')}>Discover All</button></div>}
            </div>
            <div className="carousel-wrapper">
                {displayLiveFeed.length > 2 && ( <> <button className="carousel-nav-btn prev-vertical" onClick={() => handleVerticalScroll('up')}>▲</button> <button className="carousel-nav-btn next-vertical" onClick={() => handleVerticalScroll('down')}>▼</button> </> )}
                <div className="vertical-carousel-container" ref={verticalCarouselRef}>
                    {isLiveFeedLoading ? Array.from({ length: 4 }).map((_, i) => <div key={i} className="vertical-carousel-item" style={{backgroundColor: '#1A1A1A'}}></div>)
                    : displayLiveFeed.map((item, index) => (
                        <div key={item.id ? `${item.id}-${index}` : `${item.title}-${index}`} className="vertical-carousel-item" style={{position: 'relative', cursor: 'pointer'}} onClick={() => handleItemClick(item)}>
                            <img src={item.customThumbnailUrl || item.imageUrl} alt={item.title} className="liveFeedThumbnail" />
                            <div className="liveFeedContent">
                                <p className="liveFeedTitle">{item.title}</p>
                                <p className="liveFeedCreator">by {item.creatorName}</p>
                             <div style={{ display: 'flex', alignItems: 'center', gap: '5px', color: '#AAA', fontSize: '12px', marginTop: '4px' }}>
                            <svg viewBox="0 0 24 24" style={{ width: '16px', height: '16px', fill: 'currentColor' }}><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5C21.27 7.61 17 4.5 12 4.5zm0 10c-2.48 0-4.5-2.02-4.5-4.5S9.52 5.5 12 5.5s4.5 2.02 4.5 4.5-2.02 4.5-4.5 4.5zM12 8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9-2-2-.9-2-2-2z"></path></svg>
                            <span>{item.viewCount || 0} views</span>
                            </div>
                            </div>
                            {currentUser && item.id && <LikeButton contentItem={item} currentUser={currentUser} showMessage={showMessage} />}
                        </div>
                    ))}
                </div>
            </div>
        </div>
    );
};
// --- END: FULL COMPONENT REPLACEMENT ---


            // =========== START REPLACEMENT ===========
            const PremiumScreen = ({ showMessage, currentUser, setActiveScreen, setPledgeContext }) => {
                const [eventSettings, setEventSettings] = useState(null);
                const [loading, setLoading] = useState(true);
                const [premiumPrice, setPremiumPrice] = useState(1.99);

                useEffect(() => {
                    const settingsDocRef = doc(db, "settings", "socialLinks");
                    const unsubscribeSettings = onSnapshot(settingsDocRef, (docSnap) => {
                        if (docSnap.exists()) {
                            setPremiumPrice(docSnap.data().premiumPrice || 1.99);
                        }
                    });

                    // THE DEFINITIVE FIX: Use a query to find the settings document by its name, not by a hardcoded ID.
                    const categoriesRef = collection(db, "content_categories");
                    const q = query(categoriesRef, where("name", "==", "Live Premieres"));
                    const unsubscribeLiveEvent = onSnapshot(q, (snapshot) => {
                        if (!snapshot.empty) {
                            // There will only be one document, so we take the first one.
                            setEventSettings(snapshot.docs[0].data());
                        } else {
                            setEventSettings(null);
                        }
                        setLoading(false);
                    });

                    return () => {
                        unsubscribeSettings();
                        unsubscribeLiveEvent();
                    };
                }, []);

                const handlePledge = (type) => {
                    if (!currentUser) {
                        showMessage("Please log in or sign up to continue.");
                        setActiveScreen('Login');
                        return;
                    }

                    if (type === 'eventTicket') {
                        if (!eventSettings?.isTicketedEvent) {
                             showMessage("There is no ticketed event currently available for purchase.");
                             return;
                        }
                        const context = { 
                            type: 'eventTicket',
                            amount: eventSettings.ticketPrice || 5.00,
                            targetEventId: eventSettings.liveStreamEventId || 'LivePremiere_General', 
                            targetEventTitle: eventSettings.liveStreamEventTitle || "Live Premiere Event"
                        };
                        setPledgeContext(context);
                        setActiveScreen('SubscriptionPledge');
                    } else if (type === 'premium') {
                        const context = { type: 'premium', amount: premiumPrice };
                        setPledgeContext(context);
                        setActiveScreen('SubscriptionPledge');
                    }
                };

                return (
                    <div className="screenContainer">
                        <p className="heading">NVA Network Premium Access</p>
                        <p className="subHeading">Choose how you want to experience our exclusive content.</p>

                        <div className="premiumFeatureCard" style={{border: '1px solid #FFD700'}}>
                            <p className="premiumFeatureTitle">Premium Subscription</p>
                            <p className="premiumFeatureDescription">Get access to **all** ticketed live events, enjoy ad-free viewing, and receive exclusive perks. The best value for dedicated fans.</p>
                            <button className="button" style={{marginTop: '15px'}} onClick={() => handlePledge('premium')}>

                                <span className="buttonText">Purchase Subscription</span>
                            </button>
                        </div>

                         <div className="premiumFeatureCard" style={{border: '1px solid #CCC'}}>
                            {loading ? <p className="premiumFeatureDescription">Loading Event Details...</p> : 
                            (eventSettings?.isTicketedEvent) ? (
                                <>
                                    <p className="premiumFeatureTitle" style={{color: '#FFF'}}>{eventSettings.liveStreamEventTitle || "Live Premiere Event"}</p>
                                    <p className="premiumFeatureDescription" style={{marginBottom: '15px'}}>{eventSettings.liveStreamEventDescription || 'Purchase a single-use ticket for our next live premiere event.'}</p>
                                    <button 
                                        className="button" 
                                        style={{ backgroundColor: '#0A0A0A', border: '1px solid #FFD700' }} 
                                        onClick={() => handlePledge('eventTicket')}
                                    >
                                        <span className="buttonText" style={{color: '#FFD700'}}>Buy Ticket</span>
                                    </button>
                                </>
                            ) : (<p className="premiumFeatureDescription">There are no new ticketed events scheduled at this time. Please check back later!</p>)}
                        </div>

                          {/* ====================================================================== */}
                        {/* ================ START: ADD THIS NEW CARD FOR BOOKING ================ */}
                        {/* ====================================================================== */}
                        <div className="premiumFeatureCard" style={{border: '1px solid #00FFFF'}}>
                            <p className="premiumFeatureTitle" style={{color: '#00FFFF'}}>24hr Promoted Status</p>
                            <p className="premiumFeatureDescription">Book the #1 "Billboard" spot on the Home page. The ultimate visibility for your brand or event. (Verified Advertiser Status Required)</p>
                            <button 
                                className="button" 
                                style={{ backgroundColor: '#0A0A0A', border: '1px solid #00FFFF', marginTop: '15px' }} 
                                onClick={() => {
                                    if (!currentUser) {
                                        showMessage("Please log in to book a slot.");
                                        setActiveScreen('Login');
                                        return;
                                    }
                                    // THIS IS THE FIX: Use the new time-aware logic
                                    const isVerified = creatorProfile?.isVerifiedAdvertiser && creatorProfile.verifiedAdvertiserExpiresAt && creatorProfile.verifiedAdvertiserExpiresAt.toDate() > new Date();
                                    if (isVerified) {
                                        setActiveScreen('BookStatus');
                                    } else {
                                        showMessage("This feature is for Verified Advertisers only. Please contact NVA Network for verification.");
                                    }
                                }}
                            >
                                <span className="buttonText" style={{color: '#00FFFF'}}>Book Billboard Slot</span>
                            </button>
                        </div>
                        {/* ====================================================================== */}
                        {/* ================= END: ADD THIS NEW CARD FOR BOOKING ================= */}
                        {/* ====================================================================== */}   
                                    
                    </div>
                );
            };
// =========== END REPLACEMENT ===========

            const AboutContactScreen = () => (
                <div className="screenContainer">
                    <p className="heading">A<p className="subHeading">The Caribbean’s first mobile-first entertainment network, dedicated to bringing the best of Caribbean content to a global stage.</p>bout NVA Network</p>
                    <p className="subHeading">The Caribbean’s first mobile-first entertainment network, dedicated to bringing the best of Guyanese content to a global stage.</p>

                    <p className="paragraph">
                        NVA Network is committed to empowering local creators and connecting audiences worldwide
                        with unique and vibrant stories from the Caribbean. Our mission is to provide a platform for Caribbean                        comedians, filmmakers, interviewers, and live event organizers to showcase their talent,
                        reach new audiences, and build sustainable careers.
                    </p>

                    <p className="sectionTitle">Contact Us</p>
                    <p className="paragraph">
                        Have questions, feedback, or want to partner with us? Reach out!
                    </p>
                    <p className="contactInfo">Email: contact@nvanetwork.gy</p>
                    <p className="contactInfo">Phone: +592-555-NVA (Placeholder)</p>
                    <p className="contactInfo">Follow us on social media!</p>
                </div>
            );

            const CrowdfundingScreen = ({ showMessage, setActiveScreen }) => {
                const PLATFORM_FEE_PERCENTAGE = 0.07;
                return (
                    <div className="screenContainer">
                        <p className="heading">Support Caribbean Creators!</p>
                        <p className="subHeading">Help bring more authentic Caribbean content to life.</p>
                        <p className="paragraph">
                            International crowdfunding platforms often don't support direct bank accounts in the Caribbean,
                            making it difficult for our talented creators to receive global support.
                            At NVA Network, we're committed to finding direct ways for you to contribute!
                        </p>
                        <div className="premiumFeatureCard">
                            <p className="premiumFeatureTitle">Why Your Support Matters:</p>
                            <p className="premiumFeatureDescription">
                                Your contributions directly fund new skits, short films, interviews, and live event coverage.
                                Every dollar helps cover production costs, equipment, and fair compensation for our artists.
                            </p>
                        </div>
                        <p className="sectionTitle">How You Can Contribute Directly:</p>
                        <p className="paragraph">
                            We are setting up direct support channels that are accessible within the Caribbean and for our diaspora.
                            Please contact us for details on how to send your support via:
                        </p>
                        <p className="listItem">• Direct Bank Transfer (Local & International options)</p>
                        <p className="listItem">• Mobile Money Services (e.g., MMG - Mobile Money Guyana)</p>
                        <p className="listItem">• Other Local Payment Methods</p>
                        <button
                            className="button"
                            onClick={() => setActiveScreen('AllCampaigns')}
                        >
                            <span className="buttonText">Browse Creator Campaigns</span>
                        </button>
                        <p className="smallText">(Discover campaigns and support your favorite creators!)</p>
                        <p className="paragraph" style={{ marginTop: '20px' }}>
                            Your generosity empowers Caribbean voices and helps us build a stronger, more vibrant content ecosystem.
                            Thank you for being a part of the NVA Network family!
                        </p>
                        <p className="smallText" style={{ marginTop: '20px', color: '#888' }}>
                            A small platform fee (e.g., {(PLATFORM_FEE_PERCENTAGE * 100).toFixed(0)}%) helps NVA Network cover operational costs and continue supporting our creators.
                        </p>
                    </div>
                );
            };


// --- REPLACE THE ENTIRE LoginScreen COMPONENT ---

                            // --- START: NEW ForgotPasswordScreen Component ---
        const ForgotPasswordScreen = ({ showMessage, setActiveScreen }) => {
            const [email, setEmail] = useState('');
            const [isSending, setIsSending] = useState(false);

            const handleResetRequest = async (e) => {
                e.preventDefault();
                if (!email) {
                    showMessage("Please enter your email address.");
                    return;
                }
                setIsSending(true);
                try {
                    await sendPasswordResetEmail(auth, email);
                    showMessage("If an account with that email exists, a password reset link has been sent.");
                    setActiveScreen('Login');
                } catch (error) {
                    console.error("Password reset error:", error);
                    showMessage("An error occurred. Please check the email format and try again.");
                } finally {
                    setIsSending(false);
                }
            };

            return (
                <div className="screenContainer">
                    <p className="heading">Reset Your Password</p>
                    <p className="subHeading">Enter your account's email address for a password reset link.</p>
                    <form onSubmit={handleResetRequest} className="loginForm">
                        <div className="formGroup">
                            <label htmlFor="resetEmail" className="formLabel">Email:</label>
                            <input
                                type="email"
                                id="resetEmail"
                                className="formInput"
                                value={email}
                                onChange={(e) => setEmail(e.target.value)}
                                placeholder="your.email@example.com"
                                required
                            />
                        </div>
                        <button type="submit" className="button" disabled={isSending}>
                            <span className="buttonText">{isSending ? 'Sending...' : 'Send Reset Link'}</span>
                        </button>
                    </form>
                    <button
                        className="button"
                        onClick={() => setActiveScreen('Login')}
                        style={{ backgroundColor: '#3A3A3A', marginTop: '20px' }}
                    >
                        <span className="buttonText light">Back to Login</span>
                    </button>
                </div>
            );
        };
        // --- END: NEW ForgotPasswordScreen Component ---

const LoginScreen = ({ showMessage, setActiveScreen, setSuspensionDetails }) => {
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');

    const handleSubmit = async (e) => {
        e.preventDefault();
        try {
            // This function's only job is to attempt to sign in.
            // It does not change screens. The main App component will handle that.
            await signInWithEmailAndPassword(auth, email, password);
            // We don't even need to show a success message here, as the app will
            // naturally transition to the loading screen and then the dashboard.
        } catch (error) {
            console.error("Error logging in:", error);
            let errorMessage = "Login failed. Please check your credentials.";
            if (error.code === 'auth/user-not-found' || error.code === 'auth/wrong-password' || error.code === 'auth/invalid-credential') {
                errorMessage = "Incorrect email or password. Please try again.";
            }
            showMessage(errorMessage);
        }
    };

    return (
        <div className="screenContainer">
            <p className="heading">Creator Login</p>
            <p className="subHeading">Access your dashboard to manage your content and campaigns.</p>
            <form onSubmit={handleSubmit} className="loginForm"><div className="formGroup"><label htmlFor="loginEmail" className="formLabel">Email:</label><input type="email" id="loginEmail" className="formInput" value={email} onChange={(e) => setEmail(e.target.value)} required /></div><div className="formGroup"><label htmlFor="loginPassword" className="formLabel">Password:</label><input type="password" id="loginPassword" className="formInput" value={password} onChange={(e) => setPassword(e.target.value)} required /></div><button type="submit" className="button"><span className="buttonText">Login</span></button></form>
            <p className="smallText" style={{ marginTop: '20px' }}>Don't have an account?{' '}<a href="#" className="termsLink" onClick={(e) => { e.preventDefault(); setActiveScreen('CreatorSignUp'); }}>Sign Up Here</a></p>
            <p className="smallText" style={{ marginTop: '10px' }}>
                <a href="#" className="termsLink" onClick={(e) => { e.preventDefault(); setActiveScreen('ForgotPassword'); }}>Forgot Password?</a>
            </p>
            <button className="button" onClick={() => setActiveScreen('Home')} style={{ backgroundColor: '#3A3A3A', marginTop: '30px' }}><span className="buttonText light">Back to Home</span></button>
        </div>
    );
};


const UserSignUpScreen = ({ showMessage, setActiveScreen }) => {
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const [agreedToTerms, setAgreedToTerms] = useState(false);

    const handleSubmit = async (e) => {
        e.preventDefault();
        if (!agreedToTerms) {
            showMessage('Please agree to the Terms & Conditions to sign up.');
            return;
        }

        if (password.length < 8) {
            showMessage('Password must be at least 8 characters long.');
            return;
        }
        if (!/\d/.test(password)) {
            showMessage('Password must include at least one number.');
            return;
        }
        if (!/[A-Z]/.test(password)) {
            showMessage('Password must include at least one capital letter.');
            return;
        }

        try {
            const userCredential = await createUserWithEmailAndPassword(auth, email, password);
            const user = userCredential.user;

            // This is the new, required step
            await sendEmailVerification(user);

            const creatorRef = doc(db, "creators", user.uid);
            // This is the full data structure from your original, working component
            await setDoc(creatorRef, {
                email: user.email,
                creatorName: user.email.split('@')[0] || "",
                bio: "",
                categories: [],
                existingWorkLink: "",
                profilePictureUrl: '',
                uploadedVideos: { youtube: null, facebook: null, tiktok: null },
                createdAt: new Date().toISOString(),
                role: 'user',
                banned: false
            });
                
            showMessage(`Account created successfully for ${email}! Please check your inbox to verify your account.`);
            setActiveScreen('VerifyEmail'); // Redirect to the verification screen
        }
        catch (error) {
            console.error("Error signing up user:", error);
            let errorMessage = "Failed to sign up. Please try again.";
            if (error.code === 'auth/email-already-in-use') {
                errorMessage = "This email is already in use. Please use a different email or sign in.";
            } else if (error.code === 'auth/invalid-email') {
                errorMessage = "Invalid email address format.";
            } else if (error.code === 'auth/weak-password') {
                errorMessage = "Password is too weak. Please choose a stronger password.";
            }
            showMessage(errorMessage);
        }
    };

    return (
        <div className="screenContainer">
            <p className="heading">Create Your Account</p>
            <p className="subHeading">Sign up to access exclusive content and support creators!</p>

            <form onSubmit={handleSubmit}>
                <div className="formGroup">
                    <label htmlFor="userEmail" className="formLabel">Email:</label>
                    <input
                        type="email"
                        id="userEmail"
                        className="formInput"
                        value={email}
                        onChange={(e) => setEmail(e.target.value)}
                        required
                    />
                </div>

                <div className="formGroup">
                    <label htmlFor="userPassword" className="formLabel">Password:</label>
                    <input
                        type="password"
                        id="userPassword"
                        className="formInput"
                        value={password}
                        onChange={(e) => setPassword(e.target.value)}
                        required
                    />
                    <p className="smallText" style={{ textAlign: 'left', color: '#FFD700', marginTop: '5px' }}>
                        Password must be at least 8 characters long, include at least one number and one capital letter.
                    </p>
                </div>

                <div className="formGroup">
                    <div className="checkboxItem">
                        <input
                            type="checkbox"
                            id="agreeUserTerms"
                            checked={agreedToTerms}
                            onChange={(e) => setAgreedToTerms(e.target.checked)}
                            required
                        />
                        <label htmlFor="agreeUserTerms">
                            I agree to the <a href="#" className="termsLink" onClick={(e) => { e.preventDefault(); showMessage('Simulating opening User Terms & Conditions...'); }}>Terms & Conditions</a>.
                        </label>
                    </div>
                </div>

                <button type="submit" className="button">
                    <span className="buttonText">Sign Up</span>
                </button>
            </form>

            <p className="smallText" style={{ marginTop: '20px' }}>
                Already have an account?{' '}
                <a href="#" className="termsLink" onClick={(e) => { e.preventDefault(); setActiveScreen('Login'); }}>Login Here</a>
            </p>

            <button
                className="button"
                onClick={() => setActiveScreen('Home')}
                style={{ backgroundColor: '#3A3A3A', color: '#FFF', marginTop: '30px' }}
            >
                <span className="buttonText">Back to Home</span>
            </button>
        </div>
    );
};

// --- REPLACE CreatorSignUpScreen WITH THIS COMPLETE VERSION ---
const CreatorSignUpScreen = ({ showMessage, setActiveScreen }) => {
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const [creatorName, setCreatorName] = useState('');
    const [bio, setBio] = useState('');
    const [selectedCategories, setSelectedCategories] = useState([]);
    const [existingWorkLink, setExistingWorkLink] = useState('');
    const [agreedToTerms, setAgreedToTerms] = useState(false);
    const availableCategories = ['Skits', 'Short Films', 'Interviews', 'Live Premieres', 'Music', 'Documentary', 'Other'];

    const handleCategoryChange = (e) => { const { value, checked } = e.target; setSelectedCategories(prev => checked ? [...prev, value] : prev.filter(cat => cat !== value)); };

    const handleSubmit = async (e) => {
        e.preventDefault();
        if (!agreedToTerms) { showMessage('Please agree to the Creator Terms & Conditions to sign up.'); return; }
        if (password.length < 8 || !/\d/.test(password) || !/[A-Z]/.test(password)) { showMessage('Password must be at least 8 characters, with a number and a capital letter.'); return; }

        try {
            const userCredential = await createUserWithEmailAndPassword(auth, email, password);
            const user = userCredential.user;
            await sendEmailVerification(user);
            const creatorRef = doc(db, "creators", user.uid);
            await setDoc(creatorRef, { email: user.email, creatorName: creatorName, bio: bio, categories: selectedCategories, existingWorkLink: existingWorkLink, profilePictureUrl: '', createdAt: new Date().toISOString(), role: 'creator', banned: false });
            showMessage(`Creator "${creatorName}" signed up! Please check your inbox to verify your account.`);
            setActiveScreen('VerifyEmail');
        } catch (error) {
            console.error("Error signing up creator:", error);
            let errorMessage = "Failed to sign up. Please try again.";
            if (error.code === 'auth/email-already-in-use') { errorMessage = "This email is already in use."; }
            showMessage(errorMessage);
        }
    };

    return (
        <div className="screenContainer">
            <p className="heading">Join NVA Network as a Creator!</p>
            <form onSubmit={handleSubmit}>
                <div className="formGroup"><label htmlFor="email" className="formLabel">Email:</label><input type="email" id="email" className="formInput" value={email} onChange={(e) => setEmail(e.target.value)} required /></div>
                <div className="formGroup"><label htmlFor="password" className="formLabel">Password:</label><input type="password" id="password" className="formInput" value={password} onChange={(e) => setPassword(e.target.value)} required /></div>
                <div className="formGroup"><label htmlFor="creatorName" className="formLabel">Creator Name (Public):</label><input type="text" id="creatorName" className="formInput" value={creatorName} onChange={(e) => setCreatorName(e.target.value)} required /></div>
                <div className="formGroup"><label htmlFor="bio" className="formLabel">Brief Bio/Description:</label><textarea id="bio" className="formTextarea" value={bio} onChange={(e) => setBio(e.target.value)} placeholder="Tell us about yourself!" required ></textarea></div>
                <div className="checkboxGroup"><p className="checkboxLabel">Content Categories:</p>{availableCategories.map((cat) => (<div key={cat} className="checkboxItem"><input type="checkbox" id={`cat-${cat}`} value={cat} checked={selectedCategories.includes(cat)} onChange={handleCategoryChange} /><label htmlFor={`cat-${cat}`}>{cat}</label></div>))}</div>
                <div className="formGroup"><label htmlFor="existingWork" className="formLabel">Link to Existing Work (Optional):</label><input type="url" id="existingWork" className="formInput" value={existingWorkLink} onChange={(e) => setExistingWorkLink(e.target.value)} placeholder="e.g., YouTube channel" /></div>
                <div className="formGroup"><div className="checkboxItem"><input type="checkbox" id="agreeTerms" checked={agreedToTerms} onChange={(e) => setAgreedToTerms(e.target.checked)} required /><label htmlFor="agreeTerms">I agree to the <a href="#" className="termsLink" onClick={(e) => { e.preventDefault(); showMessage('Simulating opening Creator Terms...'); }}>Creator Terms & Conditions</a>.</label></div></div>
                <button type="submit" className="button"><span className="buttonText">Sign Up as Creator</span></button>
            </form>
        </div>
    );
};


const CreatorDashboardScreen = ({
    showMessage,
    setActiveScreen,
    currentUser,
    creatorProfile,
    setCreatorProfile,
    setSelectedCampaignId,
    setShowConfirmationModal,
    setConfirmationTitle,
    setConfirmationMessage,
    setOnConfirmationAction
}) => {
    const [creatorCampaigns, setCreatorCampaigns] = useState([]);
    const [isEditingProfile, setIsEditingProfile] = useState(false);
    const [editCreatorName, setEditCreatorName] = useState('');
    const [editBio, setEditBio] = useState('');
    const [editCategories, setEditCategories] = useState([]);
    const [editExistingWorkLink, setEditExistingWorkLink] = useState('');
    const availableCategories = ['Skits', 'Short Films', 'Interviews', 'Live Premieres', 'Music', 'Documentary', 'Other'];
    const [videoLinkInput, setVideoLinkInput] = useState('');
    const [customThumbnailFile, setCustomThumbnailFile] = useState(null);
    const [customThumbnailPreview, setCustomThumbnailPreview] = useState('');
    const [autoThumbnailPreview, setAutoThumbnailPreview] = useState('');
    const [isPublishing, setIsPublishing] = useState(false);
    const thumbnailFileInputRef = useRef(null);
    const profilePictureInputRef = useRef(null);
    const [showImageAdjustModal, setShowImageAdjustModal] = useState(false);
    const [imageFileToAdjust, setImageFileToAdjust] = useState(null);
    const [isUploadingPFP, setIsUploadingPFP] = useState(false);
    const [liveEventId, setLiveEventId] = useState(null);

    // THIS IS THE FIX: Define the constants for use throughout the component
    const isVerified = creatorProfile?.isVerifiedAdvertiser && creatorProfile.verifiedAdvertiserExpiresAt && creatorProfile.verifiedAdvertiserExpiresAt.toDate() > new Date();
    const isPremium = creatorProfile?.premiumExpiresAt && creatorProfile.premiumExpiresAt.toDate() > new Date();

    const endCampaignEarlyLogic = async (campaignId) => {
        showMessage("Ending campaign...");
        try {
            const functions = getFunctions(window.firebaseApp);
            const endCampaignCallable = httpsCallable(functions, 'endCampaignEarly');
            await endCampaignCallable({ campaignId: campaignId, appId: window.appId });
            showMessage("Campaign ended successfully and a notification has been sent!");
            // The onSnapshot listener will automatically update the campaign's status on screen.
        } catch (error) {
            console.error("Error ending campaign early:", error);
            showMessage(`Error: ${error.message}`);
        }
    };

    const confirmEndCampaignEarly = (campaignId, campaignTitle) => {
        setConfirmationTitle("End Campaign Successfully?");
        setConfirmationMessage(`This will permanently end your campaign "${campaignTitle}", send a success notification to all users, and start your 30-day cooldown. Are you sure?`);
        setOnConfirmationAction(() => () => endCampaignEarlyLogic(campaignId));
        setShowConfirmationModal(true);
    };

    useEffect(() => {
        const categoriesRef = collection(db, "content_categories");
        const q = query(categoriesRef, where("name", "==", "Live Premieres"));
        const unsubscribe = onSnapshot(q, (snapshot) => {
            if (!snapshot.empty) { setLiveEventId(snapshot.docs[0].data().liveStreamEventId || null); } else { setLiveEventId(null); }
        });
        return () => unsubscribe();
    }, []);

    useEffect(() => {
        let unsubscribe = () => {};
        if (currentUser) {
            const campaignsCollectionRef = collection(db, `artifacts/${appId}/public/data/campaigns`);
            const q = query(campaignsCollectionRef, where('creatorId', '==', currentUser.uid), orderBy('createdAt', 'desc'));
            unsubscribe = onSnapshot(q, (snapshot) => { setCreatorCampaigns(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }))); });
        } else { setCreatorCampaigns([]); }
        return () => unsubscribe();
    }, [currentUser]);

    useEffect(() => { if (creatorProfile) { setEditCreatorName(creatorProfile.creatorName || ''); setEditBio(creatorProfile.bio || ''); setEditCategories(creatorProfile.categories || []); setEditExistingWorkLink(creatorProfile.existingWorkLink || ''); setVideoLinkInput(creatorProfile.featuredVideoLink?.url || ''); } }, [creatorProfile]);
    useEffect(() => { setAutoThumbnailPreview(''); if (!videoLinkInput || (creatorProfile.featuredVideoLink && videoLinkInput === creatorProfile.featuredVideoLink.url)) return; const handler = setTimeout(() => { const { thumbnailUrl } = extractVideoInfo(videoLinkInput); if (thumbnailUrl) setAutoThumbnailPreview(thumbnailUrl); }, 600); return () => clearTimeout(handler); }, [videoLinkInput]);
    const handleSaveProfile = async () => { if (!editCreatorName) { showMessage("Creator name cannot be empty."); return; } try { const creatorRef = doc(db, "creators", currentUser.uid); await updateDoc(creatorRef, { creatorName: editCreatorName, bio: editBio, categories: editCategories, existingWorkLink: editExistingWorkLink, updatedAt: new Date().toISOString() }); setCreatorProfile(prev => ({ ...prev, creatorName: editCreatorName, bio: editBio, categories: editCategories, existingWorkLink: editExistingWorkLink })); setIsEditingProfile(false); showMessage('Profile updated successfully!'); } catch (error) { showMessage(`Failed to update profile: ${error.message}`); } };
    const handleCancelEdit = () => { if (creatorProfile) { setEditCreatorName(creatorProfile.creatorName || ''); setEditBio(creatorProfile.bio || ''); setEditCategories(creatorProfile.categories || []); setEditExistingWorkLink(creatorProfile.existingWorkLink || ''); } setIsEditingProfile(false); };
    const handleProfileCategoryChange = (e) => { const { value, checked } = e.target; setEditCategories(prev => checked ? [...prev, value] : prev.filter(cat => cat !== value)); };
    const triggerProfilePictureUpload = (e) => { const file = e.target.files[0]; if (file) { setImageFileToAdjust(file); setShowImageAdjustModal(true); } };
    const handleSaveAdjustedProfilePicture = async (adjustedBlob) => { if (!currentUser || !adjustedBlob) return; setIsUploadingPFP(true); showMessage("Uploading..."); try { const filePath = `profile_pictures/${currentUser.uid}/profile_${Date.now()}.png`; const storageRefPath = ref(storage, filePath); const snapshot = await uploadBytes(storageRefPath, adjustedBlob); const downloadURL = await getDownloadURL(snapshot.ref); const creatorRef = doc(db, "creators", currentUser.uid); await updateDoc(creatorRef, { profilePictureUrl: downloadURL }); setCreatorProfile(prev => ({ ...prev, profilePictureUrl: downloadURL })); setShowImageAdjustModal(false); showMessage("Profile picture updated!"); } catch (error) { showMessage(`Failed to update profile picture: ${error.message}`); } finally { if (profilePictureInputRef.current) { profilePictureInputRef.current.value = null; } setIsUploadingPFP(false); } };
    const handleCancelAdjust = () => { setImageFileToAdjust(null); setShowImageAdjustModal(false); };
    const handleCancelCampaign = async (campaignId, campaignTitle) => { try { const campaignRef = doc(db, `artifacts/${appId}/public/data/campaigns`, campaignId); await updateDoc(campaignRef, { status: 'cancelled', updatedAt: new Date().toISOString(), statusChangedAt: new Date().toISOString() }); showMessage(`Campaign "${campaignTitle}" has been cancelled.`); } catch (error) { showMessage(`Failed to cancel campaign: ${error.message}`); } };
    const confirmCancelCampaign = (campaignId, campaignTitle) => { setConfirmationTitle("Cancel Campaign?"); setConfirmationMessage(`Are you sure you want to cancel your campaign "${campaignTitle}"? This cannot be undone.`); setOnConfirmationAction(() => () => handleCancelCampaign(campaignId, campaignTitle)); setShowConfirmationModal(true); };
    const handleAddOrUpdateVideo = async () => { if (!videoLinkInput) { showMessage('Please paste a URL first.'); return; } setIsPublishing(true); const { videoId, thumbnailUrl: autoThumbnailUrl, embedUrl, platform } = extractVideoInfo(videoLinkInput); if (!videoId) { showMessage('Invalid or unsupported URL.'); setIsPublishing(false); return; } let finalThumbnailUrl = autoThumbnailUrl; if (customThumbnailFile) { showMessage('Uploading...'); try { const fileName = `thumb_${currentUser.uid}_${Date.now()}`; const storageRefPath = ref(storage, `creator_uploads/${currentUser.uid}/${fileName}`); await uploadBytes(storageRefPath, customThumbnailFile); finalThumbnailUrl = await getDownloadURL(storageRefPath); showMessage('Thumbnail uploaded!'); } catch (error) { showMessage(`Upload failed: ${error.message}`); setIsPublishing(false); return; } } let newContentRef; try { const contentCollectionRef = collection(db, `artifacts/${appId}/public/data/content_items`); newContentRef = await addDoc(contentCollectionRef, { title: `New from ${creatorProfile.creatorName}`, description: `...`, mainUrl: videoLinkInput, customThumbnailUrl: finalThumbnailUrl, embedUrl, videoPlatform: platform, creatorId: currentUser.uid, creatorName: creatorProfile.creatorName, contentType: 'Live Feed', orderIndex: Date.now(), isActive: true, createdAt: new Date().toISOString(), createdBy: currentUser.uid, viewCount: 0, likeCount: 0 }); showMessage('Published to Live Feed!'); } catch (error) { showMessage(`Failed to publish: ${error.message}`); setIsPublishing(false); return; } const videoData = { url: videoLinkInput, thumbnailUrl: finalThumbnailUrl, embedUrl, platform, liveFeedContentId: newContentRef.id }; try { const creatorRef = doc(db, "creators", currentUser.uid); await updateDoc(creatorRef, { featuredVideoLink: videoData, updatedAt: new Date().toISOString() }); setCreatorProfile(prev => ({ ...prev, featuredVideoLink: videoData })); showMessage('Featured link has been set!'); } catch (error) { showMessage(`Failed to update profile: ${error.message}`); } finally { setIsPublishing(false); } };
    const handleRemoveVideo = () => { const videoToRemove = creatorProfile.featuredVideoLink; if (!videoToRemove) return; const deletionLogic = async () => { setIsPublishing(true); if (videoToRemove.liveFeedContentId) { try { await deleteDoc(doc(db, `artifacts/${appId}/public/data/content_items`, videoToRemove.liveFeedContentId)); showMessage('Post removed from Live Feed.'); } catch (error) { showMessage(`Could not remove from feed: ${error.message}`); } } try { const creatorRef = doc(db, "creators", currentUser.uid); await updateDoc(creatorRef, { featuredVideoLink: null, updatedAt: new Date().toISOString() }); setCreatorProfile(prev => ({ ...prev, featuredVideoLink: null })); setVideoLinkInput(''); setCustomThumbnailFile(null); setCustomThumbnailPreview(''); setAutoThumbnailPreview(''); showMessage('Featured link removed.'); } catch (error) { showMessage(`Failed to remove link: ${error.message}`); } finally { setIsPublishing(false); } }; setShowConfirmationModal(true); setConfirmationTitle("Remove Featured Link?"); setConfirmationMessage("Are you sure? This will remove the link and delete the post from the public Live Feed."); setOnConfirmationAction(() => deletionLogic); };
    if (!creatorProfile) { return (<div className="screenContainer" style={{ textAlign: 'center', paddingTop: '50px' }}><p className="heading">Loading Your Dashboard...</p></div>); }
    const hasActiveOrPendingCampaign = creatorCampaigns.some(c => c.status === 'active' || c.status === 'pending');
    const currentThumbnail = customThumbnailPreview || (creatorProfile.featuredVideoLink?.thumbnailUrl) || autoThumbnailPreview;
    const hasValidTicket = liveEventId && creatorProfile?.purchasedTickets?.[liveEventId];

    return (
        <>
            <div className="screenContainer">
                <p className="heading">Dashboard</p>
                <p className="subHeading">Welcome, {creatorProfile.creatorName || currentUser.email}!</p>
                <div className="dashboardSection">
                    <div className="flex justify-between items-center"><p className="dashboardSectionTitle" style={{marginBottom: 0}}>Your Profile</p> {!isEditingProfile ? (<button className="dashboardButton" onClick={() => setIsEditingProfile(true)}>Edit Profile</button>) : (<div><button className="dashboardButton" onClick={handleSaveProfile} style={{backgroundColor: '#008000'}}>Save</button><button className="dashboardButton" onClick={handleCancelEdit} style={{backgroundColor: '#555', color: '#FFF'}}>Cancel</button></div>)}</div>
                    <div className="pt-4 border-t border-gray-200 mt-4" style={{borderColor: '#3A3A3A'}}>
                        {isEditingProfile ? (
                            <>
                                <div className="formGroup">
                                    <label htmlFor="editCreatorName" className="formLabel">Creator Name:</label>
                                    <input type="text" id="editCreatorName" className="formInput" value={editCreatorName} onChange={(e) => setEditCreatorName(e.target.value)} required />
                                </div>
                                <div className="formGroup">
                                    <label htmlFor="editBio" className="formLabel">Bio:</label>
                                    <textarea id="editBio" className="formTextarea" value={editBio} onChange={(e) => setEditBio(e.target.value)}></textarea>
                                </div>
                                <div className="checkboxGroup">
                                    <p className="checkboxLabel">My Content Categories:</p>
                                    {availableCategories.map((cat) => (
                                        <div key={cat} className="checkboxItem">
                                            <input type="checkbox" id={`edit-cat-${cat}`} value={cat} checked={editCategories.includes(cat)} onChange={handleProfileCategoryChange} />
                                            <label htmlFor={`edit-cat-${cat}`}>{cat}</label>
                                        </div>
                                    ))}
                                </div>
                                <div className="formGroup">
                                    <label htmlFor="editExistingWork" className="formLabel">External Link (Portfolio, Channel, etc.):</label>
                                    <input type="url" id="editExistingWork" className="formInput" value={editExistingWorkLink} onChange={(e) => setEditExistingWorkLink(e.target.value)} />
                                </div>
                            </>
                        ) : (
                            <>
                                <div className="flex items-center mb-4">
                                    <div className="relative">
                                        <img src={creatorProfile.profilePictureUrl || 'https://placehold.co/100x100/555/FFF?text=P'} alt="Profile" style={{width: '100px', height: '100px', borderRadius: '50%', border: '2px solid #FFD700', objectFit: 'cover'}} />
                                        <input type="file" ref={profilePictureInputRef} onChange={triggerProfilePictureUpload} accept="image/*" style={{ display: 'none' }} />
                                        <button onClick={() => profilePictureInputRef.current.click()} style={{backgroundColor: '#FFD700', color: '#0A0A0A', width: '30px', height: '30px', borderRadius: '50%', border: 'none', cursor: 'pointer', position: 'absolute', bottom: 0, right: 0, display: 'flex', alignItems: 'center', justifyContent: 'center'}}>✏️</button>
                                    </div>
                                    <div style={{marginLeft: '1rem'}}>
                                        <p className="dashboardItem" style={{fontSize: '18px', fontWeight: 'bold', color: '#FFF'}}>{creatorProfile.creatorName}</p>
                                        
                                        {/* THIS IS THE FIX: This block now contains all status badges */}
                                       <div style={{ display: 'flex', alignItems: 'center', gap: '10px', marginTop: '4px' }}>
                                            <p className="dashboardItem" style={{fontSize: '12px', color: '#AAA', margin: 0}}>Role: {creatorProfile.role}</p>
                                            {isPremium && (
                                                <span style={{ backgroundColor: '#FFD700', color: '#0A0A0A', padding: '3px 8px', borderRadius: '10px', fontSize: '10px', fontWeight: 'bold'}}>👑 Premium</span>
                                            )}
                                            {isVerified && (
                                                <span style={{ backgroundColor: '#00FFFF', color: '#0A0A0A', padding: '3px 8px', borderRadius: '10px', fontSize: '10px', fontWeight: 'bold'}}>✔ Verified</span>
                                            )}
                                        </div>

                                        {hasValidTicket && (<div style={{marginTop: '8px', display: 'flex', alignItems: 'center', gap: '5px', backgroundColor: '#008000', padding: '3px 8px', borderRadius: '10px', width: 'fit-content'}}><svg viewBox="0 0 20 20" fill="currentColor" style={{width: '16px', height: '16px', color: '#FFF'}}><path fillRule="evenodd" d="M15.5,2 L15.5,2 C17.709139,2 19.5,3.790861 19.5,6 L19.5,14 C19.5,16.209139 17.709139,18 15.5,18 L15.5,18 C14.3954305,18 13.5,17.1045695 13.5,16 L13.5,4 C13.5,2.8954305 14.3954305,2 15.5,2 Z M4.5,2 L4.5,2 C2.290861,2 0.5,3.790861 0.5,6 L0.5,14 C0.5,16.209139 2.290861,18 4.5,18 L4.5,18 C5.6045695,18 6.5,17.1045695 6.5,16 L6.5,4 C6.5,2.8954305 5.6045695,2 4.5,2 Z M9.5,2 C8.3954305,2 7.5,2.8954305 7.5,4 L7.5,16 C7.5,17.1045695 8.3954305,18 9.5,18 C10.6045695,18 11.5,17.1045695 11.5,16 L11.5,4 C11.5,2.8954305 10.6045695,2 9.5,2 Z" clipRule="evenodd"></path></svg><span style={{color: '#FFF', fontSize: '10px', fontWeight: 'bold'}}>EVENT TICKET HOLDER</span></div>)}
                                        <div style={{display: 'flex', gap: '15px', marginTop: '10px'}}><div className="dashboardItem termsLink" style={{cursor: 'pointer'}} onClick={() => setActiveScreen('Followers')}><strong>{creatorProfile.followerCount || 0}</strong> Followers</div><div className="dashboardItem termsLink" style={{cursor: 'pointer'}} onClick={() => setActiveScreen('MyFollows')}><strong>{creatorProfile.followingCount || 0}</strong> Following</div></div>
                                    </div>
                                </div>
                                <p className="dashboardItem"><strong>Bio:</strong> {creatorProfile.bio || "No bio set."}</p><p className="dashboardItem"><strong>Categories:</strong> {creatorProfile.categories?.length > 0 ? creatorProfile.categories.join(', ') : "No categories set."}</p><p className="dashboardItem"><strong>External Link:</strong> {creatorProfile.existingWorkLink ? <a href={creatorProfile.existingWorkLink} target="_blank" rel="noopener noreferrer" className="termsLink">{creatorProfile.existingWorkLink}</a> : "No link set."}</p>
                            </>
                        )}
                    </div>
                </div>

                {/* THIS IS THE RESTORED CODE BLOCK */}
                {(creatorProfile.role === 'creator' || creatorProfile.role === 'admin') && (
                    <>
                        <div className="dashboardSection">
                            <div className="flex justify-between items-center">
                                <p className="dashboardSectionTitle" style={{marginBottom: 0}}>My Crowdfunding Campaigns</p>
                                <button 
                                    className="dashboardButton" 
                                    onClick={() => setActiveScreen('CreateCampaign')} 
                                    disabled={hasActiveOrPendingCampaign || (creatorProfile.canCreateCampaignAfter && creatorProfile.canCreateCampaignAfter.toDate() > new Date())} 
                                    style={(hasActiveOrPendingCampaign || (creatorProfile.canCreateCampaignAfter && creatorProfile.canCreateCampaignAfter.toDate() > new Date())) ? {cursor: 'not-allowed', backgroundColor: '#555', color: '#999'} : {}}
                                >
                                    Create New
                                </button>
                            </div>
                            <div className="pt-4 border-t border-gray-200 mt-4" style={{borderColor: '#3A3A3A'}}>
                                {creatorCampaigns.length === 0 ? (<p className="dashboardItem">You have not created any campaigns yet.</p>) : (creatorCampaigns.map(campaign => ( <div key={campaign.id} className="creator-campaign-list-item" onClick={() => { setSelectedCampaignId(campaign.id); setActiveScreen('CampaignDetails'); }} style={{ cursor: 'pointer', flexDirection: 'column', alignItems: 'stretch' }}><div style={{ display: 'flex', alignItems: 'center', width: '100%' }}><img src={campaign.imageUrl || 'https://placehold.co/80x50/3A3A3A/FFF?text=NVA'} alt={campaign.title} className="creator-campaign-thumbnail" onError={(e) => { e.target.src = 'https://placehold.co/80x50/3A3A3A/FFF?text=Error'; }}/><div className="creator-campaign-info"><p className="creator-campaign-title">{campaign.title}</p><p className={`creator-campaign-status status-${campaign.status}`}>Status: {campaign.status.charAt(0).toUpperCase() + campaign.status.slice(1)}</p></div></div><div style={{width: '100%', marginTop: '10px'}}><div className="campaignProgressContainer" style={{ height: '8px' }}><div className="campaignProgressBar" style={{ width: `${(campaign.raised / campaign.goal) * 100}%` }}></div></div><div className="campaignListStats" style={{marginTop: '4px'}}><span>Raised: <span className="campaignListRaised">${campaign.raised || 0}</span></span><span>Goal: <span className="campaignListGoal">${campaign.goal}</span></span></div></div><div style={{display: 'flex', justifyContent: 'flex-end', gap: '10px', width: '100%', marginTop: '10px'}}>{campaign.status === 'active' && campaign.raised >= campaign.goal && (<button className="actionButton" style={{backgroundColor: '#008000'}} onClick={(e) => { e.stopPropagation(); confirmEndCampaignEarly(campaign.id, campaign.title); }}>End Campaign Early</button>)}{campaign.status !== 'cancelled' && campaign.status !== 'ended' && (<button className="actionButton" style={{backgroundColor: '#DC3545'}} onClick={(e) => { e.stopPropagation(); confirmCancelCampaign(campaign.id, campaign.title); }}>Cancel</button>)}</div></div> )))}
                                {hasActiveOrPendingCampaign && (<p className="smallText" style={{textAlign: 'center', color: '#FFD700', marginTop: '15px'}}>You must cancel or wait for your current campaign to finish before creating a new one.</p>)}
                            </div>
                        </div>

                        <div className="dashboardSection">
                            <p className="dashboardSectionTitle">My Featured Link</p>
                            <p className="dashboardItem" style={{color: '#AAA', lineHeight: 1.4, marginBottom: '15px'}}> This is the content currently featured on your profile and in the Live Feed. Use the manager to change it.</p>
                            {creatorProfile.featuredVideoLink ? (
                                <div className="vertical-carousel-item" style={{backgroundColor: '#1A1A1A'}}>
                                    <div style={{width: '80px', height: '60px', flexShrink: 0, marginRight: '10px'}}>
                                         <DynamicThumbnail 
                                            item={{ mainUrl: creatorProfile.featuredVideoLink.url, imageUrl: creatorProfile.featuredVideoLink.thumbnailUrl }} 
                                            onClick={() => handleVideoPress(creatorProfile.featuredVideoLink.embedUrl || creatorProfile.featuredVideoLink.url, creatorProfile.featuredVideoLink)} 
                                        />
                                    </div>
                                    <div className="liveFeedContent">
                                        <p className="liveFeedTitle">{`Currently Featuring: Your Latest Link`}</p>
                                        <p className="liveFeedCreator" style={{color: '#FFD700'}}>Visible on your profile</p>
                                    </div>
                                </div>
                            ) : (
                                <p className="dashboardItem">You do not have a featured link set. Go to your library to set one.</p>
                            )}
                            <button className="button" onClick={() => setActiveScreen('MyContentLibrary')} style={{marginTop: '15px'}}>
                                <span className="buttonText">Manage My Content Library</span>
                            </button>
                        </div>
                    </>
                )}

                  {/* Verified Advertiser Features (Available to both 'user' and 'creator' roles if verified) */}
                {isVerified && (
                    <div className="dashboardSection" style={{border: '1px solid #00FFFF'}}>
                        <p className="dashboardSectionTitle" style={{color: '#00FFFF'}}>Promoted Status Billboard</p>
                        <p className="dashboardItem" style={{color: '#AAA', lineHeight: 1.4, marginBottom: '15px'}}>
                            Manage your existing bookings or reserve a new 24-hour "Billboard" slot on the Home page.
                        </p>
                        <div style={{display: 'flex', gap: '10px', marginTop: '15px'}}>
                            <button className="button" onClick={() => setActiveScreen('PromotedStatus')} style={{flex: 1, margin: 0, backgroundColor: '#3A3A3A'}}>
                                <span className="buttonText light">Manage Bookings</span>
                            </button>
                            <button className="button" onClick={() => setActiveScreen('BookStatus')} style={{flex: 1, margin: 0}}>
                                <span className="buttonText">Book New Slot</span>
                            </button>
                        </div>
                    </div>
                )}

                {/* My Listings - Visible to Premium OR Verified */}
                {(isVerified || isPremium) && (
                    <div className="dashboardSection">
                        <p className="dashboardSectionTitle">My Opportunity Listings</p>
                        <p className="dashboardItem" style={{color: '#AAA', lineHeight: 1.4, marginBottom: '15px'}}>
                            Manage your posts for the Creator Connect hub.
                        </p>
                         <button className="button" onClick={() => setActiveScreen('MyListings')} style={{marginTop: '0px'}}>
                            <span className="buttonText">Manage My Listings</span>
                        </button>
                    </div>
                )}

                {/* Features Available to ALL Logged-in Users */}
                <div className="dashboardSection">
                    <p className="dashboardSectionTitle">My Saved Opportunities</p>
                    <p className="dashboardItem" style={{color: '#AAA', lineHeight: 1.4, marginBottom: '15px'}}>
                        View the listings you have bookmarked.
                    </p>
                    <button className="button" onClick={() => setActiveScreen('SavedOpportunities')} style={{marginTop: '0px'}}>
                        <span className="buttonText">View Saved</span>
                    </button>
                </div>
                
                <button className="button" onClick={() => setActiveScreen('Home')} style={{ backgroundColor: '#3A3A3A', marginTop: '30px' }}><span className="buttonText light">Back to Home</span></button>
            </div>
            {showImageAdjustModal && imageFileToAdjust && (<ProfilePictureAdjustModal isUploading={isUploadingPFP} imageUrl={URL.createObjectURL(imageFileToAdjust)} onSave={handleSaveAdjustedProfilePicture} onCancel={handleCancelAdjust} showMessage={showMessage} />)}
        </>
    );
};

                        // START: ADDITION (New MyContentLibraryScreen Component)
// --- START: FULL COMPONENT REPLACEMENT ---
const MyContentLibraryScreen = ({
    showMessage,
    setActiveScreen,
    currentUser,
    creatorProfile,
    setShowConfirmationModal,
    setConfirmationTitle,
    setConfirmationMessage,
    setOnConfirmationAction,
    handleVideoPress
}) => {
    const [title, setTitle] = useState('');
    const [description, setDescription] = useState('');
    const [videoLinkInput, setVideoLinkInput] = useState('');
    const [contentType, setContentType] = useState('');
    const [isPublishing, setIsPublishing] = useState(false);
    const [customThumbnailFile, setCustomThumbnailFile] = useState(null);
    const [customThumbnailPreview, setCustomThumbnailPreview] = useState('');
    const [autoThumbnailPreview, setAutoThumbnailPreview] = useState('');
    const thumbnailFileInputRef = useRef(null);
    const [availableCategories, setAvailableCategories] = useState([]);
    const [libraryItems, setLibraryItems] = useState([]);
    const [loadingLibrary, setLoadingLibrary] = useState(true);
    const [searchTerm, setSearchTerm] = useState('');
    const [isLibraryExpanded, setIsLibraryExpanded] = useState(true);
    const [isUpdatingFeature, setIsUpdatingFeature] = useState(null);
    const [isUpdatingPin, setIsUpdatingPin] = useState(null);

    // --- STATE and HANDLERS for Image Adjustment Modal ---
    const [showImageAdjustModal, setShowImageAdjustModal] = useState(false);
    const [imageFileToAdjust, setImageFileToAdjust] = useState(null);

    const handleThumbnailFileSelect = (e) => {
        const file = e.target.files[0];
        if (file) {
            setImageFileToAdjust(file);
            setShowImageAdjustModal(true);
        }
    };

    const handleThumbnailSave = (adjustedBlob) => {
        const newFile = new File([adjustedBlob], "custom_thumbnail.png", { type: "image/png" });
        setCustomThumbnailFile(newFile);
        setCustomThumbnailPreview(URL.createObjectURL(newFile));
        setShowImageAdjustModal(false);
    };

    const handleThumbnailCancel = () => {
        setImageFileToAdjust(null);
        setShowImageAdjustModal(false);
        if (thumbnailFileInputRef.current) {
            thumbnailFileInputRef.current.value = null;
        }
    };

    useEffect(() => {
        const categoriesRef = collection(db, "content_categories");
        const q = query(categoriesRef, where("isActive", "==", true), orderBy("orderIndex", "asc"));
        const unsubscribe = onSnapshot(q, (snapshot) => {
            const fetchedCategories = snapshot.docs.map(doc => doc.data().name).filter(name => name !== 'Live Feed');
            setAvailableCategories(fetchedCategories);
            if (fetchedCategories.length > 0 && !contentType) { setContentType(fetchedCategories[0]); }
        });
        return () => unsubscribe();
    }, []);

    useEffect(() => {
        if (!currentUser) return;
        setLoadingLibrary(true);
        const contentRef = collection(db, `artifacts/${appId}/public/data/content_items`);
        const q = query(contentRef, where('creatorId', '==', currentUser.uid), orderBy('createdAt', 'desc'));
        const unsubscribe = onSnapshot(q, (snapshot) => {
            setLibraryItems(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
            setLoadingLibrary(false);
        });
        return () => unsubscribe();
    }, [currentUser]);

    useEffect(() => {
        setAutoThumbnailPreview('');
        if (!videoLinkInput) return;
        const handler = setTimeout(() => {
            const { thumbnailUrl } = extractVideoInfo(videoLinkInput);
            if (thumbnailUrl) setAutoThumbnailPreview(thumbnailUrl);
        }, 600);
        return () => clearTimeout(handler);
    }, [videoLinkInput]);

    const resetForm = () => {
        setTitle(''); setDescription(''); setVideoLinkInput('');
        setContentType(availableCategories.length > 0 ? availableCategories[0] : '');
        setCustomThumbnailFile(null); setCustomThumbnailPreview(''); setAutoThumbnailPreview('');
        if (thumbnailFileInputRef.current) { thumbnailFileInputRef.current.value = null; }
    };
    
    const handleAddToLibrary = async () => {
        if (!title.trim() || !contentType || !videoLinkInput.trim()) { showMessage('Title, Content Type, and a URL are required.'); return; }
        setIsPublishing(true);
        let finalThumbnailUrl = '';

        if (customThumbnailFile) {
            showMessage('Uploading custom thumbnail...');
            try {
                const filePath = `content_thumbnails/${currentUser.uid}/${Date.now()}_${customThumbnailFile.name}`;
                const storageRefPath = ref(storage, filePath);
                const snapshot = await uploadBytes(storageRefPath, customThumbnailFile);
                finalThumbnailUrl = await getDownloadURL(snapshot.ref);
            } catch (error) {
                showMessage(`Thumbnail upload failed: ${error.message}`);
                setIsPublishing(false);
                return;
            }
        } 
        else if (autoThumbnailPreview && autoThumbnailPreview !== GENERIC_THUMBNAIL_PLACEHOLDER) {
            finalThumbnailUrl = autoThumbnailPreview;
        }
        else {
            showMessage("Could not get a thumbnail from this URL. Please upload a custom image to continue.");
            setIsPublishing(false);
            return;
        }
        
        const { embedUrl, platform } = extractVideoInfo(videoLinkInput);

        try {
            const addContentFunction = httpsCallable(functions, 'addContentToLibrary');
            await addContentFunction({
                appId: appId,
                contentData: {
                    title: title.trim(), description: description.trim(), mainUrl: videoLinkInput,
                    customThumbnailUrl: finalThumbnailUrl, embedUrl: embedUrl, videoPlatform: platform,
                    creatorName: creatorProfile.creatorName, creatorProfilePictureUrl: creatorProfile.profilePictureUrl || '',
                    contentType: contentType,
                }
            });
            showMessage(`"${title.trim()}" was added to your library.`);
            resetForm();
        } catch (error) { showMessage(`Failed to save content: ${error.message}`);
        } finally { setIsPublishing(false); }
    };

    const handleSetFeatured = async (itemToFeature) => {
        setIsUpdatingFeature(itemToFeature.id);
        try {
            const setFeaturedFunction = httpsCallable(functions, 'setFeaturedContent');
            const result = await setFeaturedFunction({ contentId: itemToFeature.id, appId: appId });
            showMessage(result.data.message);
        } catch (error) { showMessage(`Error: ${error.message}`);
        } finally { setIsUpdatingFeature(null); }
    };

    const handleRemoveFeatured = async () => {
        if (!creatorProfile.featuredVideoLink) return;
        setIsUpdatingFeature(creatorProfile.featuredVideoLink.liveFeedContentId);
        try {
            const removeFeaturedFunction = httpsCallable(functions, 'removeFeaturedContent');
            const result = await removeFeaturedFunction({ appId: appId });
            showMessage(result.data.message);
        } catch (error) { showMessage(`Error: ${error.message}`);
        } finally { setIsUpdatingFeature(null); }
    };

    const handleTogglePin = async (itemToPin) => {
        setIsUpdatingPin(itemToPin.id);
        try {
            const togglePinFunction = httpsCallable(functions, 'togglePinStatus');
            const result = await togglePinFunction({ contentId: itemToPin.id });
            showMessage(result.data.message);
        } catch (error) {
            showMessage(`Error: ${error.message}`);
        } finally {
            setIsUpdatingPin(null);
        }
    };
    
    const handleDelete = (itemToDelete) => {
        setConfirmationTitle("Delete Content?");
        setConfirmationMessage(`Are you sure you want to permanently delete "${itemToDelete.title}"? This cannot be undone.`);
        setOnConfirmationAction(() => async () => {
            try {
                const deleteFunction = httpsCallable(functions, 'deleteContentItem');
                await deleteFunction({ contentId: itemToDelete.id, appId: appId });
                showMessage("Content deleted successfully.");
            } catch (error) {
                showMessage(`Error: ${error.message}`);
            }
        });
        setShowConfirmationModal(true);
    };

    const currentThumbnail = customThumbnailPreview || autoThumbnailPreview;
    const filteredItems = libraryItems.filter(item => item.title.toLowerCase().includes(searchTerm.toLowerCase()));
    if (!creatorProfile) { return <div className="screenContainer"><p className="heading">Loading...</p></div>; }
    
    return (
        <div className="screenContainer">
            <p className="heading">My Content Library</p>
            <p className="subHeading">Add to your portfolio and manage what's featured and pinned on your profile.</p>
            
            <div className="dashboardSection">
                <p className="dashboardSectionTitle">Add New Content to Library</p>
                {libraryItems.length >= 100 ? (
                    <div className="pt-4 border-t border-gray-200 mt-4" style={{borderColor: '#3A3A3A', textAlign: 'center'}}>
                        <p className="heading" style={{fontSize: '18px', color: '#FFD700'}}>Library Full</p>
                        <p className="subHeading" style={{fontSize: '14px', color: '#AAA'}}>
                            You have reached your 100 video limit. To add new content, you must first delete an existing item from your library.
                        </p>
                    </div>
                ) : (
                    <div className="videoLinkSection">
                        <div className="formGroup"><label htmlFor="contentTitle" className="formLabel">Title:</label><input type="text" id="contentTitle" className="formInput" value={title} onChange={(e) => setTitle(e.target.value)} required /></div>
                        <div className="formGroup"><label htmlFor="contentDescription" className="formLabel">Description (Optional):</label><textarea id="contentDescription" className="formTextarea" value={description} onChange={(e) => setDescription(e.target.value)} placeholder="A brief summary of your content"></textarea></div>
                        <div className="formGroup"><label htmlFor="contentType" className="formLabel">Content Type:</label><select id="contentType" className="formInput" value={contentType} onChange={(e) => setContentType(e.target.value)} required><option value="" disabled>-- Select a Category --</option>{availableCategories.map(cat => (<option key={cat} value={cat}>{cat}</option>))}</select></div>
                        <label htmlFor="featuredVideoLink" className="formLabel">URL:</label>
                        <div className="videoInputContainer"><input type="url" id="featuredVideoLink" className="formInput" value={videoLinkInput} onChange={(e) => setVideoLinkInput(e.target.value)} placeholder="Paste your video link here" /></div>
                        <div className="formGroup" style={{marginTop: '15px'}}><label htmlFor="customThumbnailFile" className="formLabel">Custom Thumbnail (Optional):</label><input type="file" id="customThumbnailFile" ref={thumbnailFileInputRef} className="formInput" onChange={handleThumbnailFileSelect} accept="image/*" style={{padding: '10px 0', border: 'none', backgroundColor: 'transparent'}} /></div>
                        {currentThumbnail && ( <div style={{marginTop: '10px'}}><p className="formLabel" style={{marginBottom: '5px'}}>Thumbnail Preview:</p><img src={currentThumbnail} alt="Thumbnail Preview" style={{ maxWidth: '200px', borderRadius: '8px', border: '2px solid #FFD700' }} onError={(e) => { e.target.style.display = 'none'; }} /></div>)}
                        <div className="videoActions" style={{marginTop: '20px', justifyContent: 'flex-start'}}><button className="adminActionButton approve" onClick={handleAddToLibrary} disabled={isPublishing} style={{padding: '10px 20px', fontSize: '14px'}}>{isPublishing ? 'Saving...' : 'Add to Library'}</button></div>
                    </div>
                )}
            </div>

            <div className="dashboardSection" style={{ marginTop: '20px' }}>
                <div className="flex justify-between items-center cursor-pointer" onClick={() => setIsLibraryExpanded(!isLibraryExpanded)}>
                    <p className="dashboardSectionTitle" style={{ marginBottom: 0 }}>My Uploads ({libraryItems.length})</p>
                    <button className="text-xl font-bold text-white">{isLibraryExpanded ? '▼' : '▶'}</button>
                </div>
                <div className={`overflow-hidden transition-all duration-500 ease-in-out ${isLibraryExpanded ? 'max-h-[5000px] mt-4' : 'max-h-0'}`}>
                    <div className="formGroup"><input type="text" className="formInput" placeholder="Search your library by title..." value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} /></div>
                    <div className="dashboardContentList">
                        {loadingLibrary ? <p>Loading content...</p> : 
                            filteredItems.length === 0 ? <p className="dashboardItem">{searchTerm ? `No content matches "${searchTerm}".` : 'Your library is empty.'}</p> :
                            filteredItems.map(item => {
                                const isPinned = creatorProfile?.pinnedContent?.includes(item.id);
                                return (
                                <div key={item.id} className="library-item-card">
                                    <button 
                                        className={`pin-icon-button ${isPinned ? 'pinned' : ''}`}
                                        onClick={() => handleTogglePin(item)}
                                        disabled={isUpdatingPin === item.id}
                                        title={isPinned ? 'Unpin from profile' : 'Pin to profile'}
                                    >
                                        <svg className="pin-svg" viewBox="0 0 24 24"><path d="M16 12V4h1V2H7v2h1v8l-2 2v2h5.2v6h1.6v-6H18v-2l-2-2z"></path></svg>
                                    </button>
                                    <div className="library-item-content">
                                        <img src={item.customThumbnailUrl} alt={item.title} className="library-item-thumbnail" onClick={() => {
                                            const event = new CustomEvent('openVideoModal', { detail: { url: item.embedUrl || item.mainUrl, item } });
                                            window.dispatchEvent(event);
                                        }} />
                                        <div className="library-item-info">
                                            <p className="library-item-title">{item.title}</p>
                                            <p className="library-item-status">
                                                Type: {item.contentType}
                                                {isPinned && <span style={{ color: '#FFD700', fontWeight: 'bold' }}> • Pinned</span>}
                                            </p>
                                        </div>
                                    </div>
                                    <div className="videoActions" style={{marginTop: '10px'}}>
                                        {creatorProfile.featuredVideoLink?.liveFeedContentId === item.id ? (
                                            <button className="actionButton" onClick={handleRemoveFeatured} disabled={isUpdatingFeature === item.id} style={{backgroundColor: '#FF8C00'}}>
                                                {isUpdatingFeature === item.id ? '...' : 'Remove Featured'}
                                            </button>
                                        ) : (
                                            <button className="actionButton" onClick={() => handleSetFeatured(item)} disabled={isUpdatingFeature === item.id} style={{backgroundColor: '#008000'}}>
                                                {isUpdatingFeature === item.id ? '...' : 'Set as Featured'}
                                            </button>
                                        )}
                                        <button className="actionButton remove" onClick={() => handleDelete(item)}>Delete</button>
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                </div>
            </div>
            <button className="button" onClick={() => setActiveScreen('CreatorDashboard')} style={{ backgroundColor: '#3A3A3A', marginTop: '30px' }}><span className="buttonText light">Back to Dashboard</span></button>
            {showImageAdjustModal && imageFileToAdjust && (
                <ProfilePictureAdjustModal 
                    imageUrl={URL.createObjectURL(imageFileToAdjust)}
                    onSave={handleThumbnailSave}
                    onCancel={handleThumbnailCancel}
                    showMessage={showMessage}
                    isUploading={isPublishing}
                />
            )}
        </div>
    );
};
// --- END: FULL COMPONENT REPLACEMENT ---

// =========== START REPLACEMENT ===========
              const memoizedScreen = React.useMemo(() => {
                if (currentUser && !currentUser.emailVerified) {
                    return <VerificationScreen 
                        currentUser={currentUser} 
                        showMessage={showMessage} 
                        handleLogout={handleLogout} 
                        setActiveScreen={setActiveScreen}
                    />;
                }
            
                switch (activeScreen) {
                    case 'Home':
                        return <HomeScreen currentUser={currentUser} showMessage={showMessage} handleVideoPress={handleVideoPress} handleLogout={handleLogout} creatorProfile={creatorProfile} featuredContentSlots={featuredContentSlots}/>;
                     case 'FollowingFeed':
                        return <FollowingFeedScreen currentUser={currentUser} setActiveScreen={setActiveScreen} showMessage={showMessage} handleVideoPress={handleVideoPress}/>;
                    case 'Contact':
                        return <ContactScreen setActiveScreen={setActiveScreen} showMessage={showMessage} currentUser={currentUser}/>;
                    case 'Discover':
                        return <CategoriesScreen 
                            showMessage={showMessage} 
                            isLive={isLive} 
                            countdownText={countdownText} 
                            liveThumbnail={liveThumbnail} 
                            currentUser={currentUser} 
                            creatorProfile={creatorProfile} 
                            setActiveScreen={setActiveScreen} 
                            handleVideoPress={handleVideoPress} 
                        />;
                    case 'DiscoverUsers':
                        return <DiscoverUsersScreen showMessage={showMessage} setActiveScreen={setActiveScreen} setSelectedCampaignId={setSelectedCampaignId} creatorProfile={creatorProfile} setSelectedUserId={setSelectedUserId}/>;
                    case 'UserProfile':
                    return <UserProfileScreen 
                        selectedUserId={selectedUserId} 
                        setActiveScreen={setActiveScreen} 
                        setSelectedCampaignId={setSelectedCampaignId} 
                        showMessage={showMessage} 
                        currentUser={currentUser}
                        creatorProfile={creatorProfile} // THIS IS THE FIX
                    />;
                    case 'MyFollows':
                        return <MyFollowsScreen currentUser={currentUser} showMessage={showMessage} setActiveScreen={setActiveScreen} setSelectedUserId={setSelectedUserId}/>;
                    case 'Followers':
                        return <FollowersScreen currentUser={currentUser} showMessage={showMessage} setActiveScreen={setActiveScreen} setSelectedUserId={setSelectedUserId}/>;
                    case 'Login':
                        return <LoginScreen showMessage={showMessage} setActiveScreen={setActiveScreen} setSuspensionDetails={setSuspensionDetails} />;
                    case 'UserSignUp':
                        return <UserSignUpScreen showMessage={showMessage} setActiveScreen={setActiveScreen}/>;
                    case 'CreatorSignUp':
                        return <CreatorSignUpScreen showMessage={showMessage} setActiveScreen={setActiveScreen}/>;
                    case 'ForgotPassword': // <-- THE ONLY ADDITION IS THIS CASE
                        return <ForgotPasswordScreen showMessage={showMessage} setActiveScreen={setActiveScreen}/>;
                   case 'Premium':
                        return <PremiumScreen showMessage={showMessage} currentUser={currentUser} setActiveScreen={setActiveScreen} setPledgeContext={setPledgeContext} selectedCurrency={selectedCurrency} currencyRates={currencyRates} />;
                    case 'SupportUsScreen':
                        return <SupportUsScreen setActiveScreen={setActiveScreen} />;
                    case 'PremiumPerks':
                        return <PremiumPerksScreen setActiveScreen={setActiveScreen} />;
                    case 'AdvertiserPerks':
                        return <AdvertiserPerksScreen setActiveScreen={setActiveScreen} />;
                    // --- THIS IS THE FIX ---
                    case 'Crowdfunding':
                        return <CrowdfundingScreen showMessage={showMessage} setActiveScreen={setActiveScreen} />;
                    case 'AllCampaigns':
                        return <AllCampaignsScreen showMessage={showMessage} setActiveScreen={setActiveScreen} setSelectedCampaignId={setSelectedCampaignId} selectedCurrency={selectedCurrency} currencyRates={currencyRates}/>;
                    case 'CampaignDetails':
                        return <CampaignDetailsScreen showMessage={showMessage} setActiveScreen={setActiveScreen} selectedCampaignId={selectedCampaignId} currentUser={currentUser} setPledgeContext={setPledgeContext} selectedCurrency={selectedCurrency} currencyRates={currencyRates} />;
                    case 'DonationPledge':
                        return <DonationPledgeScreen showMessage={showMessage} setActiveScreen={setActiveScreen} currentUser={currentUser} creatorProfile={creatorProfile} pledgeContext={pledgeContext} setPledgeIdForConfirmation={setPledgeIdForConfirmation} />;
                   case 'SubscriptionPledge':
                        return <SubscriptionPledgeScreen showMessage={showMessage} setActiveScreen={setActiveScreen} currentUser={currentUser} creatorProfile={creatorProfile} pledgeContext={pledgeContext} setPledgeIdForConfirmation={setPledgeIdForConfirmation} selectedCurrency={selectedCurrency} currencyRates={currencyRates} />;
                     case 'PendingConfirmation':
                        if (!pledgeIdForConfirmation) {
                            return (
                                <div className="screenContainer" style={{textAlign: 'center', paddingTop: '50px'}}>
                                    <p className="heading">Initializing Secure Session...</p>
                                </div>
                            );
                        }
                        return <PendingConfirmationScreen showMessage={showMessage} setActiveScreen={setActiveScreen} pledgeId={pledgeIdForConfirmation} currentUser={currentUser} selectedCurrency={selectedCurrency} currencyRates={currencyRates} />;
                    case 'CreatorDashboard':
                          return <CreatorDashboardScreen showMessage={showMessage} setActiveScreen={setActiveScreen} currentUser={currentUser} creatorProfile={creatorProfile} setCreatorProfile={setCreatorProfile} setSelectedCampaignId={setSelectedCampaignId} setShowConfirmationModal={setShowConfirmationModal} setConfirmationTitle={setConfirmationTitle} setConfirmationMessage={setConfirmationMessage} setOnConfirmationAction={setOnConfirmationAction}/>;
                    case 'CreateCampaign':
                        return <CreateCampaignScreen showMessage={showMessage} setActiveScreen={setActiveScreen} currentUser={currentUser} creatorProfile={creatorProfile}/>;
                    case 'AdminDashboard':
                        return <AdminDashboardScreen 
                            showMessage={showMessage} 
                            featuredContentSlots={featuredContentSlots} 
                            setActiveScreen={setActiveScreen} 
                            currentUser={currentUser} 
                            setSelectedAdminCampaignId={setSelectedAdminCampaignId} 
                            creatorProfile={creatorProfile} 
                            selectedAdminSubScreen={selectedAdminSubScreen} 
                            setSelectedAdminSubScreen={setSelectedAdminSubScreen}
                            setShowConfirmationModal={setShowConfirmationModal} 
                            setConfirmationTitle={setConfirmationTitle} 
                            setConfirmationMessage={setConfirmationMessage} 
                            setOnConfirmationAction={setOnConfirmationAction}
                            setSelectedUserId={setSelectedUserId}
                            setSelectedOpportunity={setSelectedOpportunity}
                            setSelectedStatus={setSelectedStatus} 
                            setSelectedCompAdmin={setSelectedCompAdmin}
                            setSelectedReportGroup={setSelectedReportGroup} // This is the new line
                        />;
                    case 'AdminCampaignDetails':
                        return <AdminCampaignDetailsScreen
                            showMessage={showMessage}
                            setActiveScreen={setActiveScreen}
                            currentUser={currentUser}
                            selectedAdminCampaignId={selectedAdminCampaignId}
                            setShowConfirmationModal={setShowConfirmationModal}
                            setConfirmationTitle={setConfirmationTitle}
                            setConfirmationMessage={setConfirmationMessage}
                            setOnConfirmationAction={setOnConfirmationAction}
                            creatorProfile={creatorProfile}
                        />;
                    case 'AdminReportReview':
                        return <AdminReportReviewScreen showMessage={showMessage} setActiveScreen={setActiveScreen} currentUser={currentUser} creatorProfile={creatorProfile} selectedReportGroup={selectedReportGroup} setShowConfirmationModal={setShowConfirmationModal} setConfirmationTitle={setConfirmationTitle} setConfirmationMessage={setConfirmationMessage} setOnConfirmationAction={setOnConfirmationAction} />;
                    case 'Suspended':
                        return <SuspendedScreen showMessage={showMessage} setActiveScreen={setActiveScreen} suspensionDetails={suspensionDetails} />;
                    case 'AdminStatusReview':
                        return <AdminStatusReviewScreen showMessage={showMessage} setActiveScreen={setActiveScreen} selectedStatus={selectedStatus} setSelectedStatus={setSelectedStatus} />;
                    
                    case 'AdminCompetitionResults':
                        return <AdminCompetitionResults 
                        showMessage={showMessage} 
                        setActiveScreen={setActiveScreen} 
                        selectedComp={selectedCompAdmin}
                        setSelectedEntry={setSelectedEntry}
                        competition={selectedCompAdmin} // Pass this for the viewer modal
                        currentUser={currentUser}
                        />;

                            case 'CompetitionScreen':
                        return <CompetitionScreen 
                            showMessage={showMessage} 
                            setActiveScreen={setActiveScreen} 
                            currentUser={currentUser} 
                            creatorProfile={creatorProfile}
                        />;
                    
                    case 'CreatorConnect':
                        return <CreatorConnectScreen 
                            showMessage={showMessage} 
                            setActiveScreen={setActiveScreen} 
                            currentUser={currentUser} 
                            creatorProfile={creatorProfile} 
                            setSelectedOpportunity={setSelectedOpportunity} 
                            setShowConfirmationModal={setShowConfirmationModal}
                            setConfirmationTitle={setConfirmationTitle}
                            setConfirmationMessage={setConfirmationMessage}
                            setOnConfirmationAction={setOnConfirmationAction}
                        />;
                    case 'OpportunityDetails':
                        return <OpportunityDetailsScreen showMessage={showMessage} setActiveScreen={setActiveScreen} selectedOpportunity={selectedOpportunity} />;
                    case 'PostOpportunityForm':
                        return <PostOpportunityForm 
                            showMessage={showMessage} 
                            setActiveScreen={setActiveScreen} 
                            currentUser={currentUser} 
                            creatorProfile={creatorProfile} 
                            setOpportunityToPromote={setOpportunityToPromote} 
                        />;
                    case 'PostSubmissionUpsell':
                        return <PostSubmissionUpsellScreen 
                            showMessage={showMessage} 
                            setActiveScreen={setActiveScreen} 
                            opportunityToPromote={opportunityToPromote} 
                            setOpportunityToPromote={setOpportunityToPromote}
                        />;
                    case 'MyListings':
                        return <MyListingsScreen showMessage={showMessage} setActiveScreen={setActiveScreen} currentUser={currentUser} />;
                    
                                       
                    case 'AdminOpportunityDetails':
                        return <AdminOpportunityDetailsScreen showMessage={showMessage} setActiveScreen={setActiveScreen} selectedOpportunity={selectedOpportunity} setSelectedOpportunity={setSelectedOpportunity} />;
                    case 'TopCreators':
                        return <TopCreatorsScreen featuredContentSlots={featuredContentSlots} handleVideoPress={handleVideoPress} setActiveScreen={setActiveScreen} currentUser={currentUser} showMessage={showMessage}/>;
                    case 'AnalyticsDashboard':
                        return <AnalyticsDashboardScreen showMessage={showMessage} setActiveScreen={setActiveScreen}/>;
                    case 'MyContentLibrary':
                        return <MyContentLibraryScreen showMessage={showMessage} setActiveScreen={setActiveScreen} currentUser={currentUser} creatorProfile={creatorProfile} setShowConfirmationModal={setShowConfirmationModal} setConfirmationTitle={setConfirmationTitle} setConfirmationMessage={setConfirmationMessage} setOnConfirmationAction={setOnConfirmationAction} handleVideoPress={handleVideoPress} />;
                        // ======================================================================
                    // ================= START: ADD THIS NEW CASE ===========================
                    // ======================================================================

                    case 'SavedOpportunities':
                        return <SavedOpportunitiesScreen showMessage={showMessage} setActiveScreen={setActiveScreen} currentUser={currentUser} setSelectedOpportunity={setSelectedOpportunity} />;

                    // ======================================================================
                    // ================== END: ADD THIS NEW CASE ============================
                    // ======================================================================

                     case 'PromotedStatus':
                        return <PromotedStatusScreen 
                            showMessage={showMessage} 
                            setActiveScreen={setActiveScreen} 
                            currentUser={currentUser} 
                            creatorProfile={creatorProfile}
                            setShowConfirmationModal={setShowConfirmationModal}
                            setConfirmationTitle={setConfirmationTitle}
                            setConfirmationMessage={setConfirmationMessage}
                            setOnConfirmationAction={setOnConfirmationAction}
                        />;

                     case 'BookStatus':
                        return <BookStatusScreen 
                            showMessage={showMessage} 
                            setActiveScreen={setActiveScreen} 
                            setPledgeIdForConfirmation={setPledgeIdForConfirmation} 
                            currentUser={currentUser} 
                            creatorProfile={creatorProfile} 
                            selectedCurrency={selectedCurrency} 
                            currencyRates={currencyRates} 
                            opportunityToPromote={opportunityToPromote}
                            setOpportunityToPromote={setOpportunityToPromote}
                        />;

                    case 'PremiumMembersScreen':
                        return <PremiumMembersScreen setActiveScreen={setActiveScreen} setSelectedUserId={setSelectedUserId} showMessage={showMessage} />;
                    case 'NotificationInbox':
                            return <NotificationInboxScreen notifications={unreadNotifications} setActiveScreen={setActiveScreen} dismissNotification={dismissNotification} />;
                    
                                        case 'PremiumMembersScreen':
                        return <PremiumMembersScreen setActiveScreen={setActiveScreen} setSelectedUserId={setSelectedUserId} showMessage={showMessage} />;
                    case 'NotificationInbox':
                            return <NotificationInboxScreen notifications={unreadNotifications} setActiveScreen={setActiveScreen} dismissNotification={dismissNotification} />;
                    default:
                        return <HomeScreen currentUser={currentUser} showMessage={showMessage} handleVideoPress={handleVideoPress} handleLogout={handleLogout} creatorProfile={creatorProfile} featuredContentSlots={featuredContentSlots}/>;
                }
           }, [activeScreen, currentUser, creatorProfile, featuredContentSlots, selectedAdminSubScreen, pledgeIdForConfirmation, selectedCurrency, currencyRates, suspensionDetails]);
// =========== END REPLACEMENT ===========

    // --- THIS IS THE NEW, RESTORED EVENT LISTENER FOR THE VIDEO MODAL ---
    useEffect(() => {
        const openModalHandler = (event) => {
            const { url, item } = event.detail;
            setCurrentVideoUrl(url);
            setCurrentContentItem(item);
            setShowVideoModal(true);
        };
        window.addEventListener('openVideoModal', openModalHandler);
        return () => {
            window.removeEventListener('openVideoModal', openModalHandler);
        };
    }, []); // Empty dependency array means this runs once and stays active


                        if (authLoading || !isVideoFinished) {
                return (
                    <div className="loading-video-container">
                        <video 
                            className="loading-video"
                            src="https://firebasestorage.googleapis.com/v0/b/nvanetworkapp.firebasestorage.app/o/NVA%20Network%20APP%20Video%20Loading%20screen%20FINAL.mp4?alt=media&token=74af6621-0d77-4cd3-bb68-a0f6d4a4c32a" 
                            autoPlay 
                            muted 
                            playsInline
                            onEnded={() => setIsVideoFinished(true)}
                            // This provides a fallback if the video fails to load or play
                            onError={() => setIsVideoFinished(true)} 
                        >
                        </video>
                    </div>
                );
            }
            
                if (authLoading) {
                return (
                    <div className="loading-video-container">
                        <p className="heading">Loading Your Profile...</p>
                    </div>
                );
            }

            // --- PASTE THIS ENTIRE NEW BLOCK HERE ---
            // After initial auth is done, if we have a user but are still waiting for their Firestore profile, show a loading screen.
            // This prevents the race condition after email verification.
            
// --- END OF THE NEW BLOCK 
          
            return (
                <>
                    <div className="header">
                        <div className="header-content-left">
                            <p className="tagline">Caribbean Content to a Global Stage.</p>
                            <p className="headerTitle">NVA Network</p>
                            <HeaderLiveButton 
                                isLive={isLive} 
                                countdownText={countdownText} 
                                onClick={() => setActiveScreen('Discover')}
                            />
                        </div>
                      <div className="header-right-group">
                            <img
                                src="https://firebasestorage.googleapis.com/v0/b/nvanetworkapp.firebasestorage.app/o/NVA%20Network%20LOGO%203_BRIGHT%20BG.png?alt=media&token=95b8d741-2fbd-4fc1-af2f-42b95ff20eb1"
                                alt="NVA Network Logo"
                                className="headerLogo"
                                onError={(e) => { e.target.onerror = null; e.target.src='https://placehold.co/450x150/1A1A1A/FFD700?text=Logo+Error'; }}
                            />
                            <CurrencySelector
                                currencyRates={currencyRates}
                                selectedCurrency={selectedCurrency}
                                onCurrencyChange={setSelectedCurrency}
                            />
                        </div>
                    </div>

                    <div className="container">
                        {memoizedScreen}
                    </div>

                       <div className="navigationBar" style={{ position: 'relative' }}>
                        <button className="navButton" onClick={() => setActiveScreen('Home')}>
                            <span className={`navButtonText ${activeScreen === 'Home' ? 'activeNavButtonText' : ''}`}>Home</span>
                        </button>
                        
                        {currentUser && (
                            <NotificationBell count={unreadNotifications.filter(n => n.isRead === false).length} onClick={() => setActiveScreen('NotificationInbox')} />
                        )}
  <button 
                            className="navButton" 
                            onClick={() => {
                                if (currentUser) {
                                    setActiveScreen('CreatorConnect');
                                } else {
                                    showMessage("You must be logged in to view listings.");
                                }
                            }}
                        >
                            <span className="navButtonText">Creator Connect</span>
                        </button>

                        {currentUser && (
                            <button 
                                className="navButton" 
                                onClick={() => {
                                    const clearFlagsFunction = httpsCallable(functions, 'clearNewContentFlags');
                                    clearFlagsFunction().catch(error => console.error("Error clearing flags:", error));
                                    setActiveScreen('FollowingFeed');
                                }} 
                                style={{ backgroundColor: '#0A0A0A', border: '1px solid #FFD700', position: 'relative' }}
                            >
                                {hasNewFollowerContent && (
                                    <span style={{
                                        position: 'absolute',
                                        top: '2px',
                                        right: '5px',
                                        width: '10px',
                                        height: '10px',
                                        backgroundColor: '#DC3545',
                                        borderRadius: '50%',
                                        border: '1px solid #FFF'
                                    }}></span>
                                )}
                                <span className="navButtonText" style={{ color: '#FFD700' }}>My Feed</span>
                            </button>
                        )}

                        {currentUser && (
                            <button className="navButton" onClick={() => setActiveScreen('CreatorDashboard')}>
                                <span className={`navButtonText ${activeScreen === 'CreatorDashboard' ? 'activeNavButtonText' : ''}`}>Dashboard</span>
                            </button>
                        )}
                        
                        {currentUser && creatorProfile && (creatorProfile.role === 'admin' || creatorProfile.role === 'authority') && (
                            <button className="navButton" onClick={() => setActiveScreen('AdminDashboard')}>
                                <span className={`navButtonText ${activeScreen === 'AdminDashboard' ? 'activeNavButtonText' : ''}`}>Admin</span>
                            </button>
                        )}

                        <button className="navButton" onClick={() => setShowMoreMenu(!showMoreMenu)}>
                            <span className="navButtonText">More</span>
                        </button>

                        {showMoreMenu && (
                            <div style={{
                                position: 'absolute',
                                bottom: '60px',
                                right: '15px',
                                backgroundColor: '#1A1A1A',
                                borderRadius: '10px',
                                boxShadow: '0 -2px 10px rgba(0,0,0,0.5)',
                                border: '1px solid #333',
                                zIndex: 1100,
                                display: 'flex',
                                flexDirection: 'column',
                                gap: '5px',
                                padding: '10px'
                            }}>
                                {currentUser && (
                                    <button className="navButton" style={{width: '100%'}} onClick={() => { setActiveScreen('SupportUsScreen'); setShowMoreMenu(false); }}>
                                        <span className="navButtonText">Support Hub</span>
                                    </button>
                                )}
                                <button className="navButton" style={{width: '100%'}} onClick={() => { setActiveScreen('About'); setShowMoreMenu(false); }}>
                                    <span className="navButtonText">About</span>
                                </button>
                                <button className="navButton" style={{width: '100%'}} onClick={() => { setActiveScreen('Contact'); setShowMoreMenu(false); }}>
                                    <span className="navButtonText">Contact</span>
                                </button>
                            </div>
                        )}
                    </div>

                    <>
                        {message && (
                            <div className="messageBox">
                                <p className="messageText">{message}</p>
                            </div>
                        )}
                        <NotificationToast notification={currentToast} onClick={handleToastClick} onTimeout={handleToastTimeout} />
                        {showVideoModal && (
                            <VideoPlayerModal
                                videoUrl={currentVideoUrl}
                                onClose={closeVideoModal}
                                contentItem={currentContentItem}
                                currentUser={currentUser}
                                showMessage={showMessage}
                            />
                        )}
                        {showConfirmationModal && (
                            <ConfirmationModal
                                title={confirmationTitle}
                                message={confirmationMessage}
                                onConfirm={onConfirmationAction}
                                onCancel={() => setShowConfirmationModal(false)}
                            />
                        )}
                        
                        {/* THIS IS THE NEW MODAL RENDER, NOW CORRECTLY PLACED */}
                        {showReportModal && (
                            <ReportContentModal
                                showMessage={showMessage}
                                onCancel={() => setShowReportModal(false)}
                                contentToReport={contentToReport}
                            />
                        )}

                        {/* ADD this JSX block */}
                        {showLikesModal && contentForLikes && (
                            <LikesModal
                                contentItem={contentForLikes}
                                currentUser={currentUser}
                                showMessage={showMessage}
                                onClose={() => setShowLikesModal(false)}
                                setActiveScreen={setActiveScreen}
                                setSelectedUserId={setSelectedUserId}
                            />
                        )}

                        {/* ADD this JSX block */}
                        {showCommentsModal && itemForComments && (
                            <CommentsModal
                                item={itemForComments}
                                itemType={itemTypeForComments}
                                currentUser={currentUser}
                                showMessage={showMessage}
                                onClose={() => setShowCommentsModal(false)}
                                setActiveScreen={setActiveScreen}
                                setSelectedUserId={setSelectedUserId}
                            />
                        )}
                    </>
                </>
            );
        }
            
                // --- END OF CORRECTED BLOCK ---

                window.onload = function() {
            if (
                typeof window.firebaseAuth === 'undefined' ||
                typeof window.onAuthStateChanged === 'undefined' ||
                typeof window.firebaseDb === 'undefined' ||
                typeof window.firebaseStorage === 'undefined' ||
                typeof ReactDOM === 'undefined'
            ) {
                console.error("Firebase or ReactDOM not fully initialized. Retrying render...");
                setTimeout(window.onload, 100);
                return;
            }

            const root = ReactDOM.createRoot(document.getElementById('root'));
            root.render(<App />);
        };
    </script>
</body>
</html>
