<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NVA Network</title>
    <!-- Google Fonts - Bebas Neue for title, Inter for body -->
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- PWA Enhancements START -->
    <link rel="manifest" href="/manifest.json">
    <link rel="apple-touch-icon" href="/icon-192x192.png">
    <meta name="theme-color" content="#0A0A0A">
    <!-- PWA Enhancements END -->
    <style>
        *, *::before, *::after {
            box-sizing: border-box;
        }
        html {
            overflow-y: scroll; /* This is the definitive fix. It prevents layout shift. */
        }
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            background-color: #0A0A0A; /* Set the body background to match the app */
        }
        body {
            font-family: 'Inter', sans-serif;
            color: #FFF;
            display: flex;
            justify-content: center; /* This centers the app on larger screens */
            -webkit-overflow-scrolling: touch;
        }
        #root {
            /* The surgical change: We remove 'width: 100%' */
            /* This allows the 'max-width' to work with the body's 'justify-content: center' */
            min-height: 100vh;
            background-color: #0A0A0A;
            display: flex;
            flex-direction: column;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            max-width: 1200px; /* This now becomes the effective width on large screens */
            /* We also add this to ensure it takes up the full width on smaller screens */
            flex-grow: 1; 
        }
        .container {
            flex: 1;
            background-color: #0A0A0A; /* Dark background */
            display: flex;
            flex-direction: column;
        }
        .header {
            position: relative; /* Keep for absolute positioning of logo */
            height: 150px;
            padding: 0 15px; /* Add padding for spacing */
            background-color: #1A1A1A;
            border-bottom: 1px solid #333;
            border-radius: 15px 15px 0 0;
            display: flex; /* Use flexbox to align items */
            justify-content: space-between; /* Space between left content and logo */
            align-items: center; /* Vertically center items */
        }

        /* New container for the text and button on the left */
        .header-content-left {
            display: flex;
            flex-direction: column;
            justify-content: space-around; /* This will space out the three items */
            height: 100%; /* Take full height of the header */
            padding: 10px 0; /* Add some vertical padding */
            z-index: 3;
        }

        .headerTitle {
            /* Remove absolute positioning */
            font-size: 38px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.7);
            font-family: 'Bebas Neue', sans-serif;
            margin: 0; /* Remove default margins */
            line-height: 1.1; /* Adjust line height */
            text-align: left; /* Ensure text is left aligned */
        }
        .tagline {
            /* Remove absolute positioning */
            font-size: 14px;
            color: #AAA;
            font-weight: normal;
            text-align: left;
            margin: 0; /* Remove default margins */
        }

        /* NEW Style for the Logo */
        .headerLogo {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            max-height: 90%; /* Use most of the header height */
            width: auto; /* Maintain aspect ratio */
            max-width: 40%; /* Prevent it from being too wide on smaller screens */
            object-fit: contain; /* Ensure the image is not distorted */
        }
        .navigationBar {
            display: flex;
            flex-wrap: wrap; /* The key property to allow wrapping */
            justify-content: center; /* Centers the buttons as a group */
            gap: 15px; /* Creates perfect 15px spacing between all items */
            padding: 15px; /* Provides breathing room around the buttons */
            background-color: #1A1A1A;
            border-top: 1px solid #333;
            border-radius: 0 0 15px 15px;
        }
        .navButton {
            padding: 8px 15px;
            border-radius: 25px; /* Adjusted for consistency with other buttons */
            cursor: pointer;
            transition: background-color 0.3s ease;
            background-color: #FFD700; /* Changed to gold for visibility */
            box-shadow: 0 4px 5px rgba(0, 0, 0, 0.3);
            border: none; /* Removed border */
        }
        .navButton:hover {
            background-color: #FFC400;
        }
        .navButtonText {
            color: #0A0A0A; /* Changed to black for visibility */
            font-size: 14px;
            font-weight: 600;
        }
        .activeNavButtonText {
            color: #0A0A0A; /* Changed to black for visibility on gold background */
        }
        .screenContainer {
            flex: 1;
            padding: 15px;
            /* Removed overflow-y: auto; here as body will handle overall scrolling */
            position: relative; /* Added for positioning the new support button */
        }
        .sectionTitle {
            font-size: 20px;
            font-weight: bold;
            color: #FFF;
            margin-bottom: 15px;
            margin-top: 20px;
        }
        .contentGrid {
            display: grid;
            grid-template-columns: repeat(2, 1fr); /* Create 2 equal-fraction columns */
            gap: 15px; /* Create a perfect 15px gap between columns and rows */
        }
        .contentCard {
            /* The width is now controlled by the parent grid. */
            /* We remove margin-bottom because the parent's 'gap' property handles all spacing. */
            background-color: #2A2A2A;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.8);
            cursor: pointer;
            transition: transform 0.2s ease;
        }
        .contentCard:hover {
            transform: translateY(-3px);
        }
        .thumbnailPlaceholder {
            width: 100%;
            height: 100px;
            background-color: #444;
            display: flex;
            flex-direction: column; /* To stack text and icon */
            justify-content: center;
            align-items: center;
            position: relative; /* For play icon positioning */
        }
        .thumbnailText {
            color: #FFF;
            font-size: 12px;
            margin-bottom: 5px; /* Space between text and icon */
        }
        .playIcon {
            width: 30px;
            height: 30px;
            fill: #FFD700; /* Gold color for play icon */
            opacity: 0.8;
        }
        .contentTitle {
            font-size: 14px;
            font-weight: bold;
            color: #FFF;
            padding: 10px;
        }
        .categoryTabs {
            margin-bottom: 15px;
            height: 40px;
            display: flex;
            /* This property is key for equal spacing of the visible buttons */
            justify-content: space-around;
            align-items: center;
            position: relative; /* Crucial for positioning the dropdown */
        }
        .moreCategoriesMenu {
            position: absolute;
            top: 100%; /* Position it right below the tabs bar */
            right: 0; /* Align to the right side */
            background-color: #1A1A1A;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.7);
            border: 1px solid #333;
            z-index: 100; /* Ensure it appears above other content */
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 200px; /* Give the menu a fixed width */
        }
        .moreMenuItem {
            width: 100%; /* Make each button take the full width of the menu */
            margin-right: 0; /* Override the default margin */
        }

        .categoryTab {
            padding: 8px 15px;
            border-radius: 20px;
            background-color: #3A3A3A;
            margin-right: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 0; /* Prevent tabs from shrinking */
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .categoryTab:hover {
            background-color: #4A4A4A;
        }

        .activeCategoryTab {
            background-color: #FFD700; /* Gold highlight for active category */
        }

        .categoryTabText {
            color: #FFF;
            font-weight: 600;
            white-space: nowrap; /* Prevent text from wrapping inside the button */
        }
        .activeCategoryTabText {
            color: #0A0A0A; /* Dark text on gold background */
        }
        .categoryContent {
            flex: 1;
            /* Removed overflow-y: auto; here as body will handle overall scrolling */
        }
        /* Horizontal Carousel Styles (Featured Highlights) */
        .horizontal-carousel-container {
            width: 100%;
            overflow-x: hidden; /* Hide scrollbar, manage scrolling with JS */
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
            scroll-snap-type: x mandatory; /* Snap to items */
            scroll-behavior: smooth; /* Smooth scrolling animation */
            display: flex; /* Arrange items in a row */
            padding-bottom: 10px; /* Space for scrollbar */
            margin-bottom: 20px; /* Space below carousel */
        }

        .horizontal-carousel-item {
            flex: 0 0 calc(33.33% - 10px); /* Show 3 items, account for margin */
            margin-right: 15px; /* Spacing between items */
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.8);
            scroll-snap-align: start; /* Snap to the start of each item */
            background-color: #2A2A2A; /* Placeholder background */
            display: flex;
            justify-content: center;
            align-items: center;
            color: #FFF;
            font-size: 12px;
            height: 100px; /* Fixed height for carousel images */
        }
        .horizontal-carousel-item:last-child {
            margin-right: 0; /* No margin on the last item */
        }
        .carousel-image {
            width: 100%;
            height: 100%;
            object-fit: cover; /* Cover the item area */
            border-radius: 10px; /* Inherit border-radius */
        }

        /* Vertical Carousel Styles (Live Feed) */
        .vertical-carousel-container {
            width: 100%;
            height: 250px; /* Fixed height for vertical carousel to show ~2 items */
            overflow-y: hidden; /* Hide scrollbar, manage scrolling with JS */
            -webkit-overflow-scrolling: touch; /* Enable touch scrolling */
            scroll-snap-type: y mandatory; /* Snap to items */
            scroll-behavior: smooth; /* Smooth scrolling animation */
            display: flex;
            flex-direction: column; /* Arrange items in a column */
            margin-bottom: 20px;
            background-color: #1A1A1A;
            border-radius: 10px;
            padding: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.8);
        }

        .vertical-carousel-item {
            flex: 0 0 calc(50% - 10px); /* Show 2 items per view, with a gap */
            margin-bottom: 15px; /* Space between items */
            background-color: #2A2A2A;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
            scroll-snap-align: start; /* Snap to the start of each item */
            display: flex;
            align-items: center;
            padding: 10px;
        }

        .vertical-carousel-item:last-child {
            margin-bottom: 0;
        }

        .liveFeedThumbnail {
            width: 80px; /* Fixed width for live feed thumbnails */
            height: 60px; /* Fixed height for live feed thumbnails (16:9 aspect ratio) */
            object-fit: cover;
            border-radius: 8px;
            margin-right: 10px;
        }

        .liveFeedContent {
            flex-grow: 1;
        }

        .liveFeedTitle {
            font-size: 14px;
            font-weight: bold;
            color: #FFF;
            margin-bottom: 5px;
        }

        .liveFeedCreator {
            font-size: 12px;
            color: #AAA;
        }

        .heading {
            font-size: 24px;
            font-weight: bold;
            color: #FFD700;
            margin-bottom: 10px;
            text-align: center;
        }
        .subHeading {
            font-size: 16px;
            color: #FFF;
            margin-bottom: 20px;
            text-align: center;
        }
        .paragraph {
            font-size: 14px;
            color: #CCC;
            margin-bottom: 10px;
            line-height: 20px;
        }
        .button {
            background-color: #FFD700;
            padding: 12px 25px;
            border-radius: 25px;
            align-self: center;
            margin-top: 20px;
            margin-bottom: 10px;
            box-shadow: 0 4px 5px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            border: none;
            transition: background-color 0.3s ease;
        }
        .button:hover {
            background-color: #FFC400;
        }
        .buttonText {
            color: #0A0A0A;
            font-size: 16px;
            font-weight: bold;
            text-align: center;
        }
        .smallText {
            font-size: 12px;
            color: #888;
            text-align: center;
            margin-bottom: 10px;
        }
        .listItem {
            font-size: 14px;
            color: #CCC;
            margin-left: 15px;
            margin-bottom: 5px;
        }
        .premiumFeatureCard {
            background-color: #2A2A2A;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
        }
        .premiumFeatureTitle {
            font-size: 18px;
            font-weight: bold;
            color: #FFD700;
            margin-bottom: 5px;
        }
        .premiumFeatureDescription {
            font-size: 14px;
            color: #CCC;
            line-height: 20px;
        }
        .pricingTable {
            background-color: #2A2A2A;
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
        }
        .pricingRow {
            display: flex;
            justify-content: space-between;
            padding-top: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid #333;
        }
        .pricingRow:last-child {
            border-bottom: none; /* No border for the last row */
        }
        .pricingTier {
            font-size: 16px;
            font-weight: bold;
            color: #FFD700;
            flex: 1;
        }
        .pricingFeatures {
            font-size: 14px;
            color: #CCC;
            flex: 2;
            text-align: left;
            margin-left: 10px;
        }
        .pricingPrice {
            font-size: 16px;
            font-weight: bold;
            color: #FFF;
            flex: 1;
            text-align: right;
        }
        .contactInfo {
            font-size: 14px;
            color: #CCC;
            margin-bottom: 5px;
        }
        .messageBox {
            position: fixed; /* Use fixed for overlay */
            bottom: 100px; /* Above navigation bar */
            left: 50%;
            transform: translateX(-50%); /* Center horizontally */
            background-color: rgba(0, 0, 0, 0.8);
            padding: 12px 20px;
            border-radius: 8px;
            z-index: 1000;
            opacity: 1;
            transition: opacity 0.3s ease-in-out;
            pointer-events: none; /* Allow clicks to pass through */
            max-width: 90%;
        }
        .messageBox.hidden {
            opacity: 0;
        }
        .messageText {
            color: #FFF;
            text-align: center;
            font-size: 14px;
        }
        /* Video Modal Styles */
        .videoModalOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .videoModalContent {
            background-color: #1A1A1A;
            border-radius: 0; /* Removed for full screen effect */
            width: 100vw; /* Make it take 100% of viewport width */
            height: 100vh; /* Make it take 100% of viewport height */
            max-width: 1200px; /* Cap maximum width for very large screens */
            max-height: 800px; /* Cap maximum height for very large screens to maintain aspect ratio */
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
            position: relative;
            display: flex; /* Enable flex for vertical centering of iframe */
            flex-direction: column;
            justify-content: center; /* Center content vertically */
            align-items: center; /* Center content horizontally */
        }
        .videoIframeContainer {
            position: relative;
            width: 100%;
            padding-bottom: 56.25%; /* 16:9 Aspect Ratio (height relative to width) */
            height: 0; /* Important for padding-bottom trick */
            overflow: hidden;
        }
        .videoIframeContainer iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
        }
        .videoModalContent.vertical {
            max-width: 450px; /* Optimal width for phone-like vertical view */
            height: 100vh;
            max-height: 100vh; /* Ensure it takes full viewport height */
            justify-content: center; /* Center the iframe vertically */
        }

        .videoIframeContainer.vertical {
            padding-bottom: 177.77%; /* 9:16 aspect ratio (16 / 9 * 100) */
        }
        .closeButton {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(255, 255, 255, 0.2);
            color: #FFF;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 10; /* Ensure it's above the iframe */
        }

        /* Styles for buttons at the top of the Home screen */
        .topRightButtonContainer {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            gap: 10px; /* Space between buttons */
            z-index: 10;
        }

        .topButton {
            background-color: #FFD700; /* Gold color */
            color: #0A0A0A; /* Dark text */
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px; /* Smaller font for a compact button */
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            border: none;
            transition: background-color 0.3s ease;
        }
        .topButton:hover {
            background-color: #FFC400;
        }


        /* Styles for Creator Campaign Cards */
        .campaignCard {
            background-color: #2A2A2A;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
        }
        .campaignTitle {
            font-size: 18px;
            font-weight: bold;
            color: #FFD700;
            margin-bottom: 5px;
        }
        .campaignCreator {
            font-size: 14px;
            color: #CCC;
            margin-bottom: 10px;
        }
        .campaignDescription {
            font-size: 14px;
            color: #AAA;
            line-height: 1.5;
            margin-bottom: 10px;
        }
        .campaignProgressContainer {
            width: 100%;
            background-color: #444;
            border-radius: 5px;
            height: 10px;
            margin-bottom: 5px;
            overflow: hidden; /* Ensure progress bar stays within bounds */
        }
        .campaignProgressBar {
            height: 100%;
            background-color: #FFD700;
            border-radius: 5px;
            transition: width 0.5s ease-in-out;
        }
        .campaignStats {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #CCC;
            width: 100%;
        }
        .campaignGoal, .campaignRaised {
            font-weight: bold;
            color: #FFF;
        }
        .campaignButton {
            background-color: #FFD700;
            padding: 10px 15px;
            border-radius: 20px;
            color: #0A0A0A;
            font-weight: bold;
            text-align: center;
            cursor: pointer;
            border: none;
            transition: background-color 0.3s ease;
        }
        .campaignButton:hover {
            background-color: #FFC400;
        }

        /* Styles for Creator Sign Up Form */
        .formGroup {
            margin-bottom: 15px;
        }
        .formLabel {
            display: block;
            font-size: 14px;
            color: #FFF;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .formInput, .formTextarea {
            width: calc(100% - 20px); /* Account for padding */
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #555;
            background-color: #333;
            color: #FFF;
            font-size: 14px;
        }
        .formTextarea {
            resize: vertical; /* Allow vertical resizing */
            min-height: 80px;
        }
        .checkboxGroup {
            margin-bottom: 15px;
        }
        .checkboxLabel {
            display: block;
            font-size: 14px;
            color: #FFF;
            margin-bottom: 8px;
            font-weight: bold;
        }
        .checkboxItem {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .checkboxItem input[type="checkbox"] {
            margin-right: 8px;
            width: 18px; /* Larger checkbox for touch */
            height: 18px;
            accent-color: #FFD700; /* Highlight checkbox */
        }
        .termsText {
            font-size: 12px;
            color: #AAA;
            margin-top: 10px;
            line-height: 1.4;
        }
        .termsLink {
            color: #FFD700;
            text-decoration: none;
            font-weight: bold;
        }
        .termsLink:hover {
            text-decoration: underline;
        }

        /* Styles for Creator Dashboard */
        .dashboardSection {
            background-color: #2A2A2A;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
        }
        .dashboardSectionTitle {
            font-size: 18px;
            font-weight: bold;
            color: #FFD700;
            margin-bottom: 10px;
        }
        .dashboardItem {
            font-size: 14px;
            color: #CCC;
            margin-bottom: 8px;
            line-height: 1.4;
        }
        .dashboardButton {
            background-color: #0A0A0A; /* Changed to black */
            padding: 8px 15px;
            border-radius: 20px;
            color: #FFD700; /* Changed to gold */
            font-weight: bold;
            cursor: pointer;
            border: 1px solid #FFD700; /* Added a gold border for definition */
            transition: background-color 0.3s ease, color 0.3s ease;
            margin-top: 10px;
            margin-right: 10px;
        }
        .dashboardButton:hover {
            background-color: #FFD700; /* Gold background on hover */
            color: #0A0A0A; /* Black text on hover */
        }
        }
        .dashboardContentList {
            margin-top: 10px;
            padding-left: 0; /* Remove default ul padding */
            list-style: none; /* Remove bullet points */
        }
        .dashboardContentListItem {
            background-color: #3A3A3A;
            padding: 8px 12px;
            border-radius: 8px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
            color: #FFF;
        }
        .dashboardContentListItem span {
            flex-grow: 1;
        }
        .dashboardContentListItem .actionButton {
            background-color: #555;
            color: #FFF;
            border: none;
            padding: 5px 10px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 12px;
            margin-left: 10px;
            transition: background-color 0.2s ease;
        }
        .dashboardContentListItem .actionButton:hover {
            background-color: #777;
        }

        /* New styles for video link sections in dashboard */
        .videoLinkSection {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #333;
        }
        .videoLinkSection:last-child {
            border-bottom: none;
            padding-bottom: 0;
        }
        .videoLinkSection .formLabel {
            margin-bottom: 10px;
            font-size: 16px;
            color: #FFD700;
        }
        .videoInputContainer {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        .videoInputContainer .formInput {
            flex-grow: 1;
        }
        .videoThumbnailContainer {
            position: relative;
            width: 100%;
            height: 150px; /* Fixed height for thumbnails */
            background-color: #444;
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 10px;
            cursor: pointer; /* Indicate clickable */
        }
        .videoThumbnail {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .videoThumbnailOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.4);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .thumbnailPlayIcon {
            width: 40px;
            height: 40px;
            fill: #FFF;
            opacity: 0.9;
        }
        .videoActions {
            display: flex;
            justify-content: flex-end; /* Align buttons to the right */
            gap: 10px;
        }
        .videoActions .actionButton {
            background-color: #FFD700;
            color: #0A0A0A;
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: bold;
            cursor: pointer;
            border: none;
            transition: background-color 0.3s ease;
        }
        .videoActions .actionButton.remove {
            background-color: #DC3545; /* Red for remove */
            color: #FFF;
        }
        .videoActions .actionButton:hover {
            background-color: #FFC400;
        }
        .videoActions .actionButton.remove:hover {
            background-color: #C82333;
        }
        /* New styles for login form */
        .loginForm {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .loginForm .button {
            width: 100%;
        }
        /* New styling for section title with aligned button */
        .sectionHeaderWithButton {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px; /* Space below the header container */
            margin-top: 20px;
        }
        .sectionHeaderWithButton .sectionTitle {
            margin: 0; /* Remove default margins from p tag when in flex container */
        }
        /* Adjust .topButton styles for this context if needed, or create a new class */
        .sectionHeaderButton {
            background-color: #FFD700; /* Gold color */
            color: #0A0A0A; /* Dark text */
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px; /* Smaller font for a compact button */
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            border: none;
            transition: background-color 0.3s ease;
        }
        .sectionHeaderButton:hover {
            background-color: #FFC400;
        }

        /* Profile Picture Adjustment Modal Styles */
        .imageAdjustModalOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95); /* More opaque */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000; /* Higher z-index than video modal */
            flex-direction: column;
            gap: 20px;
        }

        .imageAdjustModalContent {
            background-color: #1A1A1A;
            border-radius: 15px;
            padding: 20px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .canvasContainer {
            position: relative;
            width: 200px; /* Fixed size for the canvas view */
            height: 200px;
            border-radius: 50%;
            overflow: hidden;
            border: 2px solid #FFD700;
            background-color: #333;
            margin-bottom: 20px;
            cursor: grab;
        }

        .canvasContainer.dragging {
            cursor: grabbing;
        }

        canvas {
            display: block;
            touch-action: none;
        }

        .modalButtons {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }

        .modalButton {
            background-color: #FFD700;
            color: #0A0A0A;
            padding: 10px 20px;
            border-radius: 25px;
            font-weight: bold;
            cursor: pointer;
            border: none;
            transition: background-color 0.3s ease;
        }

        .modalButton:hover {
            background-color: #FFC400;
        }

        .modalButton.cancel {
            background-color: #555;
            color: #FFF;
        }

        .modalButton.cancel:hover {
            background-color: #777;
        }

        /* Styles for Zoom Controls */
        .zoomControls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            align-items: center;
        }
        .zoomButton {
            background-color: #3A3A3A;
            color: #FFD700;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 1px solid #FFD700;
            font-size: 24px;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .zoomButton:hover {
            background-color: #4A4A4A;
        }

        /* New styles for all campaigns list */
        .allCampaignsList {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 20px;
        }
        .allCampaignsListItem {
            background-color: #2A2A2A;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: flex-start; /* Align items to the top */
            cursor: pointer; /* Pointer to indicate clickable for the whole card */
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .allCampaignsListItem:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.7);
        }
        .campaignListImagePlaceholder { /* New class for the image/button container */
            width: 80px;
            height: 80px;
            object-fit: cover;
            border-radius: 8px;
            margin-right: 15px;
            flex-shrink: 0;
            background-color: #3A3A3A; /* Background for the placeholder/button */
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative; /* For the button text */
            overflow: hidden; /* To handle background image overflow if it's large */
            background-size: cover; /* Make background image cover the area */
            background-position: center; /* Center the background image */
            box-shadow: inset 0 0 5px rgba(0,0,0,0.5); /* Subtle inner shadow */
        }
        .campaignListProjectButton { /* New class for the actual clickable button inside */
            background-color: rgba(255, 215, 0, 0.8); /* Semi-transparent gold */
            color: #0A0A0A;
            padding: 5px 8px;
            border-radius: 5px;
            font-size: 10px;
            font-weight: bold;
            text-align: center;
            cursor: pointer;
            border: none;
            transition: background-color 0.2s ease;
            position: absolute; /* Position over the background image */
            bottom: 5px; /* Place it at the bottom */
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap; /* Prevent text wrapping */
            text-shadow: 0 0 3px rgba(0,0,0,0.5);
            line-height: 1; /* Adjust line height for smaller button */
        }
        .campaignListProjectButton:hover {
            background-color: #FFC400; /* Solid gold on hover */
        }

        .campaignListContent {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        .campaignListTitle {
            font-size: 16px;
            font-weight: bold;
            color: #FFD700;
            margin-bottom: 5px;
        }
        .campaignListCreator {
            display: flex;
            align-items: center;
            font-size: 12px;
            color: #CCC;
            margin-bottom: 8px;
        }
        .campaignListCreatorProfilePic {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            object-fit: cover;
            margin-right: 8px;
            border: 1px solid #FFD700; /* Small border for visibility */
        }
        .campaignListDescription {
            font-size: 13px;
            color: #AAA;
            line-height: 1.4;
            display: -webkit-box;
            -webkit-line-clamp: 2; /* Show only 2 lines */
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 10px;
        }
        .campaignListStats {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #CCC;
            width: 100%;
        }
        .campaignListGoal, .campaignListRaised {
            font-weight: bold;
            color: #FFF;
        }
        .fee-info-container {
            position: relative;
            display: inline-flex; /* To keep icon next to text */
            align-items: center;
            margin-left: 5px; /* Space from the "Raised" text */
        }
        .fee-info-icon {
            font-size: 10px; /* Smaller icon */
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background-color: #FFD700;
            color: #0A0A0A;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            cursor: pointer;
        }
        .fee-info-tooltip {
            position: absolute;
            bottom: 100%; /* Position above the icon */
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.9);
            color: #FFF;
            padding: 8px;
            border-radius: 5px;
            font-size: 10px;
            white-space: normal; /* Allow text to wrap */
            width: 180px; /* Fixed width for tooltip */
            text-align: left;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
            pointer-events: none; /* Allow clicks to pass through */
            z-index: 10; /* Ensure it's above other elements */
            margin-bottom: 5px; /* Space between icon and tooltip */
        }
        .fee-info-container:hover .fee-info-tooltip {
            opacity: 1;
            visibility: visible;
        }


        /* Campaign Details Screen Specific Styles */
         .campaignDetailHeader {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 20px;
        }
        .campaignDetailImage {
            width: 100%;
            max-width: 350px; /* Max width for images */
            height: 200px;
            /* --- START: CORRECTED IMAGE FIT --- */
            object-fit: contain;
            background-color: #1A1A1A; /* Fills letterbox space with a dark color */
            /* --- END: CORRECTED IMAGE FIT --- */
            border-radius: 10px;
            margin-bottom: 15px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
        }
        /* Style to hide image if it fails to load */
        .campaignDetailImage.hidden {
            display: none;
        }

        .campaignDetailTitle {
            font-size: 22px;
            font-weight: bold;
            color: #FFD700;
            text-align: center;
            margin-bottom: 10px;
        }
        .campaignDetailCreator {
            display: flex;
            align-items: center;
            font-size: 15px;
            color: #CCC;
            margin-bottom: 15px;
        }
        .campaignDetailCreatorProfilePic {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            object-fit: cover;
            margin-right: 10px;
            border: 2px solid #FFD700;
        }
        .campaignDetailDescription {
            font-size: 14px;
            color: #AAA;
            line-height: 1.6;
            margin-bottom: 20px;
            background-color: #1A1A1A;
            padding: 15px;
            border-radius: 10px;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.3);
        }
        .campaignDetailStats {
            display: flex;
            justify-content: space-around;
            width: 100%;
            margin-bottom: 20px;
            padding: 10px 0;
            border-top: 1px solid #333;
            border-bottom: 1px solid #333;
        }
        .campaignDetailStatItem {
            text-align: center;
            font-size: 14px;
            color: #CCC;
        }
        .campaignDetailStatValue {
            font-size: 18px;
            font-weight: bold;
            color: #FFF;
        }
        .campaignDetailProgressBarContainer {
            width: 80%;
            background-color: #444;
            border-radius: 5px;
            height: 12px;
            margin-bottom: 10px;
            overflow: hidden;
            align-self: center; /* Center the progress bar */
        }
        .campaignDetailProgressBar {
            height: 100%;
            background-color: #FFD700;
            border-radius: 5px;
        }

        /* Admin Dashboard Specific Styles */
        .adminActionButton {
            background-color: #FFD700;
            color: #0A0A0A;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            border: none;
            margin-left: 10px;
            transition: background-color 0.2s ease;
        }
        .adminActionButton.approve {
            background-color: #008000; /* Green for approve */
            color: #FFF;
        }
        .adminActionButton.reject {
            background-color: #DC3545; /* Red for reject */
            color: #FFF;
        }
        .adminActionButton:hover {
            filter: brightness(1.1);
        }
        .adminActionButton.approve:hover {
            background-color: #006400;
        }
        .adminActionButton.reject:hover {
            background-color: #C82333;
        }
        .adminDashboardItem {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: #3A3A3A;
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            color: #FFF;
            font-size: 14px;
        }
        .adminDashboardItemTitle {
            flex-grow: 1;
            font-weight: bold;
        }
        .adminDashboardItemStatus {
            font-size: 12px;
            margin-left: 10px;
            color: #FFD700; /* Default for pending */
        }
        .adminDashboardItemStatus.active {
            color: #00FF00;
        }
        .adminDashboardItemStatus.rejected {
            color: #DC3545;
        }
        /* --- START: New Donation Ticker Styles --- */
        .donationTickerContainer {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 1500; /* Above most content, below modals */
            background-color: rgba(10, 10, 10, 0.85);
            border: 1px solid #FFD700;
            border-radius: 10px;
            padding: 12px 18px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            max-width: 300px;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.5s ease-in-out, transform 0.5s ease-in-out;
            pointer-events: none; /* Make it non-interactive */
        }

        .donationTickerContainer.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .tickerIcon {
            width: 20px;
            height: 20px;
            fill: #FFD700;
            margin-right: 10px;
            vertical-align: middle;
        }

        .tickerText {
            color: #FFF;
            font-size: 14px;
            line-height: 1.4;
            display: inline-block;
            vertical-align: middle;
        }

        .tickerText strong {
            color: #FFD700;
            font-weight: bold;
        }
        /* --- END: New Donation Ticker Styles --- */
        /* Confirmation Modal Styles */
        .confirmationModalOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000; /* Higher than any other modal */
        }

        .confirmationModalContent {
            background-color: #1A1A1A;
            border-radius: 15px;
            padding: 25px;
            width: 90%;
            max-width: 350px;
            box-shadow: 0 0 25px rgba(0, 0, 0, 0.7);
            text-align: center;
            color: #FFF;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .confirmationModalTitle {
            font-size: 20px;
            font-weight: bold;
            color: #FFD700;
            margin-bottom: 10px;
        }

        .confirmationModalMessage {
            font-size: 15px;
            color: #CCC;
            line-height: 1.5;
        }

        .confirmationModalButtons {
            display: flex;
            justify-content: space-around;
            gap: 15px;
            margin-top: 15px;
        }

        .confirmationButton {
            padding: 10px 20px;
            border-radius: 20px;
            font-weight: bold;
            cursor: pointer;
            border: none;
            transition: background-color 0.3s ease;
            flex-grow: 1;
        }

        .confirmationButton.confirm {
            background-color: #008000; /* Green for confirm */
            color: #FFF;
        }

        .confirmationButton.confirm:hover {
            background-color: #006400;
        }

        .confirmationButton.cancel {
            background-color: #DC3545; /* Red for cancel */
            color: #FFF;
        }

        .confirmationButton.cancel:hover {
            background-color: #C82333;
        }

        .admin-toggle-button:hover {
            background-color: #FFC400; /* Slightly darker gold on hover */
            transform: scale(1.05); /* Slight scale effect on hover */
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.5); /* Enhanced shadow on hover */
        }

        /* --- START: Definitive Button Text Color Fix --- */
        .buttonText.light {
            color: #E0E0E0; /* Light grey, near-white text */
        }
        /* --- END: Definitive Button Text Color Fix --- */
        .button[style*="#3A3A3A"], /* Targets inline style for #3A3A3A */
        .button[style*="#555"],    /* Targets inline style for #555 */
        .modalButton.cancel {
            color: #E0E0E0 !important; /* !important ensures this overrides other color rules */
        }

        .dashboardContentListItem .actionButton {
             background-color: #555;
             color: #E0E0E0; /* Set default text color */
        }

        .dashboardContentListItem .actionButton:hover {
            background-color: #777;
            color: #FFF !important; /* Ensure hover text is bright white */
        }
        /* --- END: Consolidated Grey Button Text Color Fix --- */
        /* New styles for Upload Progress Bar */
        .uploadProgressContainer {
            width: 100%;
            background-color: #444;
            border-radius: 5px;
            height: 12px;
            margin-top: 15px;
            overflow: hidden;
        }
        .uploadProgressBar {
            height: 100%;
            background-color: #008000; /* Green for progress */
            border-radius: 5px;
            transition: width 0.2s ease-in-out;
            text-align: center;
            line-height: 12px;
            font-size: 10px;
            color: #FFF;
            font-weight: bold;
        }


                /* NEW STYLES for User Search Screen */
        .user-search-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 20px;
        }
        .user-search-item {
            background-color: #2A2A2A;
            border-radius: 10px;
            padding: 15px;
            display: flex;
            align-items: center;
            gap: 15px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.5);
        }
        .user-search-pfp {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid #FFD700;
        }
        .user-search-info {
            flex-grow: 1;
        }
        .user-search-name {
            font-size: 16px;
            font-weight: bold;
            color: #FFF;
        }
        .user-search-role {
            font-size: 12px;
            color: #AAA;
        }
        .user-search-campaign-badge {
            background-color: #00FF00;
            color: #0A0A0A;
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: bold;
            margin-left: 10px;
        }
        /* NEW STYLES for Creator Dashboard Campaign List */
        .creator-campaign-list-item {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 10px;
            background-color: #3A3A3A;
            border-radius: 8px;
            margin-bottom: 10px;
        }
        .creator-campaign-thumbnail {
            width: 80px;
            height: 50px;
            object-fit: cover;
            border-radius: 5px;
        }
        .creator-campaign-info {
            flex-grow: 1;
        }
        .creator-campaign-title {
            font-size: 14px;
            font-weight: bold;
            color: #FFF;
        }
        .creator-campaign-status {
            font-size: 12px;
        }
        .status-pending { color: #FFD700; }
        .status-active { color: #00FF00; }
        .status-rejected { color: #DC3545; }
        .status-ended { color: #888; }
        .status-cancelled { color: #AAA; }

         /* START: New Carousel Navigation Button Styles */
            .carousel-wrapper {
            position: relative; /* Establishes a positioning context for the buttons */
            width: 100%;
        }

        .carousel-nav-btn {
            position: absolute;
            z-index: 10;
            background-color: rgba(10, 10, 10, 0.6); /* Semi-transparent dark background */
            color: #FFD700; /* Gold icon color */
            border: 1px solid #FFD700;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            font-size: 20px; /* Adjust size of arrow characters */
            line-height: 1; /* Ensure vertical centering of arrows */
        }

        .carousel-nav-btn:hover {
            background-color: rgba(255, 215, 0, 0.8); /* Semi-transparent gold on hover */
            color: #0A0A0A; /* Dark icon color on hover */
            transform: scale(1.1);
        }

        /* Positioning for Horizontal Carousel Buttons */
        .carousel-nav-btn.prev-horizontal {
            top: 50%;
            left: 5px;
            transform: translateY(-50%);
        }

        .carousel-nav-btn.next-horizontal {
            top: 50%;
            right: 5px;
            transform: translateY(-50%);
        }

        /* Positioning for Vertical Carousel Buttons */
        .carousel-nav-btn.prev-vertical {
            left: 50%;
            top: 5px;
            transform: translateX(-50%);
        }

        .carousel-nav-btn.next-vertical {
            left: 50%;
            bottom: 5px;
            transform: translateX(-50%);
        }

        .header-live-button {
    padding: 6px 12px;
    border-radius: 20px;
    font-weight: bold;
    font-size: 14px;
    cursor: pointer;
    border: none;
    box-shadow: 0 2px 8px rgba(0,0,0,0.5);
    display: inline-flex; /* Allows it to sit nicely with text */
    align-items: center;
    gap: 8px;
    transition: background-color 0.3s, transform 0.2s;
    margin-top: 10px; /* Gives space below the tagline */
}
.header-live-button:hover {
    transform: scale(1.05); /* Simpler hover effect */
}
.header-live-button.countdown {
    background-color: #008000; /* Green */
    color: #FFF;
}
.header-live-button.live {
    background-color: #DC3545; /* Red */
    color: #FFF;
    animation: pulse 1.5s infinite;
}
@keyframes pulse {
    0% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7); }
    70% { box-shadow: 0 0 10px 10px rgba(220, 53, 69, 0); }
    100% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0); }
}
       /* START: New Leaderboard Styles */
        .leaderboard-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 20px;
        }
        .leaderboard-item {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 10px;
            background-color: #2A2A2A;
            border-radius: 10px;
            border-left: 5px solid transparent;
            transition: background-color 0.3s;
        }
        .leaderboard-item.rank-1 {
            background-color: rgba(255, 215, 0, 0.15);
            border-left-color: #FFD700;
        }
        .leaderboard-item.rank-2 {
            background-color: rgba(192, 192, 192, 0.15);
            border-left-color: #C0C0C0;
        }
        .leaderboard-item.rank-3 {
            background-color: rgba(205, 127, 50, 0.15);
            border-left-color: #CD7F32;
        }
        .leaderboard-rank {
            font-size: 20px;
            font-weight: bold;
            color: #FFF;
            width: 40px;
            text-align: center;
            flex-shrink: 0;
        }
        .leaderboard-pfp {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid #555;
        }
        .leaderboard-info {
            flex-grow: 1;
        }
        .leaderboard-name {
            font-size: 16px;
            font-weight: bold;
            color: #FFF;
        }
        .leaderboard-clicks-container {
            text-align: right;
        }
        .leaderboard-clicks {
            font-size: 20px;
            font-weight: bold;
            color: #FFD700;
        }
        .leaderboard-clicks-label {
            font-size: 12px;
            color: #AAA;
        }
        .leaderboard-tabs {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
        }
        /* END: New Leaderboard Styles */
        /* START: New Follow System Styles */
        .follow-button {
            padding: 8px 20px;
            border-radius: 20px;
            font-weight: bold;
            cursor: pointer;
            border: 2px solid #FFD700;
            transition: background-color 0.2s, color 0.2s;
        }
        .follow-button.following {
            background-color: transparent;
            color: #FFD700;
        }
        .follow-button.not-following {
            background-color: #FFD700;
            color: #0A0A0A;
        }
        .follow-stats {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 10px;
        }
        .follow-stat-item {
            text-align: center;
        }
        .follow-stat-value {
            font-size: 16px;
            font-weight: bold;
            color: #FFF;
        }
        .follow-stat-label {
            font-size: 12px;
            color: #AAA;
        }
        /* END: New Follow System Styles */
        
    </style>
</head>
<body>
    <div id="root"></div>

    <!-- 1. Initialize Firebase SDKs (module type) - Must be loaded before React components that use them -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, onAuthStateChanged, signInWithCustomToken, signInAnonymously, sendEmailVerification } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, updateDoc, collection, addDoc, query, orderBy, onSnapshot, where, getDocs, deleteDoc, limit, increment, runTransaction } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getStorage, ref, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-storage.js";
        import { getAnalytics, logEvent, setUserId, setUserProperties } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-analytics.js";
        import { getFunctions, httpsCallable } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-functions.js";
        
        // Global Firebase variables (provided by Canvas environment)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Your web app's Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBo3DM-4ZwrZdzcYQAMWAVHu70vWUdB7J4",
            authDomain: "nvanetworkapp.firebaseapp.com",
            projectId: "nvanetworkapp",
            storageBucket: "nvanetworkapp.firebasestorage.app",
            messagingSenderId: "122220543439",
            appId: "1:122220543439:web:e36ccce435463b7939a6ba",
            measurementId: "G-6RNS6DH3G0"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const storage = getStorage(app); // Initialize Storage
        const analytics = getAnalytics(app);
        window.firebaseAnalytics = analytics; // Export the instance
        window.logEvent = logEvent; // Export the function
        window.setUserId = setUserId; // Export the function
        window.setUserProperties = setUserProperties; // Export the function

        // Export for use in React component
        window.firebaseApp = app;
        window.firebaseAuth = auth;
        window.firebaseDb = db;
        window.firebaseStorage = storage; // Export Storage
        window.initialAuthToken = initialAuthToken; // Export corrected initialAuthToken
        window.createUserWithEmailAndPassword = createUserWithEmailAndPassword; // Expose the function itself
        window.signInWithEmailAndPassword = signInWithEmailAndPassword; // Expose sign-in function
        window.signOut = signOut; // Expose sign-out function
        window.onAuthStateChanged = onAuthStateChanged; // Expose auth state listener
        window.doc = doc; // Expose Firestore doc
        window.setDoc = setDoc; // Expose Firestore setDoc
        window.getDoc = getDoc; // Expose Firestore getDoc
        window.updateDoc = updateDoc; // Expose Firestore updateDoc
        window.collection = collection; // Expose Firestore collection
        window.addDoc = addDoc; // Expose Firestore addDoc
        window.query = query; // Expose Firestore query
        window.orderBy = orderBy; // Expose Firestore orderBy
        window.onSnapshot = onSnapshot; // Expose Firestore onSnapshot
        window.where = where; // Expose where for Firestore queries
        window.getDocs = getDocs; // Expose getDocs for Firestore queries
        window.deleteDoc = deleteDoc; // Expose deleteDoc for Firestore
        window.increment = increment; // Expose the increment function
        window.runTransaction = runTransaction; // Expose the Transaction function
        window.ref = ref;
        window.uploadBytes = uploadBytes;
        window.ref = ref;
        window.uploadBytes = uploadBytes;
        window.getDownloadURL = getDownloadURL;
        window.appId = appId;
        window.signInWithCustomToken = signInWithCustomToken; // Expose signInWithCustomToken
        window.signInAnonymously = signInAnonymously; // Expose signInAnonymously
        window.sendEmailVerification = sendEmailVerification; // Expose verification function
        window.limit = limit;
        
         // ADD THESE TWO NEW LINES
        window.getFunctions = getFunctions;
        window.httpsCallable = httpsCallable;
        
    </script>

    <!-- 2. Load React and ReactDOM (synchronously, no defer) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- 3. Load Babel (synchronously, to process JSX from the next script) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- 4. Define your React App component (JSX content here) -->
    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

                // ======================= START: FINAL NOTIFICATION HOOK =======================
        const useNotifications = (currentUser) => {
            const [notifications, setNotifications] = useState([]);
            const [isLoading, setIsLoading] = useState(true);
            const [pendingDeletes, setPendingDeletes] = useState(new Set());

            const dismissNotification = useCallback((notificationId) => {
                setPendingDeletes(prev => new Set(prev).add(notificationId));
                const functions = getFunctions(window.firebaseApp);
                const deleteNotificationCallable = httpsCallable(functions, 'deleteNotification');
                
                deleteNotificationCallable({ notificationId })
                    .catch(error => {
                        console.error("Failed to dismiss notification:", error);
                        setPendingDeletes(prev => {
                            const newSet = new Set(prev);
                            newSet.delete(notificationId);
                            return newSet;
                        });
                    });
            }, []);

            // Expose a helper function to be called by the App component
            const markBroadcastAsSeen = useCallback(async (notificationId) => {
                if (!currentUser) return;
                try {
                    const seenRef = doc(db, "creators", currentUser.uid, "seenNotifications", notificationId);
                    await setDoc(seenRef, { seenAt: new Date() });
                } catch (error) {
                    console.error("Failed to mark broadcast as seen:", error);
                }
            }, [currentUser]);

            
            const markNotificationAsRead = useCallback(async (notificationId) => {
                if (!currentUser) return;
                try {
                    const notifRef = doc(db, "notifications", notificationId);
                    await updateDoc(notifRef, { isRead: true });
                } catch (error) {
                    console.error("Failed to mark notification as read:", error);
                }
            }, [currentUser]);
            
            useEffect(() => {
                if (!currentUser) {
                    setNotifications([]);
                    setIsLoading(false);
                    return () => {};
                }

                setIsLoading(true);
                let privateNotifications = [];
                let broadcastNotifications = [];

                const mergeAndSetNotifications = async () => {
                    const seenRef = collection(db, "creators", currentUser.uid, "seenNotifications");
                    const seenSnapshot = await getDocs(seenRef);
                    const seenIds = new Set(seenSnapshot.docs.map(doc => doc.id));
                    
                    // The hook now ONLY filters based on what's already in the database.
                    const unseenBroadcasts = broadcastNotifications.filter(b => !seenIds.has(b.id));
                    
                    const combined = [...privateNotifications, ...unseenBroadcasts];
                    const filtered = combined.filter(n => !pendingDeletes.has(n.id));
                    const unique = Array.from(new Map(filtered.map(item => [item.id, item])).values());
                    
                    unique.sort((a, b) => b.timestamp.toDate().getTime() - a.timestamp.toDate().getTime());
                    
                    setNotifications(unique);
                    setIsLoading(false);
                };

                const privateNotifRef = collection(db, "notifications");
                const privateQuery = query(privateNotifRef, where("userId", "==", currentUser.uid), orderBy("timestamp", "desc"), limit(20));
                const unsubscribePrivate = onSnapshot(privateQuery, (snapshot) => {
                    privateNotifications = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data(), isBroadcast: false }));
                    mergeAndSetNotifications();
                });

                const broadcastNotifRef = collection(db, "broadcast_notifications");
                const fiveDaysAgo = new Date(Date.now() - 5 * 24 * 60 * 60 * 1000);
                const broadcastQuery = query(broadcastNotifRef, where("timestamp", ">", fiveDaysAgo), orderBy("timestamp", "desc"));
                const unsubscribeBroadcast = onSnapshot(broadcastQuery, (snapshot) => {
                    broadcastNotifications = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data(), isBroadcast: true }));
                    mergeAndSetNotifications();
                });

                return () => {
                    unsubscribePrivate();
                    unsubscribeBroadcast();
                };

            }, [currentUser, pendingDeletes]);

            return { notifications, isLoading, dismissNotification, markBroadcastAsSeen, markNotificationAsRead };
        };
// END of REPLACEMENT Block

        const NotificationBell = ({ count, onClick }) => {
            return (
                <button className="navButton" onClick={onClick} style={{ position: 'relative', backgroundColor: '#0A0A0A', border: '1px solid #FFD700' }}>
                    <span className="navButtonText" style={{ color: '#FFD700' }}>
                        <svg viewBox="0 0 24 24" style={{ width: '24px', height: '24px', fill: 'currentColor' }}>
                            <path d="M12 22c1.1 0 2-.9 2-2h-4c0 1.1.9 2 2 2zm6-6v-5c0-3.07-1.63-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68C7.64 5.36 6 7.92 6 11v5l-2 2v1h16v-1l-2-2z"/>
                        </svg>
                    </span>
                    {count > 0 && (
                        <div style={{
                            position: 'absolute',
                            top: '-5px',
                            right: '-5px',
                            backgroundColor: '#DC3545',
                            color: '#FFF',
                            borderRadius: '50%',
                            width: '20px',
                            height: '20px',
                            display: 'flex',
                            justifyContent: 'center',
                            alignItems: 'center',
                            fontSize: '12px',
                            fontWeight: 'bold'
                        }}>
                            {count}
                        </div>
                    )}
                </button>
            );
        };

        const NotificationToast = ({ notification, onClick, onTimeout }) => {
            useEffect(() => {
                const timer = setTimeout(() => {
                    onTimeout(); 
                }, 6000); 

                return () => clearTimeout(timer);
            }, [notification, onTimeout]);

            if (!notification) return null;

            // Check for the special donation broadcast type
            if (notification.broadcastType === 'DONATION') {
                return (
                     <div className="donationTickerContainer visible">
                        <svg className="tickerIcon" viewBox="0 0 24 24"><path d="M12,2A10,10,0,1,0,22,12,10,10,0,0,0,12,2Zm3.71,9.71-4,4a1,1,0,0,1-1.42,0l-2-2a1,1,0,1,1,1.42-1.42L11,13.59l3.29-3.3a1,1,0,0,1,1.42,1.42Z"></path></svg>
                        <div className="tickerText">
                            <strong>{notification.userName}</strong> just donated <strong>${notification.amount.toFixed(2)}</strong> to "{notification.targetCampaignTitle}"!
                        </div>
                    </div>
                );
            }

            // Fallback to the standard notification toast
            return (
                <div className="donationTickerContainer visible" style={{cursor: 'pointer'}} onClick={onClick}>
                    <svg className="tickerIcon" viewBox="0 0 24 24"><path d="M12,2A10,10,0,1,0,22,12,10,10,0,0,0,12,2Zm3.71,9.71-4,4a1,1,0,0,1-1.42,0l-2-2a1,1,0,1,1,1.42-1.42L11,13.59l3.29-3.3a1,1,0,0,1,1.42,1.42Z"></path></svg>
                    <div className="tickerText">
                        {notification.message}
                    </div>
                </div>
            );
        };

        const NotificationInboxScreen = ({ notifications, setActiveScreen, dismissNotification }) => {
            // This local state is the key. It gives this component direct, instant control over the UI.
            const [localNotifications, setLocalNotifications] = useState(notifications);

            // This effect synchronizes the local list with the master list from the hook
            // when the component first loads or when a new notification arrives from the server.
            useEffect(() => {
                setLocalNotifications(notifications);
            }, [notifications]);

            const markAsRead = async (notification) => {
                // Mark private notifications as read
                if (!notification.isBroadcast && !notification.isRead) {
                    const notifRef = doc(db, "notifications", notification.id);
                    try {
                        await updateDoc(notifRef, { isRead: true });
                    } catch (error) {
                        console.error("Failed to mark notification as read:", error);
                    }
                }
                // Always mark broadcasts as seen, as their read state isn't tracked in the doc itself
                if (notification.isBroadcast) {
                    const seenRef = doc(db, "creators", window.firebaseAuth.currentUser.uid, "seenNotifications", notification.id);
                    try {
                         await setDoc(seenRef, { seenAt: new Date() });
                    } catch (error) {
                         console.error("Failed to mark broadcast as seen:", error);
                    }
                }
            };

            const handleNotificationClick = (notification) => {
                markAsRead(notification);
                if (notification.link) {
                    const screen = notification.link.replace('/', '');
                    setActiveScreen(screen);
                }
            };

            const handleDismiss = (notificationId, event) => {
                event.stopPropagation(); // Prevents the card's main click action

                // 1. INSTANTLY update the local UI state. This is the fix.
                setLocalNotifications(prev => prev.filter(n => n.id !== notificationId));

                // 2. Call the function from the hook to handle the backend deletion.
                dismissNotification(notificationId);
            };

            return (
                <div className="screenContainer">
                    <p className="heading">Notifications</p>
                    <div className="dashboardContentList">
                        {localNotifications.length === 0 ? (
                            <p className="dashboardItem" style={{textAlign: 'center'}}>You have no new notifications.</p>
                        ) : (
                            localNotifications.map(item => (
                                <div
                                    key={item.id}
                                    className="adminDashboardItem"
                                    style={{
                                        cursor: 'pointer',
                                        borderLeft: (item.isBroadcast || item.isRead === true) ? '4px solid transparent' : '4px solid #FFD700',
                                        flexDirection: 'column',
                                        alignItems: 'flex-start'
                                    }}
                                    onClick={() => handleNotificationClick(item)}
                                >
                                    <div style={{ display: 'flex', justifyContent: 'space-between', width: '100%', alignItems: 'center' }}>
                                        <p className="adminDashboardItemTitle" style={{fontWeight: 'normal', flexGrow: 1}}>{item.message}</p>
                                        {!item.isBroadcast && (
                                            <button 
                                                className="adminActionButton reject" // Use 'reject' class for red styling
                                                style={{ marginLeft: '15px' }} 
                                                onClick={(e) => handleDismiss(item.id, e)}
                                            >
                                                Dismiss
                                            </button>
                                        )}
                                    </div>
                                    <p style={{fontSize: '12px', color: '#AAA'}}>{new Date(item.timestamp.toDate()).toLocaleString()}</p>
                                </div>
                            ))
                        )}
                    </div>
                </div>
            );
        };
        // ======================= END: UNIFIED NOTIFICATION CODE BLOCK =======================

          // --- NEW HELPER FUNCTION TO BE ADDED ---
        const extractVideoInfo = (url) => {
            if (!url) return { videoId: null, thumbnailUrl: null, embedUrl: null, platform: 'unknown', isVertical: false };
            let videoId = null;
            let platform = 'unknown';
            let isVertical = false;

            // YouTube (Standard, Short, Mobile)
            const youtubeRegex = /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/|youtube\.com\/shorts\/)([^"&?\/ ]{11})/;
            const youtubeMatch = url.match(youtubeRegex);
            if (youtubeMatch && youtubeMatch[1]) {
                videoId = youtubeMatch[1];
                platform = 'youtube';
                if (url.includes('/shorts/')) {
                    isVertical = true;
                }
            }
            // Add other platform regex checks here if needed (e.g., Vimeo, Facebook)

            if (!videoId) {
                return { videoId: null, thumbnailUrl: null, embedUrl: null, platform: 'unknown', isVertical: false };
            }

            const thumbnailUrl = `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`;
            const embedUrl = `https://www.youtube.com/embed/${videoId}?autoplay=1&rel=0`;

            return { videoId, thumbnailUrl, embedUrl, platform, isVertical };
        };

                // --- CORRECTED AND CONSOLIDATED CONSTANTS ---
                
        const auth = window.firebaseAuth;
        const db = window.firebaseDb;
        const increment = window.increment;
        const storage = window.firebaseStorage;
        const analytics = window.firebaseAnalytics; // Get analytics instance
        const createUserWithEmailAndPassword = window.createUserWithEmailAndPassword;
        const signInWithEmailAndPassword = window.signInWithEmailAndPassword;
        const signOut = window.signOut;
        const onAuthStateChanged = window.onAuthStateChanged;
        const doc = window.doc;
        const setDoc = window.setDoc;
        const getDoc = window.getDoc;
        const updateDoc = window.updateDoc;
        const collection = window.collection;
        const addDoc = window.addDoc;
        const query = window.query;
        const orderBy = window.orderBy;
        const onSnapshot = window.onSnapshot;
        const where = window.where;
        const getDocs = window.getDocs;
        const deleteDoc = window.deleteDoc;
        const runTransaction = window.runTransaction;
        const ref = window.ref;
        const getFunctions = window.getFunctions;
        const httpsCallable = window.httpsCallable;
        const uploadBytes = window.uploadBytes;
        const getDownloadURL = window.getDownloadURL;
        const appId = window.appId;
        const signInAnonymously = window.signInAnonymously;
        const sendEmailVerification = window.sendEmailVerification;
        const limit = window.limit;
        
        // --- Get the Analytics functions we exposed in Step 1 ---
        const logEvent = window.logEvent;
        const setUserId = window.setUserId;
        const setUserProperties = window.setUserProperties;


        // --- NEW: Analytics Helper Function ---
        /**
         * Logs a click on a creator's featured link to Firebase Analytics.
         * @param {string} creatorId - The UID of the creator whose link was clicked.
         * @param {string} creatorName - The name of the creator.
         */
        const logFeaturedLinkClick = (creatorId, creatorName) => {
            // Check if analytics and logEvent are available before using them
            if (analytics && logEvent) {
                logEvent(analytics, 'featured_link_click', {
                    content_creator_id: creatorId,
                    content_creator_name: creatorName,
                });
            } else {
                console.log("Analytics not ready, click was not logged.");
            }
        };
        

        // Hardcoded content - these will eventually be replaced by dynamic data from Firestore
        const featuredContent = [
            { id: '1', title: 'Guyanese Comedy Special', type: 'skit', url: 'https://www.youtube.com/embed/dQw4w9WgXcQ?autoplay=1', creator: 'Comedy Crew' },
            { id: '2', title: 'Top Guyanese Skits: Best of 2024', type: 'skit', url: 'https://www.youtube.com/embed/oHg5SJYRHA0?autoplay=1', creator: 'Laugh Central' },
            { id: '3', title: 'Indie Film: "Georgetown Dreams"', type: 'short-film', url: 'https://www.youtube.com/embed/34Na4j8AVgA?autoplay=1', creator: 'Indie Films GY' },
            { id: '4', title: 'Live Concert Replay: Mashramani', type: 'live-premiere', url: 'https://www.youtube.com/embed/example4?autoplay=1', creator: 'Vibes Ent.' },
            { id: '5', title: 'Creator Interview: Rise of Talent', type: 'interview', url: 'https://www.youtube.com/embed/example5?autoplay=1', creator: 'NVA Insights' },
            { id: '6', title: 'Short Film: "The Golden Arrowhead"', type: 'short-film', url: 'https://www.youtube.com/embed/example6?autoplay=1', creator: 'Heritage Films' },
            { id: '7', title: 'New Skit Series: "Life in GT"', type: 'skit', url: 'https://www.youtube.com/embed/skit7?autoplay=1', creator: 'GT Daily' },
            { id: '8', title: 'Cooking Show: Guyanese Delights', type: 'skit', url: 'https://www.youtube.com/embed/skit8?autoplay=1', creator: 'Chef Roti' },
            { id: '9', title: 'Poetry Slam Live: Best of Season', type: 'live-premiere', url: 'https://www.youtube.com/embed/live9?autoplay=1', creator: 'Wordsmiths GY' },
            { id: '10', title: 'Wildlife Doc: Amazonian Secrets', type: 'documentary', url: 'https://www.youtube.com/embed/doc1?autoplay=1', creator: 'Nature Watch' },
            { id: '11', title: 'Guyanese Music Spotlight', type: 'music', url: 'https://www.youtube.com/embed/music1?autoplay=1', creator: 'Riddim Connect' },
            { id: '12', title: 'Interview: Young Entrepreneurs', type: 'interview', url: 'https://www.youtube.com/embed/int1?autoplay=1', creator: 'Business Buzz GY' },
        ];


 

        const getYouTubeEmbedUrl = (youtubeUrl) => {
            const videoIdMatch = youtubeUrl.match(/(?:youtu\.be\/|youtube\.com\/(?:watch\?v=|embed\/||shorts\/))([^&?#]+)/);
            if (videoIdMatch && videoIdMatch[1]) {
                return `https://www.youtube.com/embed/${videoIdMatch[1]}?autoplay=1&rel=0`;
            }
            return youtubeUrl;
        };

        const VideoPlayerModal = ({ videoUrl, onClose, contentItem, currentUser, showMessage }) => {
    const viewCountedRef = useRef(false);

    useEffect(() => {
        if (!contentItem || !currentUser || viewCountedRef.current) { return; }
        const authorId = contentItem.creatorId || contentItem.createdBy;
        const contentDocId = contentItem.originalContentId || contentItem.id;
        if (currentUser.uid === authorId) { return; }
        const timer = setTimeout(async () => {
            try {
                const contentRef = doc(db, `artifacts/${appId}/public/data/content_items`, contentDocId);
                await updateDoc(contentRef, { viewCount: increment(1) });
                viewCountedRef.current = true;
            } catch (error) {
                console.error("Error incrementing view count:", error);
            }
        }, 10000);
        return () => { clearTimeout(timer); };
    }, [contentItem, currentUser]);

    if (!videoUrl) return null;

    const { embedUrl, isVertical } = extractVideoInfo(videoUrl);
    const finalEmbedUrl = embedUrl;

    return (
        <div className="videoModalOverlay">
            <div className={`videoModalContent ${isVertical ? 'vertical' : ''}`}>
                <button className="closeButton" onClick={onClose}></button>
                <div className={`videoIframeContainer ${isVertical ? 'vertical' : ''}`}>
                    <iframe
                        src={finalEmbedUrl}
                        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
                        allowFullScreen
                        title="Embedded Video Content"
                    ></iframe>
                </div>
                
                {/* --- START: ADDED VIEW COUNT DISPLAY --- */}
                <div style={{
                    position: 'absolute',
                    bottom: '20px', // MODIFIED: Set to a higher value for better spacing
                    left: '15px',
                    backgroundColor: 'rgba(10, 10, 10, 0.7)',
                    border: '1px solid #FFD700',
                    borderRadius: '50px',
                    padding: '0 10px',
                    height: '32px',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    gap: '6px'
                }}>
                    <svg viewBox="0 0 24 24" style={{ width: '18px', height: '18px', fill: '#FFF' }}>
                        <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5C21.27 7.61 17 4.5 12 4.5zm0 10c-2.48 0-4.5-2.02-4.5-4.5S9.52 5.5 12 5.5s4.5 2.02 4.5 4.5-2.02 4.5-4.5 4.5zM12 8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"></path>
                    </svg>
                    <span style={{ color: '#FFF', fontSize: '12px', fontWeight: 'bold' }}>
                        {(contentItem?.viewCount || 0).toLocaleString()}
                    </span>
                </div>
                {/* --- END: ADDED VIEW COUNT DISPLAY --- */}

                {currentUser && contentItem && contentItem.id && (
                    <LikeButton contentItem={contentItem} currentUser={currentUser} showMessage={showMessage} />
                )}
            </div>
        </div>
    );
};


                const LikeButton = ({ contentItem, currentUser, showMessage }) => {
    const [isLiked, setIsLiked] = useState(false);
    const [likeCount, setLikeCount] = useState(contentItem.likeCount || 0);
    const [isLoading, setIsLoading] = useState(true); // Start in a loading state

    // Determine the correct ID for the original content item
    const contentDocId = contentItem.originalContentId || contentItem.id;
    
    // This useEffect hook runs once to check if the user has already liked this post.
    useEffect(() => {
        if (!currentUser || !contentDocId) {
            setIsLoading(false);
            return;
        }
        
        const likeRef = doc(db, `artifacts/${appId}/public/data/content_items/${contentDocId}/likes`, currentUser.uid);
        
        const unsubscribe = onSnapshot(likeRef, (docSnap) => {
            setIsLiked(docSnap.exists());
            setIsLoading(false);
        });

        return () => unsubscribe(); // Cleanup the listener
    }, [contentDocId, currentUser]);
    
    // This useEffect hook keeps the public like count in sync with the database.
    useEffect(() => {
        if (!contentDocId) return;

        const contentRef = doc(db, `artifacts/${appId}/public/data/content_items/${contentDocId}`);
        
        const unsubscribe = onSnapshot(contentRef, (docSnap) => {
            if (docSnap.exists()) {
                setLikeCount(docSnap.data().likeCount || 0);
            }
        });

        return () => unsubscribe();
    }, [contentDocId]);


    const handleLike = async (e) => {
        e.stopPropagation(); // Stop the click from opening the video player.
        
        if (!currentUser) {
            showMessage("Please log in to like content.");
            return;
        }
        if (isLoading) return; // Prevent clicks while loading initial state

        const contentRef = doc(db, `artifacts/${appId}/public/data/content_items/${contentDocId}`);
        const likeRef = doc(db, `artifacts/${appId}/public/data/content_items/${contentDocId}/likes`, currentUser.uid);

        // Optimistically update the UI for a fast user experience.
        const newLikedState = !isLiked;
        const newLikeCount = newLikedState ? likeCount + 1 : likeCount - 1;
        setIsLiked(newLikedState);
        setLikeCount(newLikeCount);

        try {
            if (newLikedState) {
                // User is LIKING the post
                await setDoc(likeRef, { likedAt: new Date().toISOString() });
                await updateDoc(contentRef, { likeCount: increment(1) });
            } else {
                // User is UNLIKING the post
                await deleteDoc(likeRef);
                await updateDoc(contentRef, { likeCount: increment(-1) });
            }
        } catch (error) {
            console.error("Error updating like status:", error);
            showMessage("An error occurred. Please try again.");
            // If the database update fails, revert the optimistic UI changes.
            setIsLiked(!newLikedState);
            setLikeCount(likeCount);
        }
    };

    const heartIconPath = "M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z";

    return (
        <button
            onClick={handleLike}
            disabled={isLoading} // Disable button until we know the like status
            style={{
                position: 'absolute',
                bottom: '20px', // MODIFIED: Set to a higher value for better spacing
                right: '15px',
                backgroundColor: 'rgba(10, 10, 10, 0.7)',
                border: '1px solid #FFD700',
                borderRadius: '50%',
                width: 'auto',
                minWidth: '32px',
                height: '32px',
                padding: '0 10px',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                cursor: 'pointer',
                gap: '4px',
                transition: 'transform 0.2s'
            }}
        >
            <svg viewBox="0 0 24 24" style={{ width: '18px', height: '18px', fill: isLiked ? '#FFD700' : '#FFF' }}>
                <path d={heartIconPath}></path>
            </svg>
            <span style={{ color: '#FFF', fontSize: '12px', fontWeight: 'bold' }}>{likeCount}</span>
        </button>
    );
};

                // --- START OF NEW COMPONENT ---
        // --- START: REPLACEMENT FOR DiscoverUsersScreen ---
        const DiscoverUsersScreen = ({ showMessage, setActiveScreen, setSelectedCampaignId, creatorProfile, setSelectedUserId }) => {
            const [searchTerm, setSearchTerm] = useState('');
            const [searchResults, setSearchResults] = useState([]);
            const [isLoading, setIsLoading] = useState(false);
            const [hasSearched, setHasSearched] = useState(false);
            
            const viewProfile = (userId) => {
                setSelectedUserId(userId);
                setActiveScreen('UserProfile');
            };

            const handleSearch = async (e) => {
                e.preventDefault();
                if (!searchTerm.trim()) { setSearchResults([]); return; }
                setIsLoading(true);
                setHasSearched(true);
                
                try {
                    const usersRef = collection(db, "creators");
                    let q;

                    if (creatorProfile && (creatorProfile.role === 'admin' || creatorProfile.role === 'authority')) {
                        q = query(usersRef);
                    } else {
                        q = query(usersRef, where('role', 'in', ['user', 'creator']));
                    }
                    
                    const querySnapshot = await getDocs(q);
                    const users = querySnapshot.docs
                        .map(doc => ({ id: doc.id, ...doc.data() }))
                        .filter(user => user.creatorName && user.creatorName.toLowerCase().includes(searchTerm.toLowerCase()));

                    const usersWithCampaignStatus = await Promise.all(
                        users.map(async (user) => {
                            const campaignsRef = collection(db, `artifacts/${appId}/public/data/campaigns`);
                            const campaignQuery = query(campaignsRef, where('creatorId', '==', user.id), where('status', '==', 'active'));
                            const campaignSnapshot = await getDocs(campaignQuery);
                            return {
                                ...user,
                                hasActiveCampaign: !campaignSnapshot.empty,
                                activeCampaignId: !campaignSnapshot.empty ? campaignSnapshot.docs[0].id : null
                            };
                        })
                    );
                    setSearchResults(usersWithCampaignStatus);
                } catch (error) {
                    console.error("Error searching users:", error);
                    showMessage("Failed to search for users. Please try again.");
                } finally {
                    setIsLoading(false);
                }
            };
            
            return (
                <div className="screenContainer">
                    <p className="heading">Discover Creators</p>
                    <form onSubmit={handleSearch}>
                        <div className="formGroup">
                            <label htmlFor="userSearch" className="formLabel">Creator Name:</label>
                            <input type="text" id="userSearch" className="formInput" value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} placeholder="Enter a creator's name..."/>
                        </div>
                        <button type="submit" className="button" disabled={isLoading}><span className="buttonText">{isLoading ? 'Searching...' : 'Search'}</span></button>
                    </form>
                    <div className="user-search-list">
                        {isLoading && <p>Searching...</p>}
                        {!isLoading && hasSearched && searchResults.length === 0 && <p>No users found matching "{searchTerm}".</p>}
                        {!isLoading && searchResults.map(user => (
                            <div key={user.id} className="user-search-item" style={{cursor: 'pointer'}} onClick={() => viewProfile(user.id)}>
                                <img src={user.profilePictureUrl || 'https://placehold.co/100x100/555/FFF?text=P'} alt={user.creatorName} className="user-search-pfp"/>
                                <div className="user-search-info">
                                    <p className="user-search-name">
                                        {user.creatorName}
                                        {user.hasActiveCampaign && <span className="user-search-campaign-badge">Active Campaign</span>}
                                    </p>
                                    <p className="user-search-role">Role: {user.role}</p>
                                </div>
                            </div>
                        ))}
                    </div>
                </div>
            );
        };
        // --- END OF REPLACEMENT ---


        const UserProfileScreen = ({ selectedUserId, setActiveScreen, setSelectedCampaignId, showMessage, currentUser }) => {
    const [profile, setProfile] = useState(null);
    const [campaigns, setCampaigns] = useState([]);
    const [loading, setLoading] = useState(true);
    const [isContentListExpanded, setIsContentListExpanded] = useState(true);
    // --- State for the follow system ---
    const [isFollowing, setIsFollowing] = useState(false);
    const [isFollowLoading, setIsFollowLoading] = useState(false);

    // State for video player
    const [showVideoModal, setShowVideoModal] = useState(false);
    const [currentVideoUrl, setCurrentVideoUrl] = useState('');
    
    useEffect(() => {
        if (!selectedUserId) {
            setActiveScreen('DiscoverUsers');
            return;
        }
        setLoading(true);

        // --- Real-time listener for the viewed profile ---
        const userDocRef = doc(db, "creators", selectedUserId);
        const unsubscribeProfile = onSnapshot(userDocRef, (userDocSnap) => {
            if (userDocSnap.exists()) {
                setProfile({ id: userDocSnap.id, ...userDocSnap.data() });
            } else {
                showMessage("This user profile could not be found.");
                setActiveScreen('DiscoverUsers');
            }
        }, (error) => {
            console.error("Error fetching user profile:", error);
            showMessage("Failed to load user profile.");
            setActiveScreen('DiscoverUsers');
        });

        // --- Real-time listener for active campaigns ---
        const campaignsRef = collection(db, `artifacts/${appId}/public/data/campaigns`);
        const q = query(campaignsRef, where('creatorId', '==', selectedUserId), where('status', '==', 'active'));
        const unsubscribeCampaigns = onSnapshot(q, (campaignSnapshot) => {
            setCampaigns(campaignSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
            setLoading(false); // Set loading to false after campaigns are also loaded
        });

        // --- Real-time listener for the follow status ---
        let unsubscribeFollow = () => {};
        if (currentUser) {
            const followDocRef = doc(db, "creators", selectedUserId, "followers", currentUser.uid);
            unsubscribeFollow = onSnapshot(followDocRef, (followDocSnap) => {
                setIsFollowing(followDocSnap.exists());
            });
        }

        // --- Cleanup all listeners on unmount ---
        return () => {
            unsubscribeProfile();
            unsubscribeCampaigns();
            unsubscribeFollow();
        };
    }, [selectedUserId, currentUser]);

        // --- Function to handle the follow/unfollow action ---
    const handleFollowToggle = async () => {
        if (!currentUser) {
            showMessage("Please log in to follow creators.");
            setActiveScreen('Login');
            return;
        }
        if (currentUser.uid === selectedUserId) {
            showMessage("You cannot follow yourself.");
            return;
        }
        setIsFollowLoading(true);

        const targetUserRef = doc(db, "creators", selectedUserId);
        const currentUserRef = doc(db, "creators", currentUser.uid);
        const targetFollowersRef = doc(db, "creators", selectedUserId, "followers", currentUser.uid);
        const currentUserFollowingRef = doc(db, "creators", currentUser.uid, "following", selectedUserId);

        try {
            await window.runTransaction(db, async (transaction) => {
                const targetUserDoc = await transaction.get(targetUserRef);
                const currentUserDoc = await transaction.get(currentUserRef);

                if (!targetUserDoc.exists() || !currentUserDoc.exists()) {
                    throw "A user document is missing, cannot update follow counts.";
                }

                if (isFollowing) {
                    // UNFOLLOW LOGIC
                    const currentFollowerCount = targetUserDoc.data().followerCount || 0;
                    const newFollowerCount = Math.max(0, currentFollowerCount - 1); // Prevents going below 0

                    const currentFollowingCount = currentUserDoc.data().followingCount || 0;
                    const newFollowingCount = Math.max(0, currentFollowingCount - 1); // Safety check for our own count

                    transaction.delete(targetFollowersRef);
                    transaction.delete(currentUserFollowingRef);
                    transaction.update(targetUserRef, { followerCount: newFollowerCount });
                    transaction.update(currentUserRef, { followingCount: newFollowingCount });

                } else {
                    // FOLLOW LOGIC (no change needed here, but kept for clarity)
                    transaction.set(targetFollowersRef, { followedAt: new Date().toISOString() });
                    transaction.set(currentUserFollowingRef, { followingSince: new Date().toISOString() });
                    transaction.update(targetUserRef, { followerCount: increment(1) });
                    transaction.update(currentUserRef, { followingCount: increment(1) });
                }
            });
            showMessage(isFollowing ? `Unfollowed ${profile.creatorName}` : `You are now following ${profile.creatorName}!`);
        } catch (error) {
            console.error("Error in follow/unfollow transaction:", error);
            showMessage("Something went wrong. Please try again.");
        } finally {
            setIsFollowLoading(false);
        }
    };

// --- Function to handle the follow/unfollow action ---
    
    const handleVideoPress = (url) => {
        setCurrentVideoUrl(url);
        setShowVideoModal(true);
    };

    const closeVideoModal = () => {
        setShowVideoModal(false);
        setCurrentVideoUrl('');
    };

    if (loading) {
        return (<div className="screenContainer" style={{ textAlign: 'center', paddingTop: '50px' }}><p className="heading">Loading Profile...</p></div>);
    }

    if (!profile) return null;

    return (
        <>
            <div className="screenContainer">
                <div className="dashboardSection">
                    <div className="flex items-center mb-4">
                        <img src={profile.profilePictureUrl || 'https://placehold.co/100x100/555/FFF?text=P'} alt="Profile" style={{width: '100px', height: '100px', borderRadius: '50%', border: '2px solid #FFD700', objectFit: 'cover'}} />
                        <div style={{marginLeft: '1rem', flexGrow: 1}}>
                            <p className="dashboardItem" style={{fontSize: '20px', fontWeight: 'bold', color: '#FFF', marginBottom: '5px'}}>{profile.creatorName}</p>
                            <p className="dashboardItem" style={{fontSize: '14px', color: '#AAA'}}>Role: {profile.role}</p>
                            
                            {/* --- Follower/Following Counts --- */}
                            <div style={{display: 'flex', gap: '15px', marginTop: '10px'}}>
                                <p className="dashboardItem"><strong>{profile.followerCount || 0}</strong> Followers</p>
                                <p className="dashboardItem"><strong>{profile.followingCount || 0}</strong> Following</p>
                            </div>
                        </div>
                    </div>
                    
                    {/* --- Follow/Unfollow Button --- */}
                    {currentUser && currentUser.uid !== selectedUserId && (
                        <button className="dashboardButton" onClick={handleFollowToggle} disabled={isFollowLoading}
                            style={{ width: '100%', marginTop: '15px', backgroundColor: isFollowing ? '#555' : '#FFD700', color: isFollowing ? '#FFF' : '#0A0A0A', cursor: isFollowLoading ? 'wait' : 'pointer' }}>
                            {isFollowLoading ? 'Updating...' : (isFollowing ? 'Unfollow' : 'Follow')}
                        </button>
                    )}
                    
                    <p className="dashboardItem" style={{marginTop: '15px'}}><strong>Bio:</strong> {profile.bio || "No bio provided."}</p>
                    <p className="dashboardItem"><strong>Categories:</strong> {profile.categories?.length > 0 ? profile.categories.join(', ') : "No categories set."}</p>
                </div>

                {/* Rest of the component (Featured Content, Campaigns, etc.) remains the same */}
                <div className="dashboardSection">
                    <p className="dashboardSectionTitle">Featured Content</p>
                    {profile.featuredVideoLink && profile.featuredVideoLink.url ? (
                        <div className="vertical-carousel-item" style={{cursor: 'pointer'}} onClick={() => handleVideoPress(profile.featuredVideoLink.embedUrl || profile.featuredVideoLink.url)}>
                            <img src={profile.featuredVideoLink.thumbnailUrl || 'https://placehold.co/80x60/3A3A3A/FFF?text=Video'} alt="Featured Video" className="liveFeedThumbnail" />
                            <div className="liveFeedContent">
                                <p className="liveFeedTitle">Latest from {profile.creatorName}</p>
                                <p className="liveFeedCreator" style={{color: '#FFD700'}}>Click to watch</p>
                            <div style={{ display: 'flex', alignItems: 'center', gap: '5px', color: '#AAA', fontSize: '12px', marginTop: '4px' }}>
                            <svg viewBox="0 0 24 24" style={{ width: '16px', height: '16px', fill: 'currentColor' }}><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5C21.27 7.61 17 4.5 12 4.5zm0 10c-2.48 0-4.5-2.02-4.5-4.5S9.52 5.5 12 5.5s4.5 2.02 4.5 4.5-2.02 4.5-4.5 4.5zM12 8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"></path></svg>
                            {/* We need to access the view count from the nested object */}
                            <span>{profile.featuredVideoLink?.viewCount || 0} views</span>
                            </div>
                            </div>
                        </div>
                    ) : (<p className="dashboardItem">This creator has not featured any content.</p>)}
                </div>

                <div className="dashboardSection">
                    <p className="dashboardSectionTitle">Active Crowdfunding Campaigns</p>
                    {campaigns.length > 0 ? (campaigns.map(campaign => (
                        <div key={campaign.id} className="creator-campaign-list-item" style={{cursor: 'pointer'}} onClick={() => { setSelectedCampaignId(campaign.id); setActiveScreen('CampaignDetails'); }}>
                            <img src={campaign.imageUrl || 'https://placehold.co/80x50/3A3A3A/FFF?text=NVA'} alt={campaign.title} className="creator-campaign-thumbnail" />
                            <div className="creator-campaign-info">
                                <p className="creator-campaign-title">{campaign.title}</p>
                                <p className="creator-campaign-status status-active">Click to view campaign</p>
                            </div>
                        </div>
                    ))) : (<p className="dashboardItem">This creator does not have any active campaigns.</p>)}
                </div>

                <button className="button" onClick={() => setActiveScreen('DiscoverUsers')} style={{ backgroundColor: '#3A3A3A', color: '#FFF' }}>
                    <span className="buttonText">Back to Search</span>
                </button>
            </div>
            {showVideoModal && (<VideoPlayerModal videoUrl={currentVideoUrl} onClose={closeVideoModal} />)}
        </>
    );
};
// =================== END: REPLACE THIS ENTIRE COMPONENT ===================




        // --- START: COMPLETE AND CORRECTED ProfilePictureAdjustModal ---
    const ProfilePictureAdjustModal = ({ isUploading, imageUrl, onSave, onCancel, showMessage }) => {
            const canvasRef = useRef(null);
            const imageRef = useRef(new Image());
            const [scale, setScale] = useState(1);
            const [position, setPosition] = useState({ x: 0, y: 0 });
            const [isDragging, setIsDragging] = useState(false);
            const [dragStart, setDragStart] = useState({ x: 0, y: 0 });

            const canvasSize = 200;
            const profilePicSize = 300; // The final output size of the profile picture

            const drawImage = useCallback(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                const img = imageRef.current;

                if (!img.complete || img.naturalWidth === 0) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    return;
                }
                
                // Clear and set background
                ctx.fillStyle = '#333';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Save context state
                ctx.save();
                
                // Apply scaling for high-DPI displays
                const devicePixelRatio = window.devicePixelRatio || 1;
                ctx.scale(devicePixelRatio, devicePixelRatio);

                // Clip to a circle
                ctx.beginPath();
                ctx.arc(canvasSize / 2, canvasSize / 2, canvasSize / 2, 0, Math.PI * 2, true);
                ctx.clip();

                const scaledWidth = img.naturalWidth * scale;
                const scaledHeight = img.naturalHeight * scale;
                
                // Draw the image with current position and scale
                ctx.drawImage(img, position.x, position.y, scaledWidth, scaledHeight);
                
                // Restore context state
                ctx.restore();

            }, [scale, position, canvasSize]);
            
            useEffect(() => {
                const canvas = canvasRef.current;
                if (canvas) {
                    // Adjust canvas for high-DPI displays
                    const devicePixelRatio = window.devicePixelRatio || 1;
                    canvas.width = canvasSize * devicePixelRatio;
                    canvas.height = canvasSize * devicePixelRatio;
                    canvas.style.width = `${canvasSize}px`;
                    canvas.style.height = `${canvasSize}px`;
                }
            }, [canvasSize]);

            useEffect(() => {
                const img = imageRef.current;
                img.crossOrigin = 'anonymous';
                img.src = imageUrl;

                img.onload = () => {
                    // Initial scale to fit the image inside the circle
                    const initialScale = Math.min(canvasSize / img.naturalWidth, canvasSize / img.naturalHeight);
                    setScale(initialScale);
                    
                    // Center the image
                    const initialX = (canvasSize - img.naturalWidth * initialScale) / 2;
                    const initialY = (canvasSize - img.naturalHeight * initialScale) / 2;
                    setPosition({ x: initialX, y: initialY });
                };
                img.onerror = () => { showMessage("Failed to load image for adjustment."); };
            }, [imageUrl, showMessage, canvasSize]);

            useEffect(() => {
                drawImage();
            }, [scale, position, drawImage]);
            
            // --- Event Handlers for Panning and Zooming ---
            const handleMouseDown = (e) => {
                setIsDragging(true);
                setDragStart({ x: e.clientX - position.x, y: e.clientY - position.y });
            };
            const handleMouseMove = (e) => {
                if (!isDragging) return;
                setPosition({ x: e.clientX - dragStart.x, y: e.clientY - dragStart.y });
            };
            const handleMouseUp = () => setIsDragging(false);
            const handleMouseLeave = () => setIsDragging(false);
            
            const handleWheel = (e) => {
                e.preventDefault();
                const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
                const newScale = scale * zoomFactor;
                
                const rect = canvasRef.current.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const newPosition = {
                    x: mouseX - (mouseX - position.x) * zoomFactor,
                    y: mouseY - (mouseY - position.y) * zoomFactor
                };
                
                setScale(newScale);
                setPosition(newPosition);
            };

            // --- FULLY IMPLEMENTED SAVE FUNCTION ---
            const saveCroppedImage = () => {
                const img = imageRef.current;
                if (!img.complete || img.naturalWidth === 0) {
                    showMessage("Image not loaded for saving.");
                    return;
                }

                const outputCanvas = document.createElement('canvas');
                outputCanvas.width = profilePicSize;
                outputCanvas.height = profilePicSize;
                const ctx = outputCanvas.getContext('2d');

                ctx.beginPath();
                ctx.arc(profilePicSize / 2, profilePicSize / 2, profilePicSize / 2, 0, Math.PI * 2, true);
                ctx.clip();
                
                // Calculate how to draw the panned/zoomed image onto the new canvas
                const finalScale = scale * (profilePicSize / canvasSize);
                const finalX = position.x * (profilePicSize / canvasSize);
                const finalY = position.y * (profilePicSize / canvasSize);

                ctx.drawImage(img, finalX, finalY, img.naturalWidth * finalScale, img.naturalHeight * finalScale);
                
                outputCanvas.toBlob((blob) => {
                    if (blob) {
                        onSave(blob);
                    } else {
                        showMessage("Failed to create image file.");
                    }
                }, 'image/png', 0.9);
            };

            return (
                <div className="imageAdjustModalOverlay">
                    <div className="imageAdjustModalContent">
                        <p className="heading" style={{fontSize: '20px', marginBottom: '10px'}}>Adjust Profile Picture</p>
                        <p className="subHeading" style={{fontSize: '14px', marginBottom: '15px', color: '#CCC'}}>Drag to pan, scroll to zoom.</p>
                        <div
                            className={`canvasContainer ${isDragging ? 'dragging' : ''}`}
                            onMouseDown={handleMouseDown}
                            onMouseMove={handleMouseMove}
                            onMouseUp={handleMouseUp}
                            onMouseLeave={handleMouseLeave}
                            onWheel={handleWheel}
                        >
                            <canvas ref={canvasRef}></canvas>
                        </div>
                        <div className="modalButtons">
                            <button className="modalButton" onClick={saveCroppedImage}>Save</button>
                            <button className="modalButton cancel" onClick={onCancel}>Cancel</button>
                        </div>
                    </div>
                </div>
            );
        };
        // --- END: COMPLETE AND CORRECTED ProfilePictureAdjustModal

        // --- REPLACEMENT COMPONENT ---
        const CreateCampaignScreen = ({ showMessage, setActiveScreen, currentUser, creatorProfile }) => {
            const [title, setTitle] = useState('');
            const [description, setDescription] = useState('');
            const [goal, setGoal] = useState('');
            const [projectLink, setProjectLink] = useState(''); // Changed from imageUrl

            // New state for thumbnail handling
            const [customThumbnailFile, setCustomThumbnailFile] = useState(null);
            const [customThumbnailPreview, setCustomThumbnailPreview] = useState('');
            const [autoThumbnailPreview, setAutoThumbnailPreview] = useState('');
            const [isUploading, setIsUploading] = useState(false);
            const thumbnailInputRef = useRef(null);

            // Effect to auto-fetch thumbnail from project link
            useEffect(() => {
                if (!projectLink) {
                    setAutoThumbnailPreview('');
                    return;
                }
                const handler = setTimeout(() => {
                    const { thumbnailUrl } = extractVideoInfo(projectLink);
                    if (thumbnailUrl) {
                        setAutoThumbnailPreview(thumbnailUrl);
                    } else {
                        setAutoThumbnailPreview(''); // Clear if no thumbnail found
                    }
                }, 800); // Debounce to avoid fetching on every keystroke

                return () => clearTimeout(handler);
            }, [projectLink]);

            const handleFileChange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    setCustomThumbnailFile(file);
                    setCustomThumbnailPreview(URL.createObjectURL(file));
                }
            };

            const handleSubmit = async (e) => {
                e.preventDefault();
                setIsUploading(true);

                if (!title || !description || !goal) {
                    showMessage('Please fill in all required fields: Title, Description, and Funding Goal.');
                    setIsUploading(false);
                    return;
                }
                if (isNaN(goal) || parseFloat(goal) <= 0) {
                    showMessage('Funding Goal must be a positive number.');
                    setIsUploading(false);
                    return;
                }

                // Check for existing active campaigns
                const campaignsCollectionRef = collection(db, `artifacts/${appId}/public/data/campaigns`);
                const q = query(campaignsCollectionRef, where('creatorId', '==', currentUser.uid), where('status', '==', 'active'));
                const querySnapshot = await getDocs(q);

                if (!querySnapshot.empty) {
                    showMessage('You can only have one active crowdfunding campaign at a time.');
                    setIsUploading(false);
                    return;
                }

                let finalImageUrl = autoThumbnailPreview || ''; // Default to auto-fetched thumbnail

                // If a custom thumbnail is provided, upload it first.
                if (customThumbnailFile) {
                    showMessage("Uploading custom thumbnail...");
                    try {
                        const filePath = `campaign_thumbnails/${currentUser.uid}/${Date.now()}_${customThumbnailFile.name}`;
                        const storageRef = ref(storage, filePath);
                        const snapshot = await uploadBytes(storageRef, customThumbnailFile);
                        finalImageUrl = await getDownloadURL(snapshot.ref);
                        showMessage("Thumbnail uploaded successfully!");
                    } catch (error) {
                        console.error("Error uploading campaign thumbnail:", error);
                        showMessage(`Thumbnail upload failed: ${error.message}`);
                        setIsUploading(false);
                        return;
                    }
                }

                try {
                    const createdAt = new Date();
                    const endDate = new Date(createdAt);
                    endDate.setDate(createdAt.getDate() + 30); // Campaigns run for 30 days

                    await addDoc(campaignsCollectionRef, {
                        creatorId: currentUser.uid,
                        creatorName: creatorProfile.creatorName || currentUser.email,
                        creatorProfilePictureUrl: creatorProfile.profilePictureUrl || '',
                        title,
                        description,
                        goal: parseFloat(goal),
                        raised: 0,
                        projectLink: projectLink, // The actual link to the project/video
                        imageUrl: finalImageUrl, // The URL of the thumbnail image
                        createdAt: createdAt.toISOString(),
                        endDate: endDate.toISOString(),
                        status: 'pending' // All campaigns start as pending
                    });

                    showMessage(`Campaign "${title}" submitted for review!`);
                    setActiveScreen('CreatorDashboard');
                } catch (error) {
                    console.error("Error creating campaign:", error);
                    showMessage(`Failed to create campaign: ${error.message}.`);
                } finally {
                    setIsUploading(false);
                }
            };
            
            // Determine which preview to show
            const currentPreview = customThumbnailPreview || autoThumbnailPreview;

            return (
                <div className="screenContainer">
                    <p className="heading">Create New Campaign</p>
                    <p className="subHeading">Tell us about your project. It will be reviewed before going live.</p>
                    
                    <form onSubmit={handleSubmit}>
                        <div className="formGroup">
                            <label htmlFor="campaignTitle" className="formLabel">Campaign Title:</label>
                            <input type="text" id="campaignTitle" className="formInput" value={title} onChange={(e) => setTitle(e.target.value)} required />
                        </div>

                        <div className="formGroup">
                            <label htmlFor="campaignDescription" className="formLabel">Description:</label>
                            <textarea id="campaignDescription" className="formTextarea" value={description} onChange={(e) => setDescription(e.target.value)} placeholder="Describe your project, what you need funding for, etc." required></textarea>
                        </div>

                        <div className="formGroup">
                            <label htmlFor="campaignGoal" className="formLabel">Funding Goal (USD):</label>
                            <input type="number" id="campaignGoal" className="formInput" value={goal} onChange={(e) => setGoal(e.target.value)} min="1" step="any" required />
                        </div>

                        <div className="formGroup">
                            <label htmlFor="projectLink" className="formLabel">Project Link (Optional):</label>
                            <input type="url" id="projectLink" className="formInput" value={projectLink} onChange={(e) => setProjectLink(e.target.value)} placeholder="e.g., YouTube, Facebook video link" />
                            <p className="smallText" style={{textAlign: 'left', color: '#AAA', marginTop: '5px'}}>We'll try to generate a thumbnail from this link.</p>
                        </div>

                        <div className="formGroup">
                            <label className="formLabel">Campaign Thumbnail:</label>
                            {currentPreview && (
                                <div style={{ marginBottom: '15px' }}>
                                    <img src={currentPreview} alt="Thumbnail Preview" style={{ maxWidth: '100%', borderRadius: '8px', border: '2px solid #FFD700' }} />
                                </div>
                            )}
                            <input type="file" ref={thumbnailInputRef} onChange={handleFileChange} accept="image/*" style={{ display: 'none' }} />
                            <button type="button" className="button" onClick={() => thumbnailInputRef.current.click()} style={{ width: '100%', backgroundColor: '#3A3A3A' }}>
                                <span className="buttonText">{customThumbnailFile ? 'Change' : 'Upload'} Custom Thumbnail</span>
                            </button>
                             <p className="smallText" style={{textAlign: 'center', color: '#AAA', marginTop: '5px'}}>Recommended size: 1280x720 pixels.</p>
                        </div>

                        <button type="submit" className="button" disabled={isUploading}>
                            <span className="buttonText">{isUploading ? 'Submitting...' : 'Submit for Review'}</span>
                        </button>
                    </form>

                    <button className="button" onClick={() => setActiveScreen('CreatorDashboard')} style={{ backgroundColor: '#555', marginTop: '20px' }}>
                        <span className="buttonText">Back to Dashboard</span>
                    </button>
                </div>
            );
        };
        // --- END OF REPLACEMENT COMPONENT ---

        const AllCampaignsScreen = ({ showMessage, setActiveScreen, setSelectedCampaignId }) => {
            const [campaigns, setCampaigns] = useState([]);
            const [loading, setLoading] = useState(true);
            const [searchTerm, setSearchTerm] = useState('');
            const PLATFORM_FEE_PERCENTAGE = 0.07; 

            useEffect(() => {
                const campaignsCollectionRef = collection(db, `artifacts/${appId}/public/data/campaigns`);
                const q = query(
                    campaignsCollectionRef,
                    where('status', '==', 'active'),
                    orderBy('createdAt', 'desc')
                );

                const unsubscribe = onSnapshot(q, (snapshot) => {
                    const fetchedCampaigns = snapshot.docs.map(doc => ({
                        id: doc.id,
                        ...doc.data()
                    }));
                    setCampaigns(fetchedCampaigns);
                    setLoading(false);
                }, (error) => {
                    console.error("Error fetching campaigns:", error);
                    showMessage("Failed to load campaigns. Please try again.");
                    setLoading(false);
                });

                return () => unsubscribe();
            }, []);

            if (loading) {
                return (
                    <div className="screenContainer" style={{ textAlign: 'center', paddingTop: '50px' }}>
                        <p className="heading">Loading Campaigns...</p>
                        <p className="subHeading" style={{ color: '#FFD700' }}>Please ensure you have an internet connection.</p>
                    </div>
                );
            }

            const filteredCampaigns = campaigns.filter(campaign => 
                campaign.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
                campaign.creatorName.toLowerCase().includes(searchTerm.toLowerCase())
            );

            return (
                <div className="screenContainer">
                    <p className="heading">All Campaigns</p>
                    <p className="subHeading">Discover and support projects by Guyanese creators!</p>

                    <div className="formGroup" style={{ marginTop: '10px', marginBottom: '20px' }}>
                        <input
                            type="text"
                            className="formInput"
                            placeholder="Search by title or creator name..."
                            value={searchTerm}
                            onChange={(e) => setSearchTerm(e.target.value)}
                        />
                    </div>

                    {campaigns.length === 0 ? (
                        <p className="paragraph" style={{ textAlign: 'center', marginTop: '20px' }}>No active campaigns found yet.</p>
                    ) : filteredCampaigns.length === 0 ? (
                        <p className="paragraph" style={{ textAlign: 'center', marginTop: '20px' }}>No campaigns found matching "{searchTerm}".</p>
                    ) : (
                        <div className="allCampaignsList">
                            {filteredCampaigns.map(campaign => {
                                const isEnded = new Date(campaign.endDate) < new Date();
                                return (
                                    <div
                                        key={campaign.id}
                                        className="allCampaignsListItem"
                                        onClick={() => {
                                            setSelectedCampaignId(campaign.id);
                                            setActiveScreen('CampaignDetails');
                                        }}
                                    >
                                        <div
                                            className="campaignListImagePlaceholder"
                                            style={{ backgroundImage: campaign.imageUrl ? `url(${campaign.imageUrl})` : 'none' }}
                                            onError={(e) => { e.target.onerror = null; e.target.style.backgroundImage='none'; }}
                                        >
                                            <button
                                                className="campaignListProjectButton"
                                                onClick={(e) => {
                                                    e.stopPropagation();
                                                    if (campaign.projectLink) {
                                                        window.open(campaign.projectLink, '_blank');
                                                    } else {
                                                        showMessage('No project link provided for this campaign.');
                                                    }
                                                }}
                                            >
                                                View Project
                                            </button>
                                        </div>
                                        <div className="campaignListContent">
                                            <p className="campaignListTitle">
                                                {campaign.title} {isEnded && <span style={{color: '#DC3545', fontSize: '12px'}}>(Ended)</span>}
                                            </p>
                                            <div className="campaignListCreator">
                                                <img
                                                    src={campaign.creatorProfilePictureUrl || 'https://placehold.co/100x100/555/FFF?text=Profile'}
                                                    alt={campaign.creatorName}
                                                    className="campaignListCreatorProfilePic"
                                                    onError={(e) => { e.target.onerror = null; e.target.src='https://placehold.co/24x24/555/FFF?text=P'; }}
                                                />
                                                <span>by {campaign.creatorName}</span>
                                            </div>
                                            <p className="campaignListDescription">{campaign.description}</p>
                                            <div className="campaignProgressContainer" style={{ height: '8px', marginBottom: '5px' }}>
                                                <div
                                                    className="campaignProgressBar"
                                                    style={{ width: `${(campaign.raised / campaign.goal) * 100}%` }}
                                                ></div>
                                            </div>
                                            <div className="campaignListStats">
                                                <span>
                                                    Raised: <span className="campaignListRaised">${campaign.raised}</span>
                                                    <div className="fee-info-container">
                                                        <span className="fee-info-icon">i</span>
                                                        <div className="fee-info-tooltip">
                                                            The 'Raised' amount is the total collected. Creator receives {((1 - PLATFORM_FEE_PERCENTAGE) * 100).toFixed(0)}% of this total after the platform fee.
                                                        </div>
                                                    </div>
                                                </span>
                                                <span>Goal: <span className="campaignListGoal">${campaign.goal}</span></span>
                                            </div>
                                        </div>
                                    </div>
                                );
                            })}
                        </div>
                    )}
                    <button
                        className="button"
                        onClick={() => setActiveScreen('Support')}
                        style={{ backgroundColor: '#3A3A3A', color: '#FFF', marginTop: '30px' }}
                    >
                        <span className="buttonText">Back to Support Us</span>
                    </button>
                </div>
            );
        };

        const CampaignDetailsScreen = ({ showMessage, setActiveScreen, selectedCampaignId, currentUser, setPledgeContext }) => {
            const [campaign, setCampaign] = useState(null);
            const [loading, setLoading] = useState(true);
            const campaignImageRef = useRef(null); // Ref to the image element

            useEffect(() => {
                const fetchCampaignDetails = async () => {
                    if (!selectedCampaignId) {
                        showMessage("No campaign selected.");
                        setActiveScreen('AllCampaigns');
                        return;
                    }

                    try {
                        const campaignDocRef = doc(db, `artifacts/${appId}/public/data/campaigns`, selectedCampaignId);
                        const docSnap = await getDoc(campaignDocRef);

                        if (docSnap.exists()) {
                            setCampaign({ id: docSnap.id, ...docSnap.data() });
                        } else {
                            showMessage("Campaign not found.");
                            setActiveScreen('AllCampaigns');
                        }
                        setLoading(false);
                    } catch (error) {
                        console.error("Error fetching campaign details:", error);
                        showMessage("Failed to load campaign details. Please try again.");
                        setLoading(false);
                        setActiveScreen('AllCampaigns');
                    }
                };

                fetchCampaignDetails();
            }, [selectedCampaignId, setActiveScreen, showMessage]);

            // THIS IS THE NEW, CORRECTLY PLACED FUNCTION
            const handleSupportCampaign = () => {
                if (!campaign) return;

                const isEnded = new Date(campaign.endDate) < new Date();
                if (isEnded || campaign.status !== 'active') {
                    showMessage("This campaign is not active and cannot receive donations.");
                    return;
                }
                if (!currentUser) {
                    showMessage("Please log in to support a campaign.");
                    setActiveScreen('Login');
                    return;
                }

                setPledgeContext({
                    type: 'donation',
                    campaignId: campaign.id,
                    campaignTitle: campaign.title,
                    creatorName: campaign.creatorName,
                    amount: '' // Start with an empty amount
                });
                setActiveScreen('DonationPledge');
            };
// =========== END FUNCTION REPLACEMENT ===========

            if (loading) {
                return (
                    <div className="screenContainer" style={{ textAlign: 'center', paddingTop: '50px' }}>
                        <p className="heading">Loading Campaign Details...</p>
                        <p className="subHeading" style={{ color: '#FFD700' }}>Please ensure you have an internet connection.</p>
                    </div>
                );
            }

            if (!campaign) {
                return null;
            }

            const progressPercentage = (campaign.raised / campaign.goal) * 100;
            const isCampaignEnded = new Date(campaign.endDate) < new Date();
            const daysRemaining = Math.ceil((new Date(campaign.endDate).getTime() - new Date().getTime()) / (1000 * 60 * 60 * 24));
            const isCampaignActive = campaign.status === 'active' && !isCampaignEnded;


            return (
                <div className="screenContainer">
                    <div className="campaignDetailHeader">
                        <img
                            ref={campaignImageRef}
                            src={campaign.imageUrl}
                            alt={campaign.title}
                            className="campaignDetailImage"
                            onError={(e) => { e.target.style.display = 'none'; }} /* Hide image if it fails to load */
                            style={{ display: campaign.imageUrl ? 'block' : 'none' }} /* Initially hide if no imageUrl */
                        />
                        <p className="campaignDetailTitle">
                            {campaign.title}
                            {isCampaignEnded && <span style={{color: '#DC3545', fontSize: '16px', marginLeft: '10px'}}>(Ended)</span>}
                            {!isCampaignEnded && campaign.status === 'pending' && <span style={{color: '#FFD700', fontSize: '16px', marginLeft: '10px'}}>(Pending Review)</span>}
                            {!isCampaignEnded && campaign.status === 'rejected' && <span style={{color: '#DC3545', fontSize: '16px', marginLeft: '10px'}}>(Rejected)</span>}
                            {!isCampaignEnded && campaign.status === 'active' && <span style={{color: '#00FF00', fontSize: '16px', marginLeft: '10px'}}>(Active)</span>}
                            {!isCampaignEnded && campaign.status === 'cancelled' && <span style={{color: '#888', fontSize: '16px', marginLeft: '10px'}}>(Cancelled)</span>}
                        </p>
                        <div className="campaignDetailCreator">
                            <img
                                src={campaign.creatorProfilePictureUrl || 'https://placehold.co/100x100/555/FFF?text=Profile'}
                                alt={campaign.creatorName}
                                className="campaignDetailCreatorProfilePic"
                                onError={(e) => { e.target.onerror = null; e.target.src='https://placehold.co/32x32/555/FFF?text=P'; }}
                            />
                            <span>by {campaign.creatorName}</span>
                        </div>
                    </div>

                    <p className="campaignDetailDescription">{campaign.description}</p>

                    <div className="campaignDetailStats">
                        <div className="campaignDetailStatItem">
                            <p className="campaignDetailStatValue">${campaign.raised}</p>
                            <p>Raised</p>
                        </div>
                        <div className="campaignDetailStatItem">
                            <p className="campaignDetailStatValue">${campaign.goal}</p>
                            <p>Goal</p>
                        </div>
                        <div className="campaignDetailStatItem">
                            <p className="campaignDetailStatValue">{Math.round(progressPercentage)}%</p>
                            <p>Progress</p>
                        </div>
                    </div>
                    <div className="campaignDetailProgressBarContainer">
                        <div className="campaignDetailProgressBar" style={{ width: `${progressPercentage}%` }}></div>
                    </div>

                    {isCampaignEnded ? (
                        <p className="smallText" style={{ textAlign: 'center', color: '#DC3545', marginTop: '10px' }}>
                            This campaign ended on {new Date(campaign.endDate).toLocaleDateString()}.
                        </p>
                    ) : (
                        <p className="smallText" style={{ textAlign: 'center', color: '#00FF00', marginTop: '10px' }}>
                            {daysRemaining > 0 ? `${daysRemaining} days remaining` : 'Campaign ending soon!'}
                        </p>
                    )}

                    {/* =========== START BUTTON REPLACEMENT =========== */}
                    <button
                        className="button"
                        onClick={handleSupportCampaign}
                        disabled={!isCampaignActive} // Only active campaigns can be supported
                        style={!isCampaignActive ? { backgroundColor: '#555', cursor: 'not-allowed' } : {}}
                    >
                        <span className="buttonText">{isCampaignEnded ? 'Campaign Ended' : (campaign.status === 'pending' ? 'Pending Review' : (campaign.status === 'rejected' ? 'Campaign Rejected' : (campaign.status === 'cancelled' ? 'Campaign Cancelled' : 'Support This Campaign')))}</span>
                    </button>
{/* =========== END BUTTON REPLACEMENT =========== */}

                    {/* --- START: ADDED/CORRECTED PROJECT LINK BUTTON --- */}
                    {campaign.projectLink && (
                    <button
                        className="button"
                        onClick={() => window.open(campaign.projectLink, '_blank')}
                        style={{ backgroundColor: '#3A3A3A', marginTop: '10px' }}
                    >
                        <span className="buttonText light">Visit Project Link</span>
                    </button>
                )}
                    {/* --- END: ADDED/CORRECTED PROJECT LINK BUTTON --- */}

                    <button
                    className="button"
                    onClick={() => setActiveScreen('AllCampaigns')}
                    style={{ backgroundColor: '#3A3A3A', marginTop: '30px' }}
                >
                    <span className="buttonText light">Back to All Campaigns</span>
                </button>
            </div>
            );
        };

const DataCorrectionTool = ({ showMessage }) => {
    const [isScanning, setIsScanning] = useState(false);
    const [scanResults, setScanResults] = useState('');

    const runCountCorrection = async () => {
        setIsScanning(true);
        setScanResults('Starting scan... This may take a moment.');
        showMessage('Starting data integrity scan...');

        try {
            const creatorsRef = collection(db, "creators");
            const querySnapshot = await getDocs(creatorsRef);
            let followersCorrected = 0;
            let followingCorrected = 0;
            let usersScanned = 0;

            for (const userDoc of querySnapshot.docs) {
                const userData = userDoc.data();
                const userId = userDoc.id;
                
                // 1. Check Followers
                const followersRef = collection(db, "creators", userId, "followers");
                const followersSnapshot = await getDocs(followersRef);
                const actualFollowerCount = followersSnapshot.size;
                const storedFollowerCount = userData.followerCount || 0;

                if (actualFollowerCount !== storedFollowerCount) {
                    await updateDoc(doc(db, "creators", userId), { followerCount: actualFollowerCount });
                    followersCorrected++;
                }
                
                // 2. Check Following
                const followingRef = collection(db, "creators", userId, "following");
                const followingSnapshot = await getDocs(followingRef);
                const actualFollowingCount = followingSnapshot.size;
                const storedFollowingCount = userData.followingCount || 0;
                
                if (actualFollowingCount !== storedFollowingCount) {
                    await updateDoc(doc(db, "creators", userId), { followingCount: actualFollowingCount });
                    followingCorrected++;
                }
                
                usersScanned++;
            }

            const resultsMessage = `Scan Complete. Scanned ${usersScanned} users. Corrected ${followersCorrected} follower counts and ${followingCorrected} following counts.`;
            setScanResults(resultsMessage);
            showMessage('Scan complete!');

        } catch (error) {
            console.error("Error during count correction:", error);
            const errorMessage = `An error occurred: ${error.message}`;
            setScanResults(errorMessage);
            showMessage(errorMessage);
        } finally {
            setIsScanning(false);
        }
    };

    return (
        <div className="dashboardSection" style={{ border: '2px solid #DC3545', marginTop: '20px' }}>
            <p className="dashboardSectionTitle">Data Correction Tools</p>
            <p className="dashboardItem" style={{ color: '#AAA', marginBottom: '15px' }}>
                Use this tool if you suspect that follower or following counts are incorrect for some users.
            </p>
            <button
                className="button"
                onClick={runCountCorrection}
                disabled={isScanning}
                style={{ backgroundColor: '#FF8C00' }}
            >
                <span className="buttonText">{isScanning ? 'Scanning...' : 'Recalculate All Follow Counts'}</span>
            </button>
            {scanResults && (
                <p className="paragraph" style={{ marginTop: '15px', backgroundColor: '#1A1A1A', padding: '10px', borderRadius: '5px' }}>
                    {scanResults}
                </p>
            )}
        </div>
    );
};

// AdminDashboardScreen Component
const AdminDashboardScreen = ({
    showMessage,
    setActiveScreen,
    featuredContentSlots,
    currentUser,
    setSelectedAdminCampaignId,
    creatorProfile,
    selectedAdminSubScreen,
    setSelectedAdminSubScreen,
    setShowConfirmationModal,
    setConfirmationTitle,
    setConfirmationMessage,
    setOnConfirmationAction
}) => {

    const [isUserManagementExpanded, setIsUserManagementExpanded] = useState(true);
    const [pledgeSortType, setPledgeSortType] = useState('date');
    const [pendingPledges, setPendingPledges] = useState([]);
    const [loadingPledges, setLoadingPledges] = useState(true);
    const [isPaymentsExpanded, setIsPaymentsExpanded] = useState(true);

    useEffect(() => {
        if (creatorProfile && creatorProfile.role === 'admin') {
            const pledgesRef = collection(db, "paymentPledges");
            const q = query(pledgesRef, where('status', '==', 'pending'), orderBy('createdAt', 'asc'));
            const unsubscribe = onSnapshot(q, (snapshot) => {
                const fetchedPledges = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                setPendingPledges(fetchedPledges);
                setLoadingPledges(false);
            });
            return () => unsubscribe();
        } else {
            setLoadingPledges(false);
        }
    }, [creatorProfile]);

    const handleApprovePledge = async (pledgeId) => {
        showMessage(`Approving pledge ${pledgeId}...`);
        try {
            const functions = getFunctions(window.firebaseApp);
            const approvePledgeCallable = httpsCallable(functions, 'approvePledge');
            const result = await approvePledgeCallable({ pledgeId: pledgeId, appId: appId });
            showMessage(result.data.message);
        } catch (error) {
            console.error("Error calling approvePledge function:", error);
            showMessage(`Error: ${error.message}`);
        }
    };

    // START of REPLACEMENT Block
        const denyPledgeLogic = async (pledgeId) => {
            showMessage(`Denying pledge...`);
            try {
                // The ONLY job of this function now is to delete the pledge.
                // The onPledgeDelete backend trigger will automatically send the notification.
                await deleteDoc(doc(db, "paymentPledges", pledgeId));
                showMessage("Pledge denied and removed successfully.");
            } catch (error) {
                console.error("Error denying pledge:", error);
                showMessage(`Error denying pledge: ${error.message}`);
            }
        };
    
        const confirmDenyPledge = (pledge) => {
            setConfirmationTitle("Deny Pledge?");
            setConfirmationMessage(`Are you sure you want to deny and permanently delete this pledge from ${pledge.userName} for $${pledge.amount.toFixed(2)}? This action will notify the user and cannot be undone.`);
            setOnConfirmationAction(() => () => denyPledgeLogic(pledge.id));
            setShowConfirmationModal(true);
        };
       // END of REPLACEMENT Block

    const [isPendingCampaignsExpanded, setIsPendingCampaignsExpanded] = useState(true);
    const [isActiveCampaignsExpanded, setIsActiveCampaignsExpanded] = useState(true);
    const [searchTerm, setSearchTerm] = useState('');
    const [selectedRole, setSelectedRole] = useState('All');
    const [pendingCampaigns, setPendingCampaigns] = useState([]);
    const [activeCampaigns, setActiveCampaigns] = useState([]);
    const [allUsers, setAllUsers] = useState([]);
    const [loading, setLoading] = useState(true);
        const [isUpdatingRole, setIsUpdatingRole] = useState(null);
    const [banRequests, setBanRequests] = useState([]);
    const [isSubmittingRequest, setIsSubmittingRequest] = useState(null);
    const [isCorrectingCount, setIsCorrectingCount] = useState(null);
    const changeUserRoleLogic = async (targetUser, newRole) => { setIsUpdatingRole(targetUser.id); showMessage(`Updating role for ${targetUser.creatorName || targetUser.email}...`); try { const userDocRef = doc(db, "creators", targetUser.id); await updateDoc(userDocRef, { role: newRole }); showMessage(`Success! ${targetUser.creatorName || targetUser.email} is now a(n) ${newRole}.`); } catch (error) { console.error("Error changing user role:", error); showMessage(`Error: ${error.message}`); } finally { setIsUpdatingRole(null); } };
    const confirmChangeUserRole = (targetUser, newRole) => { setConfirmationTitle("Change User Role?"); setConfirmationMessage(`Are you sure you want to change ${targetUser.creatorName || targetUser.email}'s role to "${newRole}"?`); setOnConfirmationAction(() => () => changeUserRoleLogic(targetUser, newRole)); setShowConfirmationModal(true); };
    const toggleBanLogic = async (userToBan) => { if (userToBan.id === currentUser.uid) { showMessage("You cannot ban your own account."); return; } if (creatorProfile.role === 'authority' && userToBan.role === 'authority') { setIsSubmittingRequest(userToBan.id); try { const banRequestRef = collection(db, "banRequests"); await addDoc(banRequestRef, { requesterId: currentUser.uid, requesterName: creatorProfile.creatorName, targetUserId: userToBan.id, targetUserName: userToBan.creatorName || userToBan.email, status: 'pending', timestamp: new Date().toISOString() }); showMessage(`Ban request for ${userToBan.creatorName || userToBan.email} has been submitted for Admin approval.`); } catch (error) { console.error("Error submitting ban request:", error); showMessage(`Failed to submit ban request: ${error.message}`); } finally { setIsSubmittingRequest(null); } return; } if (creatorProfile.role === 'authority' && userToBan.role === 'admin') { showMessage("Authority users cannot ban Admin accounts."); return; } try { const userDocRef = doc(db, "creators", userToBan.id); await updateDoc(userDocRef, { banned: !userToBan.banned, updatedAt: new Date().toISOString() }); showMessage(`${userToBan.banned ? 'Unbanned' : 'Banned'} user: ${userToBan.creatorName || userToBan.email}`); } catch (error) { console.error("Error toggling ban status:", error); showMessage(`Failed to toggle ban status: ${error.message}`); } };
    const confirmToggleBan = (userToBan) => { const action = userToBan.banned ? 'Unban' : 'Ban'; const targetUserText = userToBan.creatorName || userToBan.email; if (creatorProfile.role === 'authority' && userToBan.role === 'authority') { setConfirmationTitle('Request Authority Ban?'); setConfirmationMessage(`This will submit a request for an Admin to ban ${targetUserText}. Proceed?`); } else { setConfirmationTitle(`${action} User?`); setConfirmationMessage(`Are you sure you want to ${action.toLowerCase()} user ${targetUserText}?`); } setOnConfirmationAction(() => () => toggleBanLogic(userToBan)); setShowConfirmationModal(true); };
    const handleApproveBanRequest = async (request) => { try { const userToBanRef = doc(db, "creators", request.targetUserId); const requestRef = doc(db, "banRequests", request.id); await updateDoc(userToBanRef, { banned: true }); await deleteDoc(requestRef); showMessage(`Request approved. User ${request.targetUserName} has been banned.`); } catch (error) { console.error("Error approving ban request:", error); showMessage(`Failed to approve ban request: ${error.message}`); } };
    const handleDenyBanRequest = async (request) => { try { await deleteDoc(doc(db, "banRequests", request.id)); showMessage(`Request to ban ${request.targetUserName} has been denied.`); } catch (error) { console.error("Error denying ban request:", error); showMessage(`Failed to deny ban request: ${error.message}`); } };
    const toggleSection = (setterFunction, currentState) => { setterFunction(!currentState); };
    const recalculateCountsForUser = async (userToFix) => { setIsCorrectingCount(userToFix.id); showMessage(`Recalculating counts for ${userToFix.creatorName || userToFix.email}...`); try { const followersRef = collection(db, "creators", userToFix.id, "followers"); const followersSnapshot = await getDocs(followersRef); const actualFollowerCount = followersSnapshot.size; const followingRef = collection(db, "creators", userToFix.id, "following"); const followingSnapshot = await getDocs(followingRef); const actualFollowingCount = followingSnapshot.size; await updateDoc(doc(db, "creators", userToFix.id), { followerCount: actualFollowerCount, followingCount: actualFollowingCount }); showMessage(`Counts for ${userToFix.creatorName || userToFix.email} have been corrected.`); } catch (error) { console.error("Error during single-user count correction:", error); showMessage(`Error correcting counts: ${error.message}`); } finally { setIsCorrectingCount(null); } };
    const confirmRecalculate = (userToFix) => { setConfirmationTitle("Recalculate Counts?"); setConfirmationMessage(`This will manually recount followers and following for "${userToFix.creatorName || userToFix.email}" and update their profile. Proceed?`); setOnConfirmationAction(() => () => recalculateCountsForUser(userToFix)); setShowConfirmationModal(true); };
    useEffect(() => { const campaignsCollectionRef = collection(db, `artifacts/${appId}/public/data/campaigns`); const qPending = query(campaignsCollectionRef, where('status', '==', 'pending'), orderBy('createdAt', 'asc')); const unsubscribePending = onSnapshot(qPending, (snapshot) => { setPendingCampaigns(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }))); }); const qActive = query(campaignsCollectionRef, where('status', '==', 'active'), orderBy('createdAt', 'desc')); const unsubscribeActive = onSnapshot(qActive, (snapshot) => { setActiveCampaigns(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }))); }); const usersCollectionRef = collection(db, "creators"); const unsubscribeUsers = onSnapshot(usersCollectionRef, (snapshot) => { setAllUsers(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }))); setLoading(false); }); let unsubscribeBanRequests = () => {}; if (creatorProfile && creatorProfile.role === 'admin') { const banRequestsRef = collection(db, "banRequests"); const q = query(banRequestsRef, where('status', '==', 'pending')); unsubscribeBanRequests = onSnapshot(q, (snapshot) => { setBanRequests(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }))); }); } return () => { unsubscribePending(); unsubscribeActive(); unsubscribeUsers(); unsubscribeBanRequests(); }; }, [creatorProfile]);
    
    if (!currentUser || !creatorProfile || (creatorProfile.role !== 'admin' && creatorProfile.role !== 'authority')) { return ( <div className="screenContainer"> <p className="heading">Access Denied</p> <p className="subHeading">You must be an Admin or Authority to view this dashboard.</p> <button className="button" onClick={() => setActiveScreen('Login')}><span className="buttonText">Go to Login</span></button> </div> ); }
    if (loading) { return ( <div className="screenContainer" style={{ textAlign: 'center', paddingTop: '50px' }}> <p className="heading">Loading Admin Dashboard...</p> <p className="subHeading" style={{ color: '#FFD700' }}>Please wait.</p> </div> ); }
    const filteredUsers = allUsers.filter(user => { if (creatorProfile.role === 'authority' && user.role === 'admin') { return false; } const matchesSearchTerm = searchTerm === '' || (user.creatorName && user.creatorName.toLowerCase().includes(searchTerm.toLowerCase())) || (user.email && user.email.toLowerCase().includes(searchTerm.toLowerCase())); const matchesRole = selectedRole === 'All' || user.role === selectedRole; return matchesSearchTerm && matchesRole; });

    const sortedPledges = [...pendingPledges].sort((a, b) => {
        if (pledgeSortType === 'type') {
            if (a.paymentType < b.paymentType) return -1;
            if (a.paymentType > b.paymentType) return 1;
        }
        return new Date(b.createdAt) - new Date(a.createdAt);
    });

    return (
        <div className="screenContainer">
            <p className="heading">Admin Dashboard</p>
            <p className="subHeading">Manage users and crowdfunding campaigns.</p>

            <div style={{ display: 'flex', justifyContent: 'center', gap: '10px', paddingBottom: '20px', flexWrap: 'wrap', position: 'sticky', top: 0, zIndex: 50, backgroundColor: '#0A0A0A' }}>
                <button className="button" onClick={() => setSelectedAdminSubScreen('Overview')} style={{ backgroundColor: selectedAdminSubScreen === 'Overview' ? '#FFD700' : '#3A3A3A', color: selectedAdminSubScreen === 'Overview' ? '#0A0A0A' : '#FFF' }}><span className="buttonText">Overview</span></button>
                <button className="button" onClick={() => setSelectedAdminSubScreen('ContentManagement')} style={{ backgroundColor: selectedAdminSubScreen === 'ContentManagement' ? '#FFD700' : '#3A3A3A', color: selectedAdminSubScreen === 'ContentManagement' ? '#0A0A0A' : '#FFF' }}><span className="buttonText">Content</span></button>
                <button className="button" onClick={() => setSelectedAdminSubScreen('ManageCategories')} style={{ backgroundColor: selectedAdminSubScreen === 'ManageCategories' ? '#FFD700' : '#3A3A3A', color: selectedAdminSubScreen === 'ManageCategories' ? '#0A0A0A' : '#FFF' }}><span className="buttonText">Categories</span></button>
                <button className="button" onClick={() => setSelectedAdminSubScreen('SiteManagement')} style={{ backgroundColor: selectedAdminSubScreen === 'SiteManagement' ? '#FFD700' : '#3A3A3A', color: selectedAdminSubScreen === 'SiteManagement' ? '#0A0A0A' : '#FFF' }}><span className="buttonText">Site Management</span></button>
                <button className="button" onClick={() => setActiveScreen('AnalyticsDashboard')} style={{ backgroundColor: '#3A3A3A', color: '#FFF' }}><span className="buttonText">Analytics</span></button>
            </div>

            {selectedAdminSubScreen === 'Overview' && (
                <>
                    {creatorProfile.role === 'admin' && banRequests.length > 0 && ( <section className="dashboardSection" style={{ border: '2px solid #FFD700' }}> <p className="dashboardSectionTitle">Pending Authority Ban Requests ({banRequests.length})</p> <div className="dashboardContentList"> {banRequests.map(req => ( <div key={req.id} className="adminDashboardItem"> <div style={{ flexGrow: 1 }}> <p className="adminDashboardItemTitle">Target: {req.targetUserName}</p> <p style={{ fontSize: '12px', color: '#CCC' }}>Requested by: {req.requesterName}</p> </div> <button className="adminActionButton approve" onClick={() => handleApproveBanRequest(req)}>Approve Ban</button> <button className="adminActionButton reject" onClick={() => handleDenyBanRequest(req)}>Deny Request</button> </div> ))} </div> </section> )}
                   <section className="dashboardSection"> <div className="flex justify-between items-center cursor-pointer py-2" onClick={() => toggleSection(setIsUserManagementExpanded, isUserManagementExpanded)}> <p className="dashboardSectionTitle" style={{ marginBottom: '0' }}>User Management</p> <button className="admin-toggle-button">{isUserManagementExpanded ? '\u25BC' : '\u25B6'}</button> </div> <div id="user-management-content" className={`overflow-hidden transition-max-height duration-500 ease-in-out ${isUserManagementExpanded ? 'max-h-screen' : 'max-h-0'}`}> <div className="pt-4 border-t border-gray-200 mt-4" style={{ borderColor: '#3A3A3A' }}> <div className="formGroup" style={{ marginBottom: '15px' }}><label htmlFor="userSearch" className="formLabel">Search Users:</label><input type="text" id="userSearch" className="formInput" value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} placeholder="Search by name or email" /></div> <div className="formGroup" style={{ marginBottom: '15px' }}><label htmlFor="roleFilter" className="formLabel">Filter by Role:</label><select id="roleFilter" className="formInput" value={selectedRole} onChange={(e) => setSelectedRole(e.target.value)}><option value="All">All Roles</option><option value="user">User</option><option value="creator">Creator</option><option value="admin">Admin</option><option value="authority">Authority</option></select></div> {filteredUsers.length === 0 ? <p className="dashboardItem">No users to display matching your criteria.</p> : <div className="dashboardContentList"> {filteredUsers.map(user => ( <div key={user.id} className="adminDashboardItem" style={{alignItems: 'flex-start'}}> <div style={{ flexGrow: 1, marginRight: '10px' }}> <p className="adminDashboardItemTitle">{user.creatorName || user.email}</p> <p style={{ fontSize: '12px', color: '#CCC' }}>Role: {user.role}</p> <p style={{ fontSize: '12px', color: user.banned ? '#DC3545' : '#00FF00' }}>Status: {user.banned ? 'Banned' : 'Active'}</p> <p style={{ fontSize: '10px', color: '#AAA' }}>User ID: {user.id}</p> </div> <div style={{display: 'flex', flexDirection: 'column', gap: '10px', alignItems: 'flex-end'}}> {currentUser.uid !== user.id && <button className={`adminActionButton ${user.banned ? 'approve' : 'reject'}`} onClick={() => confirmToggleBan(user)} disabled={isSubmittingRequest === user.id}> {isSubmittingRequest === user.id ? 'Submitting...' : (user.banned ? 'Unban' : 'Ban')} </button>} <div className="formGroup" style={{marginBottom: 0}}> <select className="formInput" value={user.role} onChange={(e) => confirmChangeUserRole(user, e.target.value)} disabled={isUpdatingRole === user.id || user.id === currentUser.uid || (creatorProfile.role === 'authority' && user.role === 'admin')} style={{padding: '5px', fontSize: '12px', width: '120px'}}> <option value="user">User</option> <option value="creator">Creator</option> <option value="authority">Authority</option> {creatorProfile.role === 'admin' && <option value="admin">Admin</option>} </select> {isUpdatingRole === user.id && <p style={{fontSize: '10px', color: '#FFD700', textAlign: 'right'}}>Updating...</p>} </div> <button className="adminActionButton" onClick={() => confirmRecalculate(user)} disabled={isCorrectingCount === user.id} style={{ backgroundColor: '#FF8C00' }}> {isCorrectingCount === user.id ? 'Recalculating...' : 'Recalculate Counts'} </button> </div> </div> ))} </div> } </div> </div> </section>
                    <section className="dashboardSection"> <div className="flex justify-between items-center cursor-pointer py-2" onClick={() => toggleSection(setIsPendingCampaignsExpanded, isPendingCampaignsExpanded)}> <p className="dashboardSectionTitle" style={{ marginBottom: '0' }}>Pending Campaigns ({pendingCampaigns.length})</p> <button className="admin-toggle-button">{isPendingCampaignsExpanded ? '\u25BC' : '\u25B6'}</button> </div> <div id="pending-campaigns-content" className={`overflow-hidden transition-max-height duration-500 ease-in-out ${isPendingCampaignsExpanded ? 'max-h-screen' : 'max-h-0'}`}> <div className="pt-4 border-t border-gray-200 mt-4" style={{ borderColor: '#3A3A3A' }}> {pendingCampaigns.length === 0 ? <p className="dashboardItem">No campaigns currently pending review.</p> : <div className="dashboardContentList"> {pendingCampaigns.map(campaign => ( 
                    <div key={campaign.id} className="adminDashboardItem" onClick={() => { setSelectedAdminCampaignId(campaign.id); setActiveScreen('AdminCampaignDetails'); }} style={{ cursor: 'pointer', alignItems: 'center' }}>
                                    <img 
                                        src={campaign.imageUrl || 'https://placehold.co/80x45/3A3A3A/FFF?text=N/A'} 
                                        alt="Campaign Thumbnail"
                                        style={{ width: '80px', height: '45px', objectFit: 'cover', borderRadius: '4px', marginRight: '15px' }}
                                    />
                                    <div style={{ flexGrow: 1, marginRight: '10px' }}>
                                        <p className="adminDashboardItemTitle">{campaign.title}</p>
                                        <p style={{ fontSize: '12px', color: '#CCC' }}>by {campaign.creatorName}</p>
                                    </div>
                                </div> 
                                ))} 
                            </div> } 
                        </div> 
                    </div> 
                </section>
             <section className="dashboardSection"> <div className="flex justify-between items-center cursor-pointer py-2" onClick={() => toggleSection(setIsActiveCampaignsExpanded, isActiveCampaignsExpanded)}> <p className="dashboardSectionTitle" style={{ marginBottom: '0' }}>Active Campaigns ({activeCampaigns.length})</p> <button className="admin-toggle-button">{isActiveCampaignsExpanded ? '\u25BC' : '\u25B6'}</button> </div> <div id="active-campaigns-content" className={`overflow-hidden transition-max-height duration-500 ease-in-out ${isActiveCampaignsExpanded ? 'max-h-screen' : 'max-h-0'}`}> <div className="pt-4 border-t border-gray-200 mt-4" style={{ borderColor: '#3A3A3A' }}> {activeCampaigns.length === 0 ? <p className="dashboardItem">No campaigns currently active.</p> : <div className="dashboardContentList"> {activeCampaigns.map(campaign => ( 
             <div key={campaign.id} className="adminDashboardItem" onClick={() => { setSelectedAdminCampaignId(campaign.id); setActiveScreen('AdminCampaignDetails'); }} style={{ cursor: 'pointer', alignItems: 'center' }}>
                                    <img 
                                        src={campaign.imageUrl || 'https://placehold.co/80x45/3A3A3A/FFF?text=N/A'} 
                                        alt="Campaign Thumbnail"
                                        style={{ width: '80px', height: '45px', objectFit: 'cover', borderRadius: '4px', marginRight: '15px' }}
                                    />
                                    <div style={{ flexGrow: 1, marginRight: '10px' }}>
                                        <p className="adminDashboardItemTitle">{campaign.title}</p>
                                        <p style={{ fontSize: '12px', color: '#CCC' }}>by {campaign.creatorName}</p>
                                    </div>
                                </div> 
                                ))} 
                                </div> } 
                            </div> 
                        </div> 
                    </section>
                   
                   <section className="dashboardSection">
                         <p className="dashboardSectionTitle">Community Management</p>
                         <button className="button" onClick={() => setActiveScreen('PremiumMembersScreen')} style={{width: '100%', backgroundColor: '#FFD700', color: '#0A0A0A'}}>
                            <span className="buttonText">View All Premium Members </span>
                        </button>
                    </section>
                   
                    {creatorProfile.role === 'admin' && selectedAdminSubScreen === 'Overview' && (
                        <section className="dashboardSection" style={{border: '2px solid #FFD700'}}>
                            <div className="flex justify-between items-center cursor-pointer py-2" onClick={() => toggleSection(setIsPaymentsExpanded, isPaymentsExpanded)}>
                                <p className="dashboardSectionTitle" style={{marginBottom: 0}}>Pending Payments ({pendingPledges.length})</p>
                                <button className="admin-toggle-button">{isPaymentsExpanded ? '\u25BC' : '\u25B6'}</button>
                            </div>
                            <div id="pending-payments-content" className={`overflow-hidden transition-max-height duration-500 ease-in-out ${isPaymentsExpanded ? 'max-h-screen' : 'max-h-0'}`}>
                                <div className="pt-4 border-t border-gray-200 mt-4" style={{borderColor: '#3A3A3A'}}>
                                    <div style={{display: 'flex', gap: '10px', justifyContent: 'flex-end', marginBottom: '15px'}}>
                                        <button className="sectionHeaderButton" style={{backgroundColor: pledgeSortType === 'date' ? '#FFD700' : '#555', color: pledgeSortType === 'date' ? '#0A0A0A' : '#FFF'}} onClick={() => setPledgeSortType('date')}>Sort by Time</button>
                                        <button className="sectionHeaderButton" style={{backgroundColor: pledgeSortType === 'type' ? '#FFD700' : '#555', color: pledgeSortType === 'type' ? '#0A0A0A' : '#FFF'}} onClick={() => setPledgeSortType('type')}>Sort by Type</button>
                                    </div>
                                    {loadingPledges ? (
                                        <p className="dashboardItem">Loading pending payments...</p>
                                    ) : pendingPledges.length === 0 ? (
                                        <p className="dashboardItem">There are no payments pending review.</p>
                                    ) : (
                                        <div className="dashboardContentList">
                                            {sortedPledges.map(pledge => (
                                                <div key={pledge.id} className="adminDashboardItem" style={{flexDirection: 'column', alignItems: 'stretch', gap: '10px'}}>
                                                    <div className="flex justify-between items-center">
                                                        <p className="adminDashboardItemTitle">{pledge.paymentType === 'premium' ? 'Premium Subscription' : (pledge.paymentType === 'eventTicket' ? 'Event Ticket' : 'Campaign Donation')}</p>
                                                        <p style={{fontSize: '18px', fontWeight: 'bold', color: '#FFD70D'}}>${pledge.amount.toFixed(2)}</p>
                                                    </div>
                                                    <div style={{fontSize: '12px', color: '#CCC'}}>
                                                        <p>Pledge ID: <span style={{fontWeight: 'bold', color: '#FFF'}}>{pledge.pledgeId}</span></p>
                                                        <p>User: {pledge.userName} ({pledge.userEmail})</p>
                                                        {pledge.paymentType === 'donation' && <p>Campaign: {pledge.targetCampaignTitle}</p>}
                                                        {pledge.paymentType === 'eventTicket' && <p>Event: {pledge.targetEventTitle || 'Live Premiere'}</p>}
                                                        <p>Date: {new Date(pledge.createdAt).toLocaleString()}</p>
                                                    </div>
                                                    <div className="flex justify-end items-center gap-4 mt-2">
                                                        <button className="adminActionButton reject" onClick={() => confirmDenyPledge(pledge)}>Deny</button>
                                                        <button className="adminActionButton approve" onClick={() => handleApprovePledge(pledge.id)}>Approve</button>
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                    )}
                                </div>
                            </div>
                        </section>
                    )}
                    <button className="button" onClick={() => setActiveScreen('Home')} style={{ backgroundColor: '#3A3A3A', color: '#FFF', marginTop: '30px' }}><span className="buttonText light">Back to Home</span></button>
                </>
            )}

            {selectedAdminSubScreen === 'ContentManagement' && (
                <AdminContentManagerScreen
                    showMessage={showMessage}
                    featuredContentSlots={featuredContentSlots}
                    setActiveScreen={setActiveScreen}
                    currentUser={currentUser}
                    creatorProfile={creatorProfile}
                    setShowConfirmationModal={setShowConfirmationModal}
                    setConfirmationTitle={setConfirmationTitle}
                    setConfirmationMessage={setConfirmationMessage}
                    setOnConfirmationAction={setOnConfirmationAction}
                />
            )}

            {selectedAdminSubScreen === 'ManageCategories' && (
                <AdminCategoryManagerScreen
                    showMessage={showMessage}
                    setActiveScreen={setActiveScreen}
                    setShowConfirmationModal={setShowConfirmationModal}
                    setConfirmationTitle={setConfirmationTitle}
                    setConfirmationMessage={setConfirmationMessage}
                    setOnConfirmationAction={setOnConfirmationAction}
                />
            )}
            
            {selectedAdminSubScreen === 'SiteManagement' && (
                <AdminSiteManagerScreen
                showMessage={showMessage}
                setActiveScreen={setActiveScreen}
                setShowConfirmationModal={setShowConfirmationModal}
                setConfirmationTitle={setConfirmationTitle}
                setConfirmationMessage={setConfirmationMessage}
                setOnConfirmationAction={setOnConfirmationAction}
                creatorProfile={creatorProfile}
                />
            )}

        </div>
    );
};
// =================== END REPLACEMENT ===================

        const ConfirmationModal = ({ title, message, onConfirm, onCancel }) => {
            return (
                <div className="confirmationModalOverlay">
                    <div className="confirmationModalContent">
                        <p className="confirmationModalTitle">{title}</p>
                        <p className="confirmationModalMessage">{message}</p>
                        <div className="confirmationModalButtons">
                            <button className="confirmationButton confirm" onClick={() => {
                                if (typeof onConfirm === 'function') {
                                    onConfirm(); // First, run the assigned action
                                }
                                onCancel();  // Then, run the function that closes the modal
                            }}>Confirm</button>
                            <button className="confirmationButton cancel" onClick={onCancel}>Cancel</button>
                        </div>
                    </div>
                </div>
            );
        };

        const AdminCampaignDetailsScreen = ({ showMessage, setActiveScreen, currentUser, selectedAdminCampaignId, setShowConfirmationModal, setConfirmationTitle, setConfirmationMessage, setOnConfirmationAction, creatorProfile }) => {
            const [campaign, setCampaign] = useState(null);
            const [loading, setLoading] = useState(true);
            const campaignImageRef = useRef(null);

            useEffect(() => {
                const fetchCampaignDetails = async () => {
                    if (!selectedAdminCampaignId) {
                        showMessage("No campaign selected for review.");
                        setActiveScreen('AdminDashboard');
                        return;
                    }

                    try {
                        const campaignDocRef = doc(db, `artifacts/${appId}/public/data/campaigns`, selectedAdminCampaignId);
                        const docSnap = await getDoc(campaignDocRef);

                        if (docSnap.exists()) {
                            setCampaign({ id: docSnap.id, ...docSnap.data() });
                        } else {
                            showMessage("Campaign not found.");
                            setActiveScreen('AdminDashboard');
                        }
                        setLoading(false);
                    } catch (error) {
                        console.error("Error fetching campaign details for admin review:", error);
                        showMessage("Failed to load campaign details for review. Please try again.");
                        setLoading(false);
                        setActiveScreen('AdminDashboard');
                    }
                };

                fetchCampaignDetails();
            }, [selectedAdminCampaignId, setActiveScreen, showMessage]);

               
            const confirmApprove = () => {
                // Check if current user is an authority and the campaign creator is an admin
                if (creatorProfile.role === 'authority' && campaign && campaign.creatorId) {
                    // Fetch the creator's role to check if they are an "admin"
                    // This is done via a separate getDoc call to respect Firestore rules that might prevent direct read of creator.role from request.resource
                    const creatorDocRef = doc(db, "creators", campaign.creatorId);
                    getDoc(creatorDocRef).then(docSnap => {
                        if (docSnap.exists() && docSnap.data().role === 'admin') {
                            showMessage("Authority users cannot approve campaigns created by Admin accounts.");
                            return;
                        } else {
                            setShowConfirmationModal(true);
                            setConfirmationTitle("Approve Campaign?");
                            setConfirmationMessage(`Are you sure you want to APPROVE campaign "${campaign.title}"?`);
                            setOnConfirmationAction(() => handleApproveCampaign);
                        }
                    }).catch(error => {
                        console.error("Error fetching creator role:", error);
                        showMessage("Could not verify campaign creator's role. Please try again.");
                    });
                } else {
                    setShowConfirmationModal(true);
                    setConfirmationTitle("Approve Campaign?");
                    setConfirmationMessage(`Are you sure you want to APPROVE campaign "${campaign.title}"?`);
                            setOnConfirmationAction(() => handleApproveCampaign);
                }
            };

            const handleApproveCampaign = async () => {
                setShowConfirmationModal(false); // Close modal
                if (!campaign || !currentUser) return;

                try {
                    const campaignDocRef = doc(db, `artifacts/${appId}/public/data/campaigns`, campaign.id);
                    await updateDoc(campaignDocRef, {
                        status: 'active',
                        approvedBy: currentUser.uid,
                        approvedAt: new Date().toISOString(),
                        updatedAt: new Date().toISOString()
                    });
                    showMessage(`Campaign "${campaign.title}" approved successfully!`);
                    setActiveScreen('AdminDashboard'); // Go back to dashboard
                } catch (error) {
                    console.error("Error approving campaign:", error);
                    showMessage(`Failed to approve campaign: ${error.message}`);
                }
            };

            const confirmReject = () => {
                // Check if current user is an authority and the campaign creator is an admin
                if (creatorProfile.role === 'authority' && campaign && campaign.creatorId) {
                    const creatorDocRef = doc(db, "creators", campaign.creatorId);
                    getDoc(creatorDocRef).then(docSnap => {
                        if (docSnap.exists() && docSnap.data().role === 'admin') {
                            showMessage("Authority users cannot reject campaigns created by Admin accounts.");
                            return;
                        } else {
                            setShowConfirmationModal(true);
                            setConfirmationTitle("Reject Campaign?");
                            setConfirmationMessage(`Are you sure you want to REJECT campaign "${campaign.title}"?`);
                            setOnConfirmationAction(() => handleRejectCampaign);
                        }
                    }).catch(error => {
                        console.error("Error fetching creator role:", error);
                        showMessage("Could not verify campaign creator's role. Please try again.");
                    });
                } else {
                    setShowConfirmationModal(true);
                    setConfirmationTitle("Reject Campaign?");
                    setConfirmationMessage(`Are you sure you want to REJECT campaign "${campaign.title}"?`);
                    setOnConfirmationAction(() => handleRejectCampaign);
                }
            };

            const handleRejectCampaign = async () => {
                setShowConfirmationModal(false); // Close modal
                if (!campaign || !currentUser) return;
            
                try {
                    // This function now ONLY updates the status. The backend trigger handles the notification.
                    const campaignDocRef = doc(db, `artifacts/${appId}/public/data/campaigns`, campaign.id);
                    await updateDoc(campaignDocRef, {
                        status: 'rejected',
                        rejectedBy: currentUser.uid,
                        rejectedAt: new Date().toISOString(),
                        updatedAt: new Date().toISOString()
                    });
            
                    showMessage(`Campaign "${campaign.title}" rejected. Creator will be notified.`);
                    setActiveScreen('AdminDashboard'); // Go back to dashboard
                } catch (error) {
                    console.error("Error rejecting campaign:", error);
                    showMessage(`Failed to reject campaign: ${error.message}`);
                }
            };
// END of REPLACEMENT Block

            const confirmEndCampaignByAdmin = () => {
                // Check if current user is an authority and the campaign creator is an admin
                if (creatorProfile.role === 'authority' && campaign && campaign.creatorId) {
                    const creatorDocRef = doc(db, "creators", campaign.creatorId);
                    getDoc(creatorDocRef).then(docSnap => {
                        if (docSnap.exists() && docSnap.data().role === 'admin') {
                            showMessage("Authority users cannot end campaigns created by Admin accounts.");
                            return;
                        } else {
                            setShowConfirmationModal(true);
                            setConfirmationTitle("End Campaign?");
                            setConfirmationMessage(`Are you sure you want to manually END campaign "${campaign.title}"? This will set its status to 'ended'.`);
                            setOnConfirmationAction(() => handleEndCampaignByAdmin);
                        }
                    }).catch(error => {
                        console.error("Error fetching creator role:", error);
                        showMessage("Could not verify campaign creator's role. Please try again.");
                    });
                } else {
                    setShowConfirmationModal(true);
                    setConfirmationTitle("End Campaign?");
                    setConfirmationMessage(`Are you sure you want to manually END campaign "${campaign.title}"? This will set its status to 'ended'.`);
                    setOnConfirmationAction(() => handleEndCampaignByAdmin);
                }
            };

            const handleEndCampaignByAdmin = async () => {
                setShowConfirmationModal(false); // Close modal
                if (!campaign || !currentUser) return;

                try {
                    const campaignDocRef = doc(db, `artifacts/${appId}/public/data/campaigns`, campaign.id);
                    await updateDoc(campaignDocRef, {
                    status: 'ended',
                    endedByAdmin: currentUser.uid,
                    endedAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString(),
                    statusChangedAt: new Date().toISOString() // <-- ADD THIS LINE
                });
                    showMessage(`Campaign "${campaign.title}" has been manually ended by admin.`);
                    setActiveScreen('AdminDashboard'); // Go back to dashboard after action
                } catch (error) {
                    console.error("Error ending campaign by admin:", error);
                    showMessage(`Failed to end campaign: ${error.message}`);
                }
            };

            if (loading) {
                return (
                    <div className="screenContainer" style={{ textAlign: 'center', paddingTop: '50px' }}>
                        <p className="heading">Loading Campaign Details for Review...</p>
                        <p className="subHeading" style={{ color: '#FFD700' }}>Please wait.</p>
                    </div>
                );
            }

            if (!campaign) {
                return null; // Should not happen if loading is false and campaignId is present
            }

            const createdDate = campaign.createdAt ? new Date(campaign.createdAt).toLocaleDateString() : 'N/A';
            const endDate = campaign.endDate ? new Date(campaign.endDate).toLocaleDateString() : 'N/A';

            return (
                <div className="screenContainer">
                    <p className="heading">Review Campaign</p>
                    <p className="subHeading">{campaign.title}</p>

                    <div className="dashboardSection">
                        <p className="dashboardSectionTitle">Campaign Details</p>
                        <div style={{ display: 'flex', alignItems: 'center', marginBottom: '15px' }}>
                            <img
                                src={campaign.creatorProfilePictureUrl || 'https://placehold.co/100x100/555/FFF?text=Profile'}
                                alt={campaign.creatorName}
                                style={{ width: '60px', height: '60px', borderRadius: '50%', objectFit: 'cover', marginRight: '15px', border: '2px solid #FFD700' }}
                                onError={(e) => { e.target.onerror = null; e.target.src='https://placehold.co/60x60/555/FFF?text=P'; }}
                            />
                            <div>
                                <p className="dashboardItem" style={{ marginBottom: '0' }}>**Creator:** {campaign.creatorName}</p>
                                <p className="dashboardItem" style={{ fontSize: '12px', color: '#AAA' }}>Creator ID: {campaign.creatorId}</p>
                            </div>
                        </div>

                        <p className="dashboardItem">**Description:** {campaign.description}</p>
                        <p className="dashboardItem">**Funding Goal:** ${campaign.goal}</p>
                        <p className="dashboardItem">**Current Raised:** ${campaign.raised}</p>
                        <p className="dashboardItem">**Status:** <span style={{ color: campaign.status === 'pending' ? '#FFD700' : (campaign.status === 'active' ? '#00FF00' : (campaign.status === 'cancelled' ? '#888' : '#DC3545')) }}>{campaign.status}</span></p>
                        <p className="dashboardItem">**Created On:** {createdDate}</p>
                        <p className="dashboardItem">**Ends On:** {endDate}</p>

                        {campaign.imageUrl && (
                            <div style={{ marginTop: '15px' }}>
                                <p className="formLabel">Project Image/Link:</p>
                                <img
                                    ref={campaignImageRef}
                                    src={campaign.imageUrl}
                                    alt="Campaign Project"
                                    style={{ width: '100%', maxWidth: '300px', height: 'auto', borderRadius: '8px', objectFit: 'contain', marginTop: '10px' }}
                                    onError={(e) => { e.target.style.display = 'none'; showMessage('Project image failed to load.'); }}
                                />
                                {/* --- START: MODIFIED PROJECT LINK BUTTON --- */}
                                {campaign.projectLink && (
                                    <button
                                        className="button"
                                        onClick={() => window.open(campaign.projectLink, '_blank')}
                                        style={{ backgroundColor: '#3A3A3A', marginTop: '10px', width: 'auto', alignSelf: 'flex-start', padding: '8px 15px', fontSize: '14px' }}
                                    >
                                        <span className="buttonText">Review Creator's Project Link</span>
                                    </button>
                                )}
                                {/* --- END: MODIFIED PROJECT LINK BUTTON --- */}
                            </div>
                        )}
                    </div>

                      <div style={{ display: 'flex', justifyContent: 'space-around', marginTop: '20px' }}>
                        {campaign.status === 'pending' && ( // Only show approve/reject for pending
                            <>
                                <button
                                    className="adminActionButton approve"
                                    onClick={confirmApprove}
                                >
                                    Approve Campaign
                                </button>
                                <button
                                    className="adminActionButton reject"
                                    onClick={confirmReject}
                                >
                                    Reject Campaign
                                </button>
                            </>
                        )}
                        {campaign.status === 'active' && ( // Show End button only for active campaigns
                            <button
                                className="adminActionButton"
                                onClick={confirmEndCampaignByAdmin}
                                style={{ backgroundColor: '#FF8C00' }} // Orange color for 'End Campaign'
                            >
                                End Campaign
                            </button>
                        )}
                    </div>

                    <button
                        className="button"
                        onClick={() => setActiveScreen('AdminDashboard')}
                        style={{ backgroundColor: '#0A0A0A', border: '1px solid #FFF', marginTop: '30px' }}
                    >
                        <span className="buttonText light">Back to Admin Dashboard</span>
                    </button>
                </div>
            );
        };


          // =========== START REPLACEMENT ===========
           const DonationPledgeScreen = ({ showMessage, setActiveScreen, currentUser, creatorProfile, pledgeContext, setPledgeIdForConfirmation }) => {
            const [amount, setAmount] = useState('');
            const [userName, setUserName] = useState((creatorProfile && creatorProfile.creatorName) ? creatorProfile.creatorName : (currentUser ? currentUser.email.split('@')[0] : ''));
            const [agreedToTerms, setAgreedToTerms] = useState(false);
            const [isSubmitting, setIsSubmitting] = useState(false);

            const handleSubmitPledge = async (e) => {
                e.preventDefault();
                if (!userName.trim()) { showMessage("Please enter your name."); return; }
                if (!agreedToTerms) { showMessage("You must agree to the terms."); return; }
                setIsSubmitting(true);
                
                const pledgeId = `NVA-${Date.now().toString().slice(-6).toUpperCase()}`;
                const pledgeAmount = parseFloat(amount);

                if (isNaN(pledgeAmount) || pledgeAmount <= 0) {
                    showMessage("Please enter a valid amount.");
                    setIsSubmitting(false);
                    return;
                }

                try {
                    const pledgeRef = doc(collection(db, "paymentPledges"), pledgeId);
                    await setDoc(pledgeRef, {
                        pledgeId, userId: currentUser.uid, userName, userEmail: currentUser.email,
                        paymentType: 'donation', amount: pledgeAmount, status: 'pending',
                        targetCampaignId: pledgeContext.campaignId, targetCampaignTitle: pledgeContext.campaignTitle,
                        targetCreatorName: pledgeContext.creatorName, createdAt: new Date().toISOString(),
                    });
                    setPledgeIdForConfirmation(pledgeId);
                    setActiveScreen('PendingConfirmation');
                } catch (error) {
                    showMessage(`An error occurred: ${error.message}`);
                    setIsSubmitting(false);
                }
            };
            
            return (
                <div className="screenContainer">
                    <p className="heading">Support a Campaign</p>
                    <p className="subHeading">{`You are donating to "${pledgeContext.campaignTitle}"`}</p>
                    <form onSubmit={handleSubmitPledge}>
                        <div className="formGroup">
                            <label htmlFor="pledgeName" className="formLabel">Your Name:</label>
                            <input type="text" id="pledgeName" className="formInput" value={userName} onChange={(e) => setUserName(e.target.value)} required />
                        </div>
                        <div className="formGroup">
                            <label htmlFor="donationAmount" className="formLabel">Donation Amount (USD):</label>
                            <input type="number" id="donationAmount" className="formInput" value={amount} onChange={(e) => setAmount(e.target.value)} required min="1" step="any" />
                        </div>
                        <div className="formGroup"><p className="termsText" style={{textAlign: 'left', color: '#CCC'}}>This is a manual payment process. You will be given instructions to complete your payment via MMG after submitting.<br/><br/><strong>A small platform fee (7%) helps NVA Network support creators.</strong></p></div>
                        <div className="formGroup"><div className="checkboxItem"><input type="checkbox" id="agreeToTerms" checked={agreedToTerms} onChange={(e) => setAgreedToTerms(e.target.checked)} required /><label htmlFor="agreeToTerms">I understand and agree to the payment terms.</label></div></div>
                        <button type="submit" className="button" disabled={isSubmitting}><span className="buttonText">{isSubmitting ? "Generating..." : "Submit Pledge & Get Payment Info"}</span></button>
                    </form>
                </div>
            );
        };
// =========== END REPLACEMENT ==========
       
        const SubscriptionPledgeScreen = ({ showMessage, setActiveScreen, currentUser, creatorProfile, pledgeContext, setPledgeIdForConfirmation }) => {
            const [userName, setUserName] = useState((creatorProfile && creatorProfile.creatorName) ? creatorProfile.creatorName : (currentUser ? currentUser.email.split('@')[0] : ''));
            const [agreedToTerms, setAgreedToTerms] = useState(false);
            const [isSubmitting, setIsSubmitting] = useState(false);
            const isTicket = pledgeContext.type === 'eventTicket';

            const handleSubmitPledge = async (e) => {
                e.preventDefault();
                if (!userName.trim()) { 
                    showMessage("Please enter your name."); 
                    return; 
                }
                if (!agreedToTerms) { 
                    showMessage("You must agree to the terms."); 
                    return; 
                }
                setIsSubmitting(true);
                
                const pledgeId = `NVA-${Date.now().toString().slice(-6).toUpperCase()}`;
                try {
                    const pledgeRef = doc(collection(db, "paymentPledges"), pledgeId);
                    await setDoc(pledgeRef, {
                        pledgeId, userId: currentUser.uid, userName, userEmail: currentUser.email,
                        paymentType: pledgeContext.type, amount: pledgeContext.amount, status: 'pending',
                        targetEventId: pledgeContext.targetEventId || null, targetEventTitle: pledgeContext.targetEventTitle || null,
                        createdAt: new Date().toISOString(),
                    });
                    setPledgeIdForConfirmation(pledgeId);
                    setActiveScreen('PendingConfirmation');
                } catch (error) {
                    showMessage(`An error occurred: ${error.message}`);
                    setIsSubmitting(false);
                }
            };
            
            return (
                <div className="screenContainer">
                    <p className="heading">{isTicket ? "Purchase Event Ticket" : "Get NVA Premium"}</p>
                    <p className="subHeading">{isTicket ? `Ticket for: "${pledgeContext.targetEventTitle}"` : "Unlock exclusive content and an ad-free experience."}</p>
                    <form onSubmit={handleSubmitPledge}>
                        <div className="formGroup">
                            <label htmlFor="pledgeName" className="formLabel">Your Name:</label>
                            <input type="text" id="pledgeName" className="formInput" value={userName} onChange={(e) => setUserName(e.target.value)} required />
                        </div>
                        <div className="premiumFeatureCard">
                            <p className="premiumFeatureTitle" style={{textAlign: 'center'}}>{isTicket ? 'Event Ticket' : 'Premium Subscription'}</p>
                            <p className="premiumFeatureDescription" style={{fontSize: '24px', fontWeight: 'bold', textAlign: 'center', color: '#FFF'}}>${parseFloat(pledgeContext.amount).toFixed(2)} USD</p>
                            <p className="premiumFeatureDescription" style={{textAlign: 'center'}}>{isTicket ? 'one-time purchase' : 'per month'}</p>
                        </div>
                        <div className="formGroup"><p className="termsText" style={{textAlign: 'left', color: '#CCC'}}>This is a manual payment process. You will be given instructions to complete your payment via MMG after submitting.</p></div>
                        <div className="formGroup"><div className="checkboxItem"><input type="checkbox" id="agreeToTerms" checked={agreedToTerms} onChange={(e) => setAgreedToTerms(e.target.checked)} required /><label htmlFor="agreeToTerms">I understand and agree to the payment terms.</label></div></div>
                        <button type="submit" className="button" disabled={isSubmitting}><span className="buttonText">{isSubmitting ? "Generating..." : "Submit Pledge & Get Payment Info"}</span></button>
                    </form>
                    <button className="button" onClick={() => setActiveScreen('Premium')} style={{ backgroundColor: '#3A3A3A', marginTop: '20px' }}>
                        <span className="buttonText">Back</span>
                    </button>
                </div>
            );
        };
// =========== END REPLACEMENT ===========

                // =========== ADD THE FOLLOWING CODE BLOCK ===========
        const PendingConfirmationScreen = ({ showMessage, setActiveScreen, pledgeId, currentUser }) => {
            const [pledgeDetails, setPledgeDetails] = useState(null);
            const [isLoading, setIsLoading] = useState(true);
            const [mmgNumber, setMmgNumber] = useState(''); // State variable is now correctly declared here

            useEffect(() => {
                if (!pledgeId) {
                    setActiveScreen('Home');
                    return () => {};
                }

                // Fetch the site-wide settings first to get the MMG number
                const settingsRef = doc(db, "settings", "socialLinks");
                getDoc(settingsRef).then(settingsSnap => {
                    if (settingsSnap.exists()) {
                        setMmgNumber(settingsSnap.data().mmgNumber || 'Admin Not Set');
                    }
                });

                // Set up the listener for the specific pledge
                const pledgeRef = doc(db, "paymentPledges", pledgeId);
                const unsubscribe = onSnapshot(pledgeRef, (docSnap) => {
                    if (docSnap.exists()) {
                        const data = docSnap.data();
                        setPledgeDetails(data);
                        setIsLoading(false);
                        if (data.status === 'approved') {
                            showMessage("Payment confirmed successfully!");
                            unsubscribe();
                            setTimeout(() => setActiveScreen('Home'), 3000);
                        } else if (data.status === 'denied') {
                            showMessage("Your payment pledge was denied.");
                            unsubscribe();
                            setTimeout(() => setActiveScreen('Home'), 3000);
                        }
                    } else {
                        showMessage("This payment pledge is no longer valid.");
                        unsubscribe();
                        setActiveScreen('Home');
                    }
                });

                return () => unsubscribe();
            }, [pledgeId]);

            const renderPledgeSummary = () => {
                if (!pledgeDetails) return null;
                switch (pledgeDetails.paymentType) {
                    case 'donation': return `Donation for "${pledgeDetails.targetCampaignTitle}"`;
                    case 'premium': return `NVA Premium Subscription`;
                    case 'eventTicket': return `Event Ticket for "${pledgeDetails.targetEventTitle}"`;
                    default: return 'Your Pledge';
                }
            };

            if (isLoading) {
                return <div className="screenContainer"><p className="heading">Generating Your Payment Details...</p></div>;
            }
            
            if (pledgeDetails.status === 'approved') {
                return (
                    <div className="screenContainer" style={{textAlign: 'center'}}>
                        <p className="heading" style={{color: '#00FF00'}}>Payment Confirmed!</p>
                        <p className="subHeading">Thank you for your support. Redirecting you home...</p>
                    </div>
                );
            }

            return (
                <div className="screenContainer">
                    <p className="heading">Complete Your Payment</p>
                    <p className="subHeading" style={{color: '#FFD700'}}>Action Required</p>
                    
                    <div className="premiumFeatureCard" style={{textAlign: 'center'}}>
                        <p className="premiumFeatureDescription" style={{marginBottom: '5px'}}>Please send exactly:</p>
                        <p className="premiumFeatureTitle" style={{fontSize: '32px', color: '#FFF'}}>${pledgeDetails.amount.toFixed(2)} USD</p>
                        <p className="premiumFeatureDescription" style={{marginTop: '10px'}}>To our MMG account along with screenshot of your confirmed Payment Receipt:</p>
                        <p className="premiumFeatureTitle" style={{fontSize: '24px'}}>{mmgNumber || 'Contact Admin for Payment Info'}</p>
                    </div>

                    <div className="dashboardSection" style={{marginTop: '20px'}}>
                        <p className="dashboardSectionTitle">Crucial Final Step:</p>
                        <p className="paragraph">
                            In the MMG Enter Description Field you **MUST** include the following Pledge ID.
                            Failure to do so will result in your payment not being processed.
                        </p>
                        <p className="heading" style={{fontSize: '28px', backgroundColor: '#0A0A0A', padding: '10px', borderRadius: '8px', border: '1px solid #FFD700', userSelect: 'all'}}>
                            {pledgeId}
                        </p>
                    </div>

                    <p className="paragraph" style={{textAlign: 'center', marginTop: '20px'}}>This screen is listening for updates. Once we manually verify your MMG transaction, this screen will automatically confirm it.</p>
                     <p className="smallText">You can safely navigate away and come back later if needed.</p>

                    <button className="button" onClick={() => setActiveScreen('Home')} style={{backgroundColor: '#3A3A0A', marginTop: '10px'}}>
                        <span className="buttonText">I have paid. Back to Home</span>
                    </button>
                </div>
            );
        };
// END of REPLACEMENT Block

                    // --- START: NEW COMPONENT ---
        const AddExternalAdModal = ({ showMessage, onSave, onCancel }) => {
            const [title, setTitle] = useState('');
            const [destinationUrl, setDestinationUrl] = useState('');
            const [imageFile, setImageFile] = useState(null);
            const [imagePreview, setImagePreview] = useState('');
            const [isUploading, setIsUploading] = useState(false);
            const fileInputRef = useRef(null);

            useEffect(() => {
                if (imageFile) return;
                if (!destinationUrl) {
                    setImagePreview('');
                    return;
                }
                const videoInfo = extractVideoInfo(destinationUrl);
                if (videoInfo && videoInfo.thumbnailUrl) {
                    setImagePreview(videoInfo.thumbnailUrl);
                } else {
                    setImagePreview(destinationUrl);
                }
            }, [destinationUrl, imageFile]);

            const handleFileChange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    setImageFile(file);
                    setImagePreview(URL.createObjectURL(file));
                }
            };

            const handleSave = async () => {
                if (!title || !destinationUrl) {
                    showMessage("A Title and Destination URL are required.");
                    return;
                }

                // If a custom file was uploaded, handle that path first.
                if (imageFile) {
                    setIsUploading(true);
                    showMessage("Uploading custom image...");
                    try {
                        const filePath = `external_ads/${Date.now()}_${imageFile.name}`;
                        const storageRef = ref(storage, filePath);
                        const snapshot = await uploadBytes(storageRef, imageFile);
                        const finalImageUrl = await getDownloadURL(snapshot.ref);
                        showMessage("Image uploaded successfully!");
                        
                        // --- CRITICAL FIX: onSave is called *inside* the successful async block ---
                        onSave({
                            type: 'external',
                            title,
                            externalLink: destinationUrl,
                            imageUrl: finalImageUrl,
                            orderIndex: Date.now()
                        });
                        setIsUploading(false);
                        onCancel(); // Close the modal

                    } catch (error) {
                        showMessage(`Image upload failed: ${error.message}`);
                        setIsUploading(false);
                    }
                } else {
                    // This is the path for URL-based images
                    if (!imagePreview) {
                        showMessage("Could not find a valid image preview. Please upload one.");
                        return;
                    }
                    onSave({
                        type: 'external',
                        title,
                        externalLink: destinationUrl,
                        imageUrl: imagePreview,
                        orderIndex: Date.now()
                    });
                    onCancel(); // Close the modal
                }
            };

            return (
                <div className="confirmationModalOverlay" style={{ zIndex: 3000 }}>
                    <div className="confirmationModalContent" style={{ textAlign: 'left', maxWidth: '500px' }}>
                        <p className="confirmationModalTitle">Add External Ad/Promotion</p>
                        <div className="formGroup">
                            <label className="formLabel">Ad Title:</label>
                            <input type="text" className="formInput" value={title} onChange={(e) => setTitle(e.target.value)} placeholder="e.g., Monster Energy Deal" required/>
                        </div>
                        <div className="formGroup">
                            <label className="formLabel">Destination URL:</label>
                            <input type="url" className="formInput" value={destinationUrl} onChange={(e) => { setDestinationUrl(e.target.value); setImageFile(null); }} placeholder="https://www.sponsor.com/deal" required/>
                            <p className="smallText" style={{textAlign: 'left', color: '#AAA', marginTop: '5px'}}>The app will try to fetch a preview from this link.</p>
                        </div>
                        <hr style={{borderColor: '#333', margin: '15px 0'}}/>
                        <div className="formGroup">
                            <label className="formLabel">Upload Custom Image (Overrides Preview):</label>
                            <input type="file" ref={fileInputRef} onChange={handleFileChange} accept="image/*" style={{ display: 'none' }} />
                            <button type="button" className="button" onClick={() => fileInputRef.current.click()} style={{ width: '100%', backgroundColor: '#3A3A3A' }}>
                                <span className="buttonText">Choose Image File</span>
                            </button>
                            {imagePreview && (
                                <div style={{marginTop: '15px'}}>
                                    <p className="formLabel">Final Preview:</p>
                                    <img src={imagePreview} alt="Preview" style={{ maxWidth: '200px', borderRadius: '8px', marginTop: '5px' }} onError={(e) => { e.target.onerror = null; e.target.src='https://placehold.co/200x120/555/FFF?text=No+Preview'; }} />
                                </div>
                            )}
                        </div>
                        <div className="confirmationModalButtons">
                            <button className="confirmationButton cancel" onClick={onCancel}>Cancel</button>
                            <button className="confirmationButton confirm" onClick={handleSave} disabled={isUploading}>
                                {isUploading ? 'Uploading...' : 'Save Ad'}
                            </button>
                        </div>
                    </div>
                </div>
            );
        };
        // --- END: NEW COMPONENT ---

        // --- START: NEW COMPONENT ---
        const AdminCurationModal = ({ curationTarget, showMessage, onCancel, contentItems }) => {
            const [curatedItems, setCuratedItems] = useState([]);
            const [loading, setLoading] = useState(true);
            const [isSaving, setIsSaving] = useState(false);
            const [showContentSelector, setShowContentSelector] = useState(false);
            const [showExternalAdModal, setShowExternalAdModal] = useState(false);

            const targetField = `${curationTarget.toLowerCase().replace(' ', '')}Items`;

            useEffect(() => {
                const fetchInitialData = async () => {
                    setLoading(true);
                    const layoutDocRef = doc(db, "settings", "homeScreenLayout");
                    try {
                        const docSnap = await getDoc(layoutDocRef);
                        if (docSnap.exists()) {
                            const layoutData = docSnap.data();
                            const itemsFromDB = layoutData[targetField] || [];
                            
                            const enrichedItems = itemsFromDB.map(item => {
                                if (item.type === 'internal') {
                                    const fullContent = contentItems.find(ci => ci.id === item.contentId);
                                    return fullContent ? { ...item, ...fullContent } : null;
                                }
                                return item;
                            }).filter(Boolean); // Filter out nulls for deleted content
                            setCuratedItems(enrichedItems);
                        } else {
                            setCuratedItems([]);
                        }
                    } catch (error) {
                        showMessage("Error fetching curation data: " + error.message);
                        setCuratedItems([]);
                    } finally {
                        setLoading(false);
                    }
                };
                
                fetchInitialData();
            }, [curationTarget]); // This hook now only re-runs if the target section changes

            const handleMove = (index, direction) => {
                const newItems = [...curatedItems];
                const item = newItems[index];
                const newIndex = index + direction;
                if (newIndex < 0 || newIndex >= newItems.length) return;
                newItems.splice(index, 1);
                newItems.splice(newIndex, 0, item);
                setCuratedItems(newItems);
            };

            const handleRemove = (index) => {
                const newItems = [...curatedItems];
                newItems.splice(index, 1);
                setCuratedItems(newItems);
            };

            const handleSelectInternalContent = (selectedContent) => {
                const isAlreadyInList = curatedItems.some(item => item.type === 'internal' && item.contentId === selectedContent.id);
                if (isAlreadyInList) {
                    showMessage("This content is already in the list.");
                    return;
                }
                const newItem = {
                    type: 'internal',
                    contentId: selectedContent.id,
                    orderIndex: curatedItems.length
                };
                setCuratedItems(prev => [...prev, { ...newItem, ...selectedContent }]);
                setShowContentSelector(false);
            };
            
            const handleSaveExternalAd = (newAd) => {
                 setCuratedItems(prev => [...prev, newAd]);
                 setShowExternalAdModal(false);
            };

            const handleSaveChanges = async () => {
                setIsSaving(true);
                showMessage("Saving changes...");
                
                const itemsToSave = curatedItems.map((item, index) => {
                    const baseItem = {
                        type: item.type,
                        orderIndex: index
                    };
                    if (item.type === 'internal') {
                        baseItem.contentId = item.contentId;
                    } else {
                        baseItem.title = item.title;
                        baseItem.imageUrl = item.imageUrl;
                        baseItem.externalLink = item.externalLink;
                    }
                    return baseItem;
                });

                try {
                    const layoutDocRef = doc(db, "settings", "homeScreenLayout");
                    await setDoc(layoutDocRef, { [targetField]: itemsToSave }, { merge: true });
                    showMessage("Curation saved successfully!");
                    onCancel();
                } catch (error) {
                    showMessage(`Error saving: ${error.message}`);
                } finally {
                    setIsSaving(false);
                }
            };

            return (
                <div className="confirmationModalOverlay" style={{ zIndex: 2500 }}>
                    <div className="confirmationModalContent" style={{ maxWidth: '700px', textAlign: 'left' }}>
                        <p className="confirmationModalTitle">Manage {curationTarget} Section</p>
                        
                        <div className="dashboardContentList" style={{ maxHeight: '40vh', overflowY: 'auto', marginBottom: '20px' }}>
                            {loading ? <p>Loading...</p> : (
                                curatedItems.length === 0 ? <p className="dashboardItem">This section is empty.</p> :
                                curatedItems.map((item, index) => (
                                    <div key={item.id || item.title + index} className="adminDashboardItem">
                                        <img src={item.customThumbnailUrl || item.imageUrl} style={{width: '80px', height: '45px', objectFit: 'cover', borderRadius: '4px'}}/>
                                        <div style={{flexGrow: 1, marginLeft: '10px'}}>
                                            <p className="adminDashboardItemTitle">{item.title}</p>
                                            <p style={{fontSize: '12px', color: '#AAA'}}>{item.type === 'internal' ? `by ${item.creatorName || '...loading'}` : 'External Ad'}</p>
                                        </div>
                                        <div style={{display: 'flex', gap: '5px'}}>
                                            <button onClick={() => handleMove(index, -1)} disabled={index === 0} className="adminActionButton" style={{width: '30px'}}></button>
                                            <button onClick={() => handleMove(index, 1)} disabled={index === curatedItems.length - 1} className="adminActionButton" style={{width: '30px'}}></button>
                                            <button onClick={() => handleRemove(index)} className="adminActionButton reject">Remove</button>
                                        </div>
                                    </div>
                                ))
                            )}
                        </div>

                        <div className="flex justify-around gap-4 my-4">
                            <button className="button" onClick={() => setShowContentSelector(true)}>
                                <span className="buttonText">Add from Library</span>
                            </button>
                             <button className="button" onClick={() => setShowExternalAdModal(true)}>
                                <span className="buttonText">Add External Ad</span>
                            </button>
                        </div>

                        <div className="confirmationModalButtons">
                            <button className="confirmationButton cancel" onClick={onCancel}>Cancel</button>
                            <button className="confirmationButton confirm" onClick={handleSaveChanges} disabled={isSaving}>
                                {isSaving ? 'Saving...' : 'Save Changes'}
                            </button>
                        </div>

                        {showContentSelector && <ContentSelectorModal showMessage={showMessage} onSelect={handleSelectInternalContent} onCancel={() => setShowContentSelector(false)} />}
                        {showExternalAdModal && <AddExternalAdModal showMessage={showMessage} onSave={handleSaveExternalAd} onCancel={() => setShowExternalAdModal(false)} />}
                    </div>
                </div>
            );
        };
        // --- END: NEW COMPONENT ---

const AdminFeaturedContentManager = ({ featuredContentSlots, showMessage }) => {
    const [showModal, setShowModal] = useState(false);
    const [editingSlot, setEditingSlot] = useState(null);
    const [isSaving, setIsSaving] = useState(null);

    const handleUnlock = async (slotKey) => {
    setIsSaving(slotKey);
    showMessage("Unlocking and recalculating slot...");
    try {
        const slotNumber = parseInt(slotKey.split('_')[1], 10);
        
        // 1. Get the current leaderboard
        const leaderboardDocRef = doc(db, "leaderboard", "topPerformers");
        const leaderboardDoc = await getDoc(leaderboardDocRef);
        if (!leaderboardDoc.exists() || !leaderboardDoc.data().creators) {
            throw new Error("Leaderboard data not found.");
        }
        const topCreators = leaderboardDoc.data().creators;
        const targetCreator = topCreators[slotNumber - 1];

        let newContent = null;
        if (targetCreator) {
            // 2. Find the best weekly content for that creator
            const contentQuery = query(
                collection(db, `artifacts/${appId}/public/data/content_items`), 
                where('creatorId', '==', targetCreator.id),
                where('isActive', '==', true),
                orderBy('createdAt', 'desc'),
                limit(20)
            );
            const contentSnapshot = await getDocs(contentQuery);
            let bestScore = -1;
            
            contentSnapshot.forEach(docSnap => {
                const content = docSnap.data();
                const score = (content.viewCount || 0) + ((content.likeCount || 0) * 5);
                if (score > bestScore) {
                    bestScore = score;
                    newContent = {id: docSnap.id, ...content};
                }
            });
        }
        
        // 3. Update the slot with the new content and unlock it
        const slotsDocRef = doc(db, "settings", "featuredContentSlots");
        await updateDoc(slotsDocRef, {
            [`${slotKey}.isLocked`]: false,
            [`${slotKey}.content`]: newContent
        });

        showMessage(`Slot #${slotNumber} unlocked and reverted to automatic selection.`);

    } catch (error) {
        showMessage("Error unlocking slot: " + error.message);
        console.error("Unlock error:", error);
    } finally {
        setIsSaving(null);
    }
};

    const handleSelectContent = async (selectedContent) => {
        if (!editingSlot) return;
        setIsSaving(editingSlot);
        setShowModal(false);
        try {
            const slotsDocRef = doc(db, "settings", "featuredContentSlots");
            await updateDoc(slotsDocRef, {
                [`${editingSlot}.content`]: selectedContent,
                [`${editingSlot}.isLocked`]: true
            });
            showMessage(`Slot #${editingSlot.split('_')[1]} has been manually updated.`);
        } catch (error) {
            showMessage("Error updating slot: " + error.message);
        } finally {
            setIsSaving(null);
            setEditingSlot(null);
        }
    };

    const slots = featuredContentSlots ? [
        { key: 'slot_1', data: featuredContentSlots.slot_1 },
        { key: 'slot_2', data: featuredContentSlots.slot_2 },
        { key: 'slot_3', data: featuredContentSlots.slot_3 }
    ] : [];

    return (
        <div className="dashboardSection" style={{border: '2px solid #FFD700'}}>
            <p className="dashboardSectionTitle">Top Creators Content Slots</p>
            <p className="dashboardItem" style={{color: '#AAA', marginBottom: '15px'}}>Manually override the content featured on the "Top Creators" screen.</p>
            
            <div className="dashboardContentList">
                {slots.map((slot, index) => (
                    <div key={slot.key} className="adminDashboardItem" style={{flexDirection: 'column', alignItems: 'flex-start', gap: '10px'}}>
                        <p className="adminDashboardItemTitle">Slot #{index + 1} <span style={{fontSize: '12px', color: slot.data?.isLocked ? '#00FF00' : '#FFD700'}}>({slot.data?.isLocked ? 'Locked' : 'Automatic'})</span></p>
                       <div style={{display: 'flex', width: '100%', alignItems: 'center', gap: '10px'}}>
    {/* This part now ONLY renders the content details, or a message if empty */}
    <div style={{flexGrow: 1, display: 'flex', alignItems: 'center', gap: '10px'}}>
        {slot.data?.content ? (
            <>
                <img src={slot.data.content.customThumbnailUrl} style={{width: '80px', height: '45px', objectFit: 'cover', borderRadius: '4px'}}/>
                <div>
                    <p style={{fontWeight: 'bold'}}>{slot.data.content.title}</p>
                    <p style={{fontSize: '12px', color: '#CCC'}}>by {slot.data.content.creatorName}</p>
                </div>
            </>
        ) : <p className="dashboardItem">This slot is currently empty.</p>}
    </div>
    
    {/* This part now ONLY renders the buttons, which are always visible */}
    <div style={{display: 'flex', gap: '10px'}}>
        {isSaving === slot.key ? <p>Saving...</p> : <>
            {slot.data?.isLocked && <button className="adminActionButton" onClick={() => handleUnlock(slot.key)}>Unlock</button>}
            <button className="adminActionButton approve" onClick={() => { setEditingSlot(slot.key); setShowModal(true); }}>Change</button>
        </>}
    </div>
</div>
                    </div>
                ))}
            </div>

            {showModal && <ContentSelectorModal onSelect={handleSelectContent} onCancel={() => setShowModal(false)} showMessage={showMessage} />}
        </div>
    );
};


const AdminContentManagerScreen = ({
    showMessage,
    setActiveScreen,
    currentUser,
    featuredContentSlots,
    creatorProfile,
    setShowConfirmationModal,
    setConfirmationTitle,
    setConfirmationMessage,
    setOnConfirmationAction
}) => {
    const [contentItems, setContentItems] = useState([]);
    const [loading, setLoading] = useState(true);
    const [isContentListExpanded, setIsContentListExpanded] = useState(true); // <-- THIS LINE IS THE FIX

    const [title, setTitle] = useState('');
    const [mainUrl, setMainUrl] = useState('');
    const [customThumbnailFile, setCustomThumbnailFile] = useState(null);
    const [customThumbnailUrlPreview, setCustomThumbnailUrlPreview] = useState('');
    const [autoThumbnailPreview, setAutoThumbnailPreview] = useState('');
    const [creatorName, setCreatorName] = useState('');
    const [contentType, setContentType] = useState('Skits');
    const [orderIndex, setOrderIndex] = useState(0);
    const [isActive, setIsActive] = useState(true);
    const [description, setDescription] = useState('');

    const thumbnailFileInputRef = useRef(null);
    
    const [availableCategories, setAvailableCategories] = useState([]);
    
    const [showCurationModal, setShowCurationModal] = useState(false);
    const [curationTarget, setCurationTarget] = useState('');

    const openCurationModal = (target) => {
        setCurationTarget(target);
        setShowCurationModal(true);
    };

            useEffect(() => {
            const categoriesRef = collection(db, "content_categories");
            const systemCategories = ['Featured', 'Trending']; 

            const q = query(
                categoriesRef, 
                where("isActive", "==", true), 
                orderBy("orderIndex", "asc")
            );
            
            const unsubscribe = onSnapshot(q, (snapshot) => {
                const fetchedCategories = snapshot.docs
                    .map(doc => doc.data().name)
                    .filter(name => !systemCategories.includes(name));
                
                const finalCategories = [...fetchedCategories, 'Live Feed'];
                
                setAvailableCategories(finalCategories);
            });
            
            return () => unsubscribe();
        }, []);

    useEffect(() => {
        if (availableCategories.length > 0 && !availableCategories.includes(contentType)) {
            setContentType(availableCategories[0]);
        }
    }, [availableCategories]);

    useEffect(() => {
        if (creatorProfile) {
            if (creatorProfile.role === 'authority') {
                setCreatorName(creatorProfile.creatorName || currentUser.email);
            } else {
                setCreatorName('');
            }
        }
    }, [creatorProfile]);

    useEffect(() => {
        if (!mainUrl) {
            setAutoThumbnailPreview('');
            return;
        }
        const handler = setTimeout(() => {
            const { thumbnailUrl } = extractVideoInfo(mainUrl);
            if (thumbnailUrl) {
                setAutoThumbnailPreview(thumbnailUrl);
            } else {
                setAutoThumbnailPreview('');
            }
        }, 800);

        return () => clearTimeout(handler);
    }, [mainUrl]);

    useEffect(() => {
        const contentCollectionRef = collection(db, `artifacts/${appId}/public/data/content_items`);
        const q = query(contentCollectionRef, orderBy('orderIndex', 'asc'), orderBy('createdAt', 'desc'));

        const unsubscribe = onSnapshot(q, (snapshot) => {
            const fetchedItems = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            setContentItems(fetchedItems);
            setLoading(false);
        }, (error) => {
            console.error("Error fetching content items for admin:", error);
            showMessage("Failed to load content items.");
            setLoading(false);
        });

        return () => unsubscribe();
    }, [showMessage]);

    const resetForm = () => {
        setTitle('');
        setMainUrl('');
        setCustomThumbnailFile(null);
        setCustomThumbnailUrlPreview('');
        setAutoThumbnailPreview('');
        if (creatorProfile && creatorProfile.role === 'authority') {
            setCreatorName(creatorProfile.creatorName || '');
        } else {
            setCreatorName('');
        }
        setContentType('Skits');
        setOrderIndex(0);
        setIsActive(true);
        setDescription('');
        if (thumbnailFileInputRef.current) {
            thumbnailFileInputRef.current.value = '';
        }
    };

    const handleAddContent = async (e) => {
        e.preventDefault();
        if (!title || !mainUrl || !creatorName || !contentType) {
            showMessage('Please fill in all required fields.');
            return;
        }
        if (!currentUser || (creatorProfile.role !== 'admin' && creatorProfile.role !== 'authority')) {
            showMessage("You don't have permission to add content.");
            return;
        }
        let finalThumbnailUrl = '';
        let embedUrl = '';
        let videoPlatform = 'generic';
        const { thumbnailUrl, embedUrl: extractedEmbedUrl, platform: extractedPlatform } = extractVideoInfo(mainUrl);
        if (extractedEmbedUrl) {
            embedUrl = extractedEmbedUrl;
            videoPlatform = extractedPlatform;
            finalThumbnailUrl = thumbnailUrl;
        } else {
            finalThumbnailUrl = 'https://placehold.co/150x100/3A3A3A/FFF?text=Generic+Link';
        }
        if (customThumbnailFile) {
            showMessage('Uploading custom thumbnail...');
            try {
                const fileName = `content_thumbnails/${currentUser.uid}_${Date.now()}_${customThumbnailFile.name}`;
                const storageRefPath = ref(storage, fileName);
                await uploadBytes(storageRefPath, customThumbnailFile);
                finalThumbnailUrl = await getDownloadURL(storageRefPath);
                showMessage('Custom thumbnail uploaded successfully!');
            } catch (error) {
                console.error("Error uploading custom thumbnail:", error);
                showMessage(`Failed to upload custom thumbnail: ${error.message}`);
                return;
            }
        }
        try {
            await addDoc(collection(db, `artifacts/${appId}/public/data/content_items`), {
                title, 
                description, 
                mainUrl, 
                customThumbnailUrl: finalThumbnailUrl, 
                embedUrl, 
                videoPlatform,
                creatorId: currentUser.uid,
                creatorName, 
                contentType, 
                orderIndex: parseInt(orderIndex), 
                isActive, 
                createdAt: new Date().toISOString(), 
                createdBy: currentUser.uid, 
                createdByName: creatorProfile.creatorName || currentUser.email,
            });
            showMessage('Content item added successfully!');
            resetForm();
        } catch (error) {
            console.error("Error adding content item:", error);
            showMessage(`Failed to add content item: ${error.message}`);
        }
    };

    const deleteContentLogic = async (id, titleToDelete) => {
        if (!currentUser || (creatorProfile.role !== 'admin' && creatorProfile.role !== 'authority')) {
            showMessage("You don't have permission to delete content.");
            return;
        }
        try {
            await deleteDoc(doc(db, `artifacts/${appId}/public/data/content_items`, id));
            showMessage(`Content item "${titleToDelete}" deleted successfully.`);
        } catch (error) {
            console.error("Error deleting content item:", error);
            showMessage(`Failed to delete content item: ${error.message}`);
        }
    };
    
    const confirmDeleteContent = (id, titleToDelete) => {
        setConfirmationTitle("Delete Content?");
        setConfirmationMessage(`Are you sure you want to permanently delete "${titleToDelete}"? This action cannot be undone.`);
        setOnConfirmationAction(() => () => deleteContentLogic(id, titleToDelete));
        setShowConfirmationModal(true);
    };

    const handleToggleActive = async (item) => {
        if (!currentUser || (creatorProfile.role !== 'admin' && creatorProfile.role !== 'authority')) { showMessage("You don't have permission to modify content status."); return; }
        try {
            await updateDoc(doc(db, `artifacts/${appId}/public/data/content_items`, item.id), {
                isActive: !item.isActive, updatedAt: new Date().toISOString(), updatedBy: currentUser.uid
            });
            showMessage(`Content item "${item.title}" status changed to ${!item.isActive ? 'Active' : 'Inactive'}.`);
        } catch (error) {
            console.error("Error toggling content active status:", error);
            showMessage(`Failed to toggle content status: ${error.message}`);
        }
    };

    if (!currentUser || (creatorProfile.role !== 'admin' && creatorProfile.role !== 'authority')) {
        return (
            <div className="screenContainer">
                <p className="heading">Access Denied</p>
                <p className="subHeading">You must be an Admin or Authority to manage content.</p>
                <button className="button" onClick={() => setActiveScreen('AdminDashboard')}><span className="buttonText">Back to Admin Dashboard</span></button>
            </div>
        );
    }
    
    const currentPreview = customThumbnailUrlPreview || autoThumbnailPreview;

    return (
        <div className="screenContainer">
            <p className="heading">Manage Content</p>
            <p className="subHeading">Curate the home screen and add new videos to the content library.</p>
            
            <AdminFeaturedContentManager featuredContentSlots={featuredContentSlots} showMessage={showMessage} />

            <div className="dashboardSection" style={{marginTop: '30px', border: '1px solid #00FF00'}}>
                <p className="dashboardSectionTitle">Home Screen Curation</p>
                <p className="dashboardItem" style={{color: '#AAA', marginBottom: '15px'}}>
                    Manually add, remove, and reorder content for the main sections on the Home screen.
                </p>
                <div style={{display: 'flex', justifyContent: 'space-around', gap: '10px', marginTop: '15px'}}>
                    <button type="button" className="button" onClick={() => openCurationModal('Featured')} style={{margin: 0}}>
                        <span className="buttonText">Manage Featured</span>
                    </button>
                    <button type="button" className="button" onClick={() => openCurationModal('Trending')} style={{margin: 0}}>
                        <span className="buttonText">Manage Trending</span>
                    </button>
                </div>
            </div>

            <div className="dashboardSection">
                <p className="dashboardSectionTitle">Add New Content to Library</p>
                <form onSubmit={handleAddContent}>
                    <div className="formGroup"><label htmlFor="contentTitle" className="formLabel">Title:</label><input type="text" id="contentTitle" className="formInput" value={title} onChange={(e) => setTitle(e.target.value)} required /></div>
                    <div className="formGroup"><label htmlFor="contentDescription" className="formLabel">Description:</label><textarea id="contentDescription" className="formTextarea" value={description} onChange={(e) => setDescription(e.target.value)} placeholder="Brief description for the content item"></textarea></div>
                    <div className="formGroup"><label htmlFor="mainUrl" className="formLabel">Main Content URL (Video/Project Link):</label><input type="url" id="mainUrl" className="formInput" value={mainUrl} onChange={(e) => setMainUrl(e.target.value)} placeholder="e.g., YouTube link, Facebook video" required /><p className="smallText" 
                    style={{textAlign: 'left', marginTop: '5px', color: '#AAA'}}>We'll try to extract a thumbnail from this link.</p></div>
                    {currentPreview && (
                        <div style={{ marginTop: '10px' }}>
                            <p className="formLabel" style={{marginBottom: '5px'}}>Thumbnail Preview:</p>
                            <img src={currentPreview} alt="Thumbnail Preview" style={{ maxWidth: '150px', borderRadius: '8px', border: '2px solid #FFD700' }} />
                        </div>
                    )}
                    <div className="formGroup"><label htmlFor="customThumbnailFile" className="formLabel">Custom Thumbnail Image (Optional):</label><input type="file" id="customThumbnailFile" ref={thumbnailFileInputRef} className="formInput" onChange={(e) => { const file = e.target.files[0]; setCustomThumbnailFile(file); if (file) { setCustomThumbnailUrlPreview(URL.createObjectURL(file)); } else { setCustomThumbnailUrlPreview(''); } }} accept="image/*" style={{padding: '10px 0', border: 'none', backgroundColor: 'transparent'}} /><p className="smallText" style={{textAlign: 'left', marginTop: '5px', color: '#AAA'}}>Upload an image to override the thumbnail from the video link.</p></div>
                    <div className="formGroup">
                        <label htmlFor="creatorName" className="formLabel">Creator Name:</label>
                        <input
                            type="text"
                            id="creatorName"
                            className="formInput"
                            value={creatorName}
                            onChange={(e) => setCreatorName(e.target.value)}
                            required
                            disabled={creatorProfile && creatorProfile.role === 'authority'}
                            style={creatorProfile && creatorProfile.role === 'authority' ? { backgroundColor: '#2A2A2A', cursor: 'not-allowed' } : {}}
                        />
                    </div>
                    <div className="formGroup">
                        <label htmlFor="contentType" className="formLabel">Content Type:</label>
                        <select id="contentType" className="formInput" value={contentType} onChange={(e) => setContentType(e.target.value)} required>
                            {availableCategories.length === 0 ? (
                                <option>Loading categories...</option>
                            ) : (
                                availableCategories.map(cat => (<option key={cat} value={cat}>{cat}</option>))
                            )}
                        </select>
                    </div>
                    <div className="formGroup"><label htmlFor="orderIndex" className="formLabel">Display Order Index (Lower numbers appear first):</label><input type="number" id="orderIndex" className="formInput" value={orderIndex} onChange={(e) => setOrderIndex(e.target.value)} min="0" /></div>
                    <div className="formGroup"><div className="checkboxItem"><input type="checkbox" id="isActive" checked={isActive} onChange={(e) => setIsActive(e.target.checked)} /><label htmlFor="isActive">Is Active (Show on public pages)</label></div></div>
                    <button type="submit" className="button"><span className="buttonText">Add Content Item</span></button>
                    <button type="button" className="button" onClick={resetForm} style={{ backgroundColor: '#555', color: '#FFF', marginLeft: '10px' }}><span className="buttonText">Clear Form</span></button>
                </form>
            </div>

            <div className="dashboardSection" style={{ marginTop: '30px' }}>
                <div 
                    className="flex justify-between items-center cursor-pointer" 
                    onClick={() => setIsContentListExpanded(!isContentListExpanded)}
                >
                    <p className="dashboardSectionTitle" style={{ marginBottom: 0 }}>Existing Content Items ({contentItems.length})</p>
                    <button className="text-xl font-bold text-white">{isContentListExpanded ? '' : ''}</button>
                </div>
                
                <div className={`overflow-hidden transition-all duration-500 ease-in-out ${isContentListExpanded ? 'max-h-[3000px] mt-4' : 'max-h-0'}`}>
                    <div className="pt-4 border-t" style={{borderColor: '#3A3A3A'}}>
                        {loading ? <p>Loading...</p> : (
                            <div className="dashboardContentList">
                                {contentItems.map(item => (
                                    <div key={item.id} className="adminDashboardItem">
                                        <img src={item.customThumbnailUrl || 'https://placehold.co/50x50/3A3A3A/FFF?text=X'} alt="Thumbnail" style={{ width: '50px', height: '50px', borderRadius: '5px', objectFit: 'cover', marginRight: '10px' }} />
                                        <div style={{ flexGrow: 1 }}>
                                            <p className="adminDashboardItemTitle">{item.title}</p>
                                            <p style={{ fontSize: '12px', color: '#CCC' }}>Creator: {item.creatorName} | Type: {item.contentType}</p>
                                            <p style={{ fontSize: '12px', color: item.isActive ? '#00FF00' : '#DC3545' }}>Status: {item.isActive ? 'Active' : 'Inactive'}</p>
                                        </div>
                                        <button className="adminActionButton" onClick={() => handleToggleActive(item)} style={{ backgroundColor: item.isActive ? '#DC3545' : '#008000', color: '#FFF' }}>{item.isActive ? 'Deactivate' : 'Activate'}</button>
                                        <button className="adminActionButton reject" onClick={() => confirmDeleteContent(item.id, item.title)}>Delete</button>
                                    </div>
                                ))}
                            </div>
                        )}
                    </div>
                </div>
            </div>
            
            {showCurationModal && (
                <AdminCurationModal 
                    curationTarget={curationTarget}
                    showMessage={showMessage}
                    onCancel={() => setShowCurationModal(false)}
                    contentItems={contentItems}
                />
            )}
        </div>
    );
};
// ====================== END: FULL COMPONENT REPLACEMENT ======================

    // FINAL VERSION of AdminSiteManagerScreen (with Inbox)

        const AdminSiteManagerScreen = ({ showMessage, setActiveScreen, setShowConfirmationModal, setConfirmationTitle, setConfirmationMessage, setOnConfirmationAction, creatorProfile }) => {
    const [socialLinks, setSocialLinks] = useState([]);
    const [isLoading, setIsLoading] = useState(true);
    const [isSaving, setIsSaving] = useState(false);
    const [hasChanges, setHasChanges] = useState(false);
    const [isLeaderboardEnabled, setIsLeaderboardEnabled] = useState(false);
    const [premiumPrice, setPremiumPrice] = useState(1.99);
    const [ticketPrice, setTicketPrice] = useState(5.00);
    const [isTicketedEvent, setIsTicketedEvent] = useState(false);
    const [submissions, setSubmissions] = useState([]);
    const [isLoadingSubmissions, setIsLoadingSubmissions] = useState(true);
    const [selectedSubmission, setSelectedSubmission] = useState(null);
      const [diagnosticResults, setDiagnosticResults] = useState(null);
    const [isDiagnosing, setIsDiagnosing] = useState(false);
    const [mmgNumber, setMmgNumber] = useState('');
    const handleRunDiagnostics = async () => {
        setIsDiagnosing(true);
        setDiagnosticResults(null);
        showMessage("Running system diagnostics...");
        try {
            const runDiagnosticsCallable = window.httpsCallable(window.firebaseFunctions, 'runSystemDiagnostics');
            const result = await runDiagnosticsCallable();
            setDiagnosticResults(result.data.diagnosticResults);
            showMessage("Diagnostics complete.");
        } catch (error) {
            console.error("Error running diagnostics:", error);
            showMessage(`Diagnostics failed: ${error.message}`);
            setDiagnosticResults({ error: error.message });
        } finally {
            setIsDiagnosing(false);
        }
    };
    // --- END: PASTE THE DIAGNOSTIC HANDLER FUNCTION HERE ---
    // useEffect hooks remain unchanged
    useEffect(() => {
        const socialLinksDocRef = doc(db, "settings", "socialLinks");
        const unsubscribe = onSnapshot(socialLinksDocRef, (docSnap) => {
           if (docSnap.exists()) {
                const data = docSnap.data();
                // Handle social links array
                if (data && Array.isArray(data.links)) {
                    const sortedLinks = [...data.links].sort((a, b) => a.name.localeCompare(b.name));
                    setSocialLinks(sortedLinks);
                } else {
                    setSocialLinks([]);
                }

                // --- NEW: Handle the leaderboard toggle ---
                if (data && typeof data.isLeaderboardEnabled === 'boolean') {
                    setIsLeaderboardEnabled(data.isLeaderboardEnabled);
                } else {
                    setIsLeaderboardEnabled(false); // Default to false if not set
                }
                // --- NEW: Handle pricing and ticket toggles ---
                if (data && typeof data.premiumPrice === 'number') {
                    setPremiumPrice(data.premiumPrice);
                }
                if (data && typeof data.ticketPrice === 'number') {
                    setTicketPrice(data.ticketPrice);
                }
                if (data && typeof data.isTicketedEvent === 'boolean') {
                    setIsTicketedEvent(data.isTicketedEvent);
                }
                // --- THIS IS THE FIX ---
                if (data && typeof data.mmgNumber !== 'undefined') {
                    setMmgNumber(data.mmgNumber);
                }

            } else {
                setSocialLinks([]);
                setIsLeaderboardEnabled(false); // Default to false if doc doesn't exist
            }
            setIsLoading(false);
        });
        return () => unsubscribe();
    }, []);

    // handleUpdateLink and handleSaveChanges remain unchanged
    const handleUpdateField = (fieldName, value) => {
    if (fieldName === 'isLeaderboardEnabled') {
        setIsLeaderboardEnabled(value);
    } else {
        const [index, field] = fieldName.split('-');
        const updatedLinks = [...socialLinks];
        updatedLinks[parseInt(index)][field] = value;
        setSocialLinks(updatedLinks);
    }
    setHasChanges(true);
};
    const handleSaveChanges = async () => { if (!hasChanges) return; setIsSaving(true); showMessage("Saving changes..."); try { const socialLinksDocRef = doc(db, "settings", "socialLinks"); await setDoc(socialLinksDocRef, { 
    links: socialLinks, 
    isLeaderboardEnabled: isLeaderboardEnabled, 
    
    // =========== ADD THE FOLLOWING 3 LINES ===========
    premiumPrice: parseFloat(premiumPrice),
    ticketPrice: parseFloat(ticketPrice),
    isTicketedEvent: isTicketedEvent,
    mmgNumber: mmgNumber

}, { merge: true }); showMessage("Changes saved successfully!"); setHasChanges(false); } catch (error) { showMessage(`Error saving changes: ${error.message}`); } finally { setIsSaving(false); } };

    // handleViewSubmission remains unchanged
    const handleViewSubmission = async (submission) => {
        setSelectedSubmission(submission);
        if (submission.status === 'New') {
            try { await updateDoc(doc(db, "contactSubmissions", submission.id), { status: 'Read' }); } catch (error) { console.error("Error marking submission as read:", error); }
        }
    };

    // --- NEW: Function to handle deleting a submission ---
    const deleteSubmissionLogic = async (submissionId) => {
        showMessage("Deleting submission...");
        try {
            await deleteDoc(doc(db, "contactSubmissions", submissionId));
            setSelectedSubmission(null); // Close the modal after deletion
            showMessage("Submission deleted successfully.");
        } catch (error) {
            console.error("Error deleting submission:", error);
            showMessage(`Failed to delete submission: ${error.message}`);
        }
    };

    // --- NEW: Confirmation handler for the delete action ---
    const confirmDeleteSubmission = (submission) => {
        // First, hide the details modal so the confirmation modal is clear.
        setSelectedSubmission(null);
        // Now, set up and show the confirmation modal.
        setConfirmationTitle("Delete Submission?");
        setConfirmationMessage(`Are you sure you want to permanently delete this message from "${submission.userName}"? This action cannot be undone.`);
        setOnConfirmationAction(() => () => deleteSubmissionLogic(submission.id));
        setShowConfirmationModal(true);
    };

    if (isLoading) {
        return <div className="screenContainer"><p className="heading">Loading Site Settings...</p></div>;
    }
    const currentUserRole = creatorProfile ? creatorProfile.role : 'user';
    return (
        <div className="screenContainer">
            <p className="heading">Site Management</p>
            {/* ... Social Links Manager JSX remains unchanged ... */}
            <div className="dashboardSection">
                <div className="flex justify-between items-center mb-4"><p className="dashboardSectionTitle" style={{marginBottom: 0}}>Social Links Manager</p><button className="button" onClick={handleSaveChanges} disabled={!hasChanges || isSaving}><span className="buttonText">{isSaving ? 'Saving...' : 'Save Changes'}</span></button></div>
                <div className="dashboardContentList">
                    {socialLinks.map((link, index) => (
                        <div key={link.name || index} className="adminDashboardItem" style={{flexDirection: 'column', alignItems: 'stretch', gap: '10px'}}>
                            <div className="flex justify-between items-center"><p className="adminDashboardItemTitle">{link.name}</p><label className="flex items-center cursor-pointer"><span className="mr-3 text-sm font-medium text-gray-300">{link.isEnabled ? 'Visible' : 'Hidden'}</span><div className="relative"><input type="checkbox" className="sr-only" checked={link.isEnabled} onChange={(e) => handleUpdateField(`${index}-isEnabled`, e.target.checked)} /><div className={`block w-14 h-8 rounded-full ${link.isEnabled ? 'bg-green-500' : 'bg-gray-600'}`}></div><div className={`dot absolute left-1 top-1 bg-white w-6 h-6 rounded-full transition-transform ${link.isEnabled ? 'transform translate-x-6' : ''}`}></div></div></label></div>
                            <div className="formGroup" style={{marginBottom: 0}}><label className="formLabel" style={{fontSize: '12px', color: '#AAA'}}>URL:</label><input type="url" className="formInput" value={link.url} onChange={(e) => handleUpdateField(`${index}-url`, e.target.value)} placeholder={`Enter full URL for ${link.name}`} /></div>
                        </div>
                    ))}
                </div>
            </div>

            <div className="dashboardSection">
    <p className="dashboardSectionTitle">Feature Toggles</p>
    <div className="adminDashboardItem">
        <p className="adminDashboardItemTitle" style={{fontWeight: 'normal'}}>Enable Top Performers Screen</p>
        <label className="flex items-center cursor-pointer">
            <span className="mr-3 text-sm font-medium text-gray-300">{isLeaderboardEnabled ? 'Enabled' : 'Disabled'}</span>
            <div className="relative">
                <input 
                    type="checkbox" 
                    className="sr-only" 
                    checked={isLeaderboardEnabled} 
                    onChange={(e) => handleUpdateField('isLeaderboardEnabled', e.target.checked)} 
                />
                <div className={`block w-14 h-8 rounded-full ${isLeaderboardEnabled ? 'bg-green-500' : 'bg-gray-600'}`}></div>
                <div className={`dot absolute left-1 top-1 bg-white w-6 h-6 rounded-full transition-transform ${isLeaderboardEnabled ? 'transform translate-x-6' : ''}`}></div>
            </div>
        </label>
    </div>
</div>


            <div className="dashboardSection">
                <p className="dashboardSectionTitle">Monetization Settings</p>
                <div className="adminDashboardItem">
                    <p className="adminDashboardItemTitle" style={{fontWeight: 'normal'}}>Premium Subscription Price (USD)</p>
                    <input 
                        type="number" 
                        className="formInput" 
                        value={premiumPrice} 
                        onChange={(e) => { setPremiumPrice(e.target.value); setHasChanges(true); }}
                        style={{width: '100px', textAlign: 'right'}} 
                    />
                </div>
                <div className="adminDashboardItem">
                    <p className="adminDashboardItemTitle" style={{fontWeight: 'normal'}}>Enable One-Time Ticket Sales</p>
                    <label className="flex items-center cursor-pointer">
                        <span className="mr-3 text-sm font-medium text-gray-300">{isTicketedEvent ? 'Enabled' : 'Disabled'}</span>
                        <div className="relative">
                            <input 
                                type="checkbox" 
                                className="sr-only" 
                                checked={isTicketedEvent} 
                                onChange={(e) => { setIsTicketedEvent(e.target.checked); setHasChanges(true); }} 
                            />
                            <div className={`block w-14 h-8 rounded-full ${isTicketedEvent ? 'bg-green-500' : 'bg-gray-600'}`}></div>
                            <div className={`dot absolute left-1 top-1 bg-white w-6 h-6 rounded-full transition-transform ${isTicketedEvent ? 'transform translate-x-6' : ''}`}></div>
                        </div>
                    </label>
                </div>
                {isTicketedEvent && (
                    <div className="adminDashboardItem">
                        <p className="adminDashboardItemTitle" style={{fontWeight: 'normal'}}>Single Event Ticket Price (USD)</p>
                        <input 
                            type="number" 
                            className="formInput" 
                            value={ticketPrice} 
                            onChange={(e) => { setTicketPrice(e.target.value); setHasChanges(true); }}
                            style={{width: '100px', textAlign: 'right'}} 
                        />
                    </div>
                )}
            
                {/* ======================= START: NEW UI ======================= */}
                {currentUserRole === 'admin' && (
                     <div className="adminDashboardItem">
                        <p className="adminDashboardItemTitle" style={{fontWeight: 'normal', color: '#FFD700'}}>MMG Account Number</p>
                        <input 
                            type="text" 
                            className="formInput" 
                            value={mmgNumber} 
                            onChange={(e) => { setMmgNumber(e.target.value); setHasChanges(true); }}
                            placeholder="Enter MMG number..."
                            style={{width: '200px', textAlign: 'right'}} 
                        />
                    </div>
                )}
                {/* ======================== END: NEW UI ======================== */}
                        
            </div>

            <div className="dashboardSection" style={{marginTop: '20px'}}>
                <p className="dashboardSectionTitle">Contact Form Submissions</p>
                {isLoadingSubmissions ? <p>Loading submissions...</p> : (
                    <div className="dashboardContentList">
                        {submissions.length === 0 ? <p className="dashboardItem">No submissions yet.</p> : (
                            submissions.map(sub => (
                                <div key={sub.id} className="adminDashboardItem" onClick={() => handleViewSubmission(sub)} style={{cursor: 'pointer', borderLeft: sub.status === 'New' ? '4px solid #FFD700' : '4px solid transparent'}}>
                                    <div style={{flexGrow: 1}}><p className="adminDashboardItemTitle">{sub.queryType} - <span style={{fontWeight: 'normal'}}>{sub.userName}</span></p><p style={{fontSize: '12px', color: '#AAA'}}>{new Date(sub.submittedAt).toLocaleString()}</p></div>
                                    <span className="adminDashboardItemStatus">{sub.status}</span>
                                </div>
                            ))
                        )}
                    </div>
                )}
            </div>

            {selectedSubmission && (
                <div className="confirmationModalOverlay" style={{zIndex: 2500}}>
                    <div className="confirmationModalContent" style={{textAlign: 'left', maxWidth: '500px'}}>
                        <p className="confirmationModalTitle">{selectedSubmission.queryType}</p>
                        <div className="dashboardItem"><strong>From:</strong> {selectedSubmission.userName}</div>
                        <div className="dashboardItem"><strong>Email:</strong> <a href={`mailto:${selectedSubmission.userEmail}`} className="termsLink">{selectedSubmission.userEmail}</a></div>
                        <div className="dashboardItem"><strong>Date:</strong> {new Date(selectedSubmission.submittedAt).toLocaleString()}</div>
                        <hr style={{borderColor: '#333', margin: '15px 0'}}/>
                        <p className="paragraph" style={{backgroundColor: '#0A0A0A', padding: '10px', borderRadius: '5px', whiteSpace: 'pre-wrap'}}>{selectedSubmission.message}</p>
                        <div className="confirmationModalButtons">
                            {/* --- THIS IS THE NEW DELETE BUTTON --- */}
                            <button className="confirmationButton cancel" onClick={() => confirmDeleteSubmission(selectedSubmission)}>Delete</button>
                            <button className="confirmationButton confirm" onClick={() => setSelectedSubmission(null)}>Close</button>
                        </div>
                    </div>
                </div>
            )}
                {/* --- START: PASTE THE SYSTEM STATUS JSX BLOCK HERE --- */}
            <div className="dashboardSection" style={{ border: '2px solid #00FFFF', marginTop: '20px' }}>
                <p className="dashboardSectionTitle">System Status</p>
                <button
                    className="button"
                    onClick={handleRunDiagnostics}
                    style={{ backgroundColor: '#008080' }}
                    disabled={isDiagnosing}
                >
                    <span className="buttonText">{isDiagnosing ? 'Running...' : 'Run System Diagnostics'}</span>
                </button>
                {diagnosticResults && (
                    <div style={{ marginTop: '15px', color: '#FFF' }}>
                        {diagnosticResults.error ? (
                            <p style={{ color: '#DC3545' }}>Error: {diagnosticResults.error}</p>
                        ) : (
                            <table style={{ width: '100%', borderCollapse: 'collapse' }}>
                                <tbody>
                                    <tr style={{ borderBottom: '1px solid #3A3A3A' }}>
                                        <td style={{ padding: '8px 0', fontWeight: 'bold' }}>Project ID:</td>
                                        <td style={{ textAlign: 'right' }}>{diagnosticResults.projectID}</td>
                                    </tr>
                                    <tr style={{ borderBottom: '1px solid #3A3A3A' }}>
                                        <td style={{ padding: '8px 0', fontWeight: 'bold' }}>Database Connectivity:</td>
                                        <td style={{ textAlign: 'right', color: diagnosticResults.dbConnectivity === 'Success' ? '#00FF00' : '#DC3545', fontWeight: 'bold' }}>
                                            {diagnosticResults.dbConnectivity}
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        )}
                    </div>
                )}
            </div>
            {/* --- END: PASTE THE SYSTEM STATUS JSX BLOCK HERE --- */}
        </div>
    );
};


// =================== END: REPLACE THIS ENTIRE COMPONENT ===================

        // REPLACE THE ENTIRE AdminCategoryManagerScreen COMPONENT WITH THIS FINAL VERSION
        const AdminCategoryManagerScreen = ({
    showMessage,
    setActiveScreen,
    setShowConfirmationModal,
    setConfirmationTitle,
    setConfirmationMessage,
    setOnConfirmationAction
}) => {
    const [categories, setCategories] = useState([]);
    const [loading, setLoading] = useState(true);
    const [newCategoryName, setNewCategoryName] = useState('');
    const [newCategoryOrder, setNewCategoryOrder] = useState(100);
    const [editingCategory, setEditingCategory] = useState(null);

    const [liveCategoryDoc, setLiveCategoryDoc] = useState(null);
    const [liveUrlInput, setLiveUrlInput] = useState('');
    const [liveStartTimeInput, setLiveStartTimeInput] = useState('');
    
    const [liveCustomThumbnailFile, setLiveCustomThumbnailFile] = useState(null);
    const [liveCustomThumbnailPreview, setLiveCustomThumbnailPreview] = useState('');
    const [liveAutoThumbnailPreview, setLiveAutoThumbnailPreview] = useState('');
    const liveThumbnailInputRef = useRef(null);
    const [isSaving, setIsSaving] = useState(false);

    useEffect(() => {
        const categoriesRef = collection(db, "content_categories");
        const q = query(categoriesRef, orderBy("orderIndex", "asc"));
        const unsubscribe = onSnapshot(q, (snapshot) => {
            const fetchedCategories = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            setCategories(fetchedCategories);
            const liveDoc = fetchedCategories.find(cat => cat.name === 'Live Premieres');
            if (liveDoc) {
                setLiveCategoryDoc(liveDoc);
                setLiveUrlInput(liveDoc.liveStreamUrl || '');
                setLiveCustomThumbnailPreview(liveDoc.liveStreamThumbnailUrl || '');
                if (liveDoc.liveStreamStartTime) {
                    const date = liveDoc.liveStreamStartTime.toDate();
                    date.setMinutes(date.getMinutes() - date.getTimezoneOffset());
                    setLiveStartTimeInput(date.toISOString().slice(0, 16));
                } else {
                    setLiveStartTimeInput('');
                }
            }
            setLoading(false);
        });
        return () => unsubscribe();
    }, []);

    useEffect(() => {
        if (!liveUrlInput) {
            setLiveAutoThumbnailPreview('');
            return;
        }
        const handler = setTimeout(() => {
            const { thumbnailUrl } = extractVideoInfo(liveUrlInput);
            setLiveAutoThumbnailPreview(thumbnailUrl || '');
        }, 500);
        return () => clearTimeout(handler);
    }, [liveUrlInput]);

    const handlePremiereThumbFileChange = (e) => {
        const file = e.target.files[0];
        if (file) {
            setLiveCustomThumbnailFile(file);
            setLiveCustomThumbnailPreview(URL.createObjectURL(file));
        }
    };
    
    const handleSetLiveEvent = async () => {
         if (!liveStartTimeInput || !liveUrlInput) {
            showMessage("Please set both a start time and a valid URL.");
            return;
        }
        setIsSaving(true);
        const liveDocRef = doc(db, "content_categories", liveCategoryDoc.id);
        let updatedData = {
            liveStreamUrl: liveUrlInput,
            liveStreamStartTime: new Date(liveStartTimeInput),
            liveStreamThumbnailUrl: liveCustomThumbnailPreview || liveAutoThumbnailPreview || ''
        };

        if (liveCustomThumbnailFile) {
            try {
                showMessage("Uploading custom thumbnail...");
                const filePath = `premiere_thumbnails/${Date.now()}_${liveCustomThumbnailFile.name}`;
                const storageRef = ref(storage, filePath);
                const snapshot = await uploadBytes(storageRef, liveCustomThumbnailFile);
                updatedData.liveStreamThumbnailUrl = await getDownloadURL(snapshot.ref);
            } catch (error) {
                showMessage(`Thumbnail upload failed: ${error.message}`);
                setIsSaving(false);
                return;
            }
        }
        
        try {
            await updateDoc(liveDocRef, updatedData);
            showMessage("Live Premiere has been set!");
        } catch (error) {
            showMessage(`Error: ${error.message}`);
        } finally {
            setLiveCustomThumbnailFile(null);
            if (liveThumbnailInputRef.current) liveThumbnailInputRef.current.value = '';
            setIsSaving(false);
        }
    };

    const handleClearLiveEvent = async () => {
        setIsSaving(true);
        try {
            await updateDoc(doc(db, "content_categories", liveCategoryDoc.id), {
                liveStreamUrl: '', liveStreamStartTime: null, liveStreamThumbnailUrl: ''
            });
            showMessage("Live Premiere has been cleared.");
        } catch (error) { showMessage(`Error: ${error.message}`); } 
        finally { setIsSaving(false); }
    };

    const handleAddCategory = async (e) => {
        e.preventDefault();
        if (!newCategoryName.trim()) return;
        try {
            await addDoc(collection(db, "content_categories"), { name: newCategoryName.trim(), orderIndex: parseInt(newCategoryOrder, 10), isActive: true, createdAt: new Date().toISOString() });
            setNewCategoryName(''); setNewCategoryOrder(100);
        } catch (error) { showMessage(`Error: ${error.message}`); }
    };
    
    const deleteLogic = async (cat) => {
         try {
            await deleteDoc(doc(db, "content_categories", cat.id));
            showMessage(`Category "${cat.name}" deleted.`);
        } catch (error) { showMessage(`Error: ${error.message}`); }
    };

    const handleDeleteCategory = (category) => {
        if (category.name === "Live Premieres") { showMessage("This category cannot be deleted."); return; }
        setConfirmationTitle("Delete Category?");
        setConfirmationMessage(`Are you sure you want to permanently delete "${category.name}"?`);
        setOnConfirmationAction(() => () => deleteLogic(category));
        setShowConfirmationModal(true);
    };

    const handleToggleActive = async (category) => {
         try {
            await updateDoc(doc(db, "content_categories", category.id), { isActive: !category.isActive });
        } catch (error) { showMessage(`Error: ${error.message}`); }
    };
    
    const handleSaveEdit = async () => {
        try {
            await updateDoc(doc(db, "content_categories", editingCategory.id), { name: editingCategory.name, orderIndex: parseInt(editingCategory.orderIndex, 10) });
            setEditingCategory(null);
        } catch (error) { showMessage(`Error: ${error.message}`); }
    };

    const finalThumbnailPreview = liveCustomThumbnailPreview || liveAutoThumbnailPreview;

    return (
        <div className="screenContainer">
            <p className="heading">Manage Categories</p>
            <p className="subHeading">Control the tabs for the Discover screen.</p>
            
            <div className="dashboardSection" style={{border: '2px solid #FFD700'}}>
                <p className="dashboardSectionTitle">Live Premieres Control</p>
                 {loading ? <p>Loading controls...</p> : (
                    <div>
                        <div className="formGroup">
                            <label className="formLabel">Scheduled Start Time:</label>
                            <input type="datetime-local" className="formInput" value={liveStartTimeInput} onChange={(e) => setLiveStartTimeInput(e.target.value)} />
                        </div>
                        <div className="formGroup">
                            <label className="formLabel">Embed URL:</label>
                            <input type="url" className="formInput" value={liveUrlInput} onChange={(e) => setLiveUrlInput(e.target.value)} />
                        </div>
                        
                        <div className="formGroup">
                            <label className="formLabel">"Coming Soon" Thumbnail Preview:</label>
                            {finalThumbnailPreview ? (
                                <img src={finalThumbnailPreview} alt="Premiere thumbnail preview" style={{maxWidth: '200px', borderRadius: '8px', margin: '10px 0', border: '1px solid #444'}}/>
                            ) : <p className="smallText" style={{textAlign: 'left', color: '#AAA'}}>No thumbnail generated. Paste a valid URL or upload an image.</p>}
                            <input type="file" ref={liveThumbnailInputRef} onChange={handlePremiereThumbFileChange} accept="image/*" style={{display: 'none'}} />
                            <button type="button" className="button" style={{backgroundColor: '#3A3A3A', width: 'auto'}} onClick={() => liveThumbnailInputRef.current.click()}>
                                <span className="buttonText">Upload Image</span>
                            </button>
                        </div>

                        <div className="flex gap-4 mt-4">
                            <button onClick={handleSetLiveEvent} className="button" disabled={isSaving}>
                                <span className="buttonText">{isSaving ? 'Saving...' : 'Set / Update Event'}</span>
                            </button>
                            <button onClick={handleClearLiveEvent} className="button" style={{backgroundColor: '#555'}} disabled={isSaving}>
                                <span className="buttonText">{isSaving ? 'Clearing...' : 'Clear Event'}</span>
                            </button>
                        </div>
                    </div>
                )}
            </div>

            <div className="dashboardSection">
                <p className="dashboardSectionTitle">Add New Category</p>
                <form onSubmit={handleAddCategory} className="flex items-end gap-4">
                    <div className="formGroup flex-grow mb-0"><label className="formLabel">Category Name:</label><input type="text" className="formInput" value={newCategoryName} onChange={(e) => setNewCategoryName(e.target.value)} required /></div>
                    <div className="formGroup mb-0"><label className="formLabel">Order:</label><input type="number" className="formInput" value={newCategoryOrder} onChange={(e) => setNewCategoryOrder(e.target.value)} style={{width: '80px'}} /></div>
                    <button type="submit" className="button m-0"><span className="buttonText">Add</span></button>
                </form>
            </div>

            <div className="dashboardSection">
                <p className="dashboardSectionTitle">Existing Categories</p>
                {loading ? <p>Loading...</p> : (
                    <div className="dashboardContentList">
                        {categories.map(cat => (
                            <div key={cat.id} className="adminDashboardItem" style={{alignItems: 'center', gap: '10px'}}>
                                {editingCategory && editingCategory.id === cat.id ? (
                                    <>
                                        <input type="text" value={editingCategory.name} onChange={(e) => setEditingCategory({...editingCategory, name: e.target.value})} className="formInput flex-grow" disabled={cat.name === "Live Premieres"} />
                                        <input type="number" value={editingCategory.orderIndex} onChange={(e) => setEditingCategory({...editingCategory, orderIndex: e.target.value})} className="formInput w-20" />
                                        <button onClick={handleSaveEdit} className="adminActionButton approve">Save</button>
                                        <button onClick={() => setEditingCategory(null)} className="adminActionButton">Cancel</button>
                                    </>
                                ) : (
                                    <>
                                        <span className="flex-grow font-bold">{cat.name}</span>
                                        <span className="text-sm text-gray-400">Order: {cat.orderIndex}</span>
                                        <span className={`font-bold ${cat.isActive ? 'text-green-400' : 'text-red-400'}`}>{cat.isActive ? 'Active' : 'Inactive'}</span>
                                        <button onClick={() => handleToggleActive(cat)} className="adminActionButton">{cat.isActive ? 'Deactivate' : 'Activate'}</button>
                                        <button onClick={() => setEditingCategory({...cat})} className="adminActionButton" disabled={cat.name === "Live Premieres"}>Edit</button>
                                        <button onClick={() => handleDeleteCategory(cat)} className="adminActionButton reject" disabled={cat.name === "Live Premieres"}>Delete</button>
                                    </>
                                )}
                            </div>
                        ))}
                    </div>
                )}
            </div>
            
            <button className="button" onClick={() => setActiveScreen('AdminDashboard')} style={{ backgroundColor: '#3A3A3A', color: '#FFF' }}>
                <span className="buttonText">Back to Admin Dashboard</span>
            </button>
        </div>
    );
};
        
        // New UserSignUpScreen component
        const UserSignUpScreen = ({ showMessage, setActiveScreen }) => {
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const [agreedToTerms, setAgreedToTerms] = useState(false);

    const handleSubmit = async (e) => {
        e.preventDefault();
        if (!agreedToTerms) {
            showMessage('Please agree to the Terms & Conditions to sign up.');
            return;
        }
        if (password.length < 8 || !/\d/.test(password) || !/[A-Z]/.test(password)) {
            showMessage('Password must be at least 8 characters, with a number and a capital letter.');
            return;
        }

        try {
            const userCredential = await createUserWithEmailAndPassword(auth, email, password);
            const user = userCredential.user;
            await sendEmailVerification(user);
            const creatorRef = doc(db, "creators", user.uid);
            await setDoc(creatorRef, {
                email: user.email,
                creatorName: user.email.split('@')[0] || "", // Default name from email
                bio: "",
                categories: [],
                existingWorkLink: "",
                profilePictureUrl: '',
                uploadedVideos: { youtube: null, facebook: null, tiktok: null },
                createdAt: new Date().toISOString(),
                role: 'user', // Explicitly set role to 'user'
                banned: false
            });

            showMessage(`Account created successfully for ${email}! Please check your inbox to verify your account.`);
            // Correctly redirects to the verification screen after successful signup.
            setActiveScreen('VerifyEmail');
        }
        catch (error) {
            console.error("Error signing up user:", error);
            let errorMessage = "Failed to sign up. Please try again.";
            if (error.code === 'auth/email-already-in-use') {
                errorMessage = "This email is already in use. Please use a different email or sign in.";
            } else if (error.code === 'auth/invalid-email') {
                errorMessage = "Invalid email address format.";
            } else if (error.code === 'auth/weak-password') {
                errorMessage = "Password is too weak. Please choose a stronger password.";
            }
            showMessage(errorMessage);
        }
    };

    return (
        <div className="screenContainer">
            <p className="heading">Create Your Account</p>
            <p className="subHeading">Sign up to access exclusive content and support creators!</p>

            <form onSubmit={handleSubmit}>
                <div className="formGroup">
                    <label htmlFor="userEmail" className="formLabel">Email:</label>
                    <input
                        type="email"
                        id="userEmail"
                        className="formInput"
                        value={email}
                        onChange={(e) => setEmail(e.target.value)}
                        required
                    />
                </div>

                <div className="formGroup">
                    <label htmlFor="userPassword" className="formLabel">Password:</label>
                    <input
                        type="password"
                        id="userPassword"
                        className="formInput"
                        value={password}
                        onChange={(e) => setPassword(e.target.value)}
                        required
                    />
                    <p className="smallText" style={{ textAlign: 'left', color: '#FFD700', marginTop: '5px' }}>
                        Password must be at least 8 characters long, include at least one number and one capital letter.
                    </p>
                </div>

                <div className="formGroup">
                    <div className="checkboxItem">
                        <input
                            type="checkbox"
                            id="agreeUserTerms"
                            checked={agreedToTerms}
                            onChange={(e) => setAgreedToTerms(e.target.checked)}
                            required
                        />
                        <label htmlFor="agreeUserTerms">
                            I agree to the <a href="#" className="termsLink" onClick={(e) => { e.preventDefault(); showMessage('Simulating opening User Terms & Conditions...'); }}>Terms & Conditions</a>.
                        </label>
                    </div>
                </div>

                <button type="submit" className="button">
                    <span className="buttonText">Sign Up</span>
                </button>
            </form>

            <p className="smallText" style={{ marginTop: '20px' }}>
                Already have an account?{' '}
                <a href="#" className="termsLink" onClick={(e) => { e.preventDefault(); setActiveScreen('Login'); }}>Login Here</a>
            </p>

            <button
                className="button"
                onClick={() => setActiveScreen('Home')}
                style={{ backgroundColor: '#3A3A3A', color: '#FFF', marginTop: '30px' }}
            >
                <span className="buttonText">Back to Home</span>
            </button>
        </div>
    );
};
        
        // --- FIND and REPLACE the ENTIRE CategoriesScreen component with this block ---

const CategoriesScreen = ({ showMessage, isLive, countdownText, liveThumbnail, currentUser, handleVideoPress }) => {
    const [categories, setCategories] = useState([]);
    const [activeCategory, setActiveCategory] = useState('Live Premieres');
    const [content, setContent] = useState([]);
    const [loadingCategories, setLoadingCategories] = useState(true);
    const [loadingContent, setLoadingContent] = useState(false);
    const [liveStreamUrl, setLiveStreamUrl] = useState('');
    
    // New state to manage the visibility of the "More Content" dropdown
    const [showMoreMenu, setShowMoreMenu] = useState(false);

    useEffect(() => {
        const categoriesRef = collection(db, "content_categories");
        const q = query(categoriesRef, where("isActive", "==", true), orderBy("orderIndex", "asc"));
        const unsubscribe = onSnapshot(q, (snapshot) => {
            const fetchedCategories = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            setCategories(fetchedCategories);
            setLoadingCategories(false);
            const liveDoc = fetchedCategories.find(cat => cat.name === 'Live Premieres');
            setLiveStreamUrl(liveDoc ? liveDoc.liveStreamUrl : '');
        });
        return () => unsubscribe();
    }, []);

    useEffect(() => {
        if (!activeCategory || activeCategory === 'Live Premieres') {
            setContent([]); setLoadingContent(false); return;
        }
        setLoadingContent(true);
        const contentRef = collection(db, `artifacts/${appId}/public/data/content_items`);
        const q = query(contentRef, where('contentType', '==', activeCategory), where('isActive', '==', true), orderBy('createdAt', 'desc'));
        const unsubscribe = onSnapshot(q, (snapshot) => {
            setContent(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
            setLoadingContent(false);
        });
        return () => unsubscribe();
    }, [activeCategory]);

    const handleCategoryClick = (categoryName) => {
        setActiveCategory(categoryName);
        setShowMoreMenu(false); // Close the menu whenever a category is selected
    };

    const LiveStreamPlayer = () => {
        if (isLive) {
            const { embedUrl, isVertical } = extractVideoInfo(liveStreamUrl);
            const finalEmbedUrl = embedUrl || `${liveStreamUrl}?autoplay=1`;
            return (
                <div style={{ width: '100%', maxWidth: '900px', margin: '0 auto' }}>
                    <div className={`videoIframeContainer ${isVertical ? 'vertical' : ''}`}>
                        <iframe src={finalEmbedUrl} allow="autoplay; fullscreen" title="Live Premiere Content"></iframe>
                    </div>
                </div>
            );
        }
        
        if (countdownText) {
            return (
                <div style={{textAlign: 'center', paddingTop: '50px', position: 'relative'}}>
                    {liveThumbnail ? (
                        <img 
                            src={liveThumbnail} 
                            alt="Coming Soon" 
                            style={{ display: 'block', margin: '0 auto', width: '100%', maxWidth: '480px', borderRadius: '10px', boxShadow: '0 4px 15px rgba(0,0,0,0.5)'}} 
                        />
                    ) : (
                        <div style={{ margin: '0 auto', width: '100%', maxWidth: '480px', height: '250px', backgroundColor: '#2A2A2A', borderRadius: '10px', display: 'flex', alignItems: 'center', justifyContent: 'center'}}>
                             <p className="heading">Coming Soon</p>
                        </div>
                    )}
                    <p className="heading" style={{marginTop: '20px'}}>Premiere Begins In:</p>
                    <p className="subHeading" style={{color: '#FFD700', fontSize: '28px'}}>{countdownText}</p>
                </div>
            );
        }

        return (
            <div style={{textAlign: 'center', paddingTop: '50px'}}>
                <p className="heading">Stream Offline</p>
                <p className="subHeading">No live premiere is currently scheduled.</p>
            </div>
        );
    };
    
    // Logic to split categories into visible and hidden
    const visibleCategories = categories.slice(0, 2);
    const hiddenCategories = categories.slice(2);

    return (
        <div className="screenContainer">
            <p className="sectionTitle">Discover Content</p>
            {loadingCategories ? <p>Loading categories...</p> : (
                <div className="categoryTabs">
                    {/* Render the first 2 (or fewer) visible categories */}
                    {visibleCategories.map(category => (
                        <button key={category.id} className={`categoryTab ${activeCategory === category.name ? 'activeCategoryTab' : ''}`} onClick={() => handleCategoryClick(category.name)}>
                            <span className={`categoryTabText ${activeCategory === category.name ? 'activeCategoryTabText' : ''}`}>{category.name}</span>
                        </button>
                    ))}
                    
                    {/* If there are more than 2 categories, render the "More Content" button */}
                    {hiddenCategories.length > 0 && (
                        <button className="categoryTab" onClick={() => setShowMoreMenu(!showMoreMenu)}>
                            <span className="categoryTabText">More Content {showMoreMenu ? '' : ''}</span>
                        </button>
                    )}

                    {/* Conditionally render the dropdown menu */}
                    {showMoreMenu && hiddenCategories.length > 0 && (
                        <div className="moreCategoriesMenu">
                            {hiddenCategories.map(category => (
                                <button key={category.id} className={`categoryTab moreMenuItem ${activeCategory === category.name ? 'activeCategoryTab' : ''}`} onClick={() => handleCategoryClick(category.name)}>
                                    <span className={`categoryTabText ${activeCategory === category.name ? 'activeCategoryTabText' : ''}`}>{category.name}</span>
                                </button>
                            ))}
                        </div>
                    )}
                </div>
            )}
            
            <div className="categoryContent">
                {activeCategory === 'Live Premieres' ? (
                    <LiveStreamPlayer />
                ) : loadingContent ? (
                    <p className="paragraph" style={{textAlign: 'center'}}>Loading content...</p>
                ) : content.length === 0 ? (
                    <p className="paragraph" style={{textAlign: 'center'}}>There is no content in this category yet.</p>
                ) : (
                    <div className="contentGrid">
                        {content.map((item) => (
                            <div key={item.id} className="contentCard" onClick={() => handleVideoPress(item.embedUrl || item.mainUrl, item)}>
                                <div className="thumbnailPlaceholder" style={{backgroundImage: `url(${item.customThumbnailUrl})`, backgroundSize: 'cover', backgroundPosition: 'center', position: 'relative'}}>
                                    <svg className="playIcon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"></path></svg>
                                    {currentUser && item.id && <LikeButton contentItem={item} currentUser={currentUser} showMessage={showMessage} />}
                                </div>
                                <p className="contentTitle">{item.title}</p>
                            </div>
                        ))}
                    </div>
                )}
            </div>
        </div>
    );
};

        
        // --- NEW HeaderLiveButton Component ---
const HeaderLiveButton = ({ isLive, countdownText, onClick }) => {
    if (!isLive && !countdownText) {
        return null; // The button remains invisible if no event is set
    }

    return (
        <button className={`header-live-button ${isLive ? 'live' : 'countdown'}`} onClick={onClick}>
            <span>{isLive ? '' : ''}</span>
            {/* This text is now more descriptive */}
            <span>{isLive ? 'Live Premieres: LIVE NOW' : `Live Premieres In: ${countdownText}`}</span>
        </button>
    );
};

        // --- NEW COMPONENT ---
        const LivePremiereBanner = ({ isLive, countdownText, onClick }) => {
            if (!isLive && !countdownText) {
                return null; // Don't render anything if there's no event
            }

            return (
                <div className={`live-premiere-banner ${isLive ? 'live' : ''}`} onClick={onClick}>
                    <span className="live-premiere-banner-icon">{isLive ? '' : ''}</span>
                    <span>{isLive ? 'LIVE NOW! Click to Watch!' : `Live Premiere In: ${countdownText}`}</span>
                </div>
            );
        };


        // --- NEW LEADERBOARD SCREEN ---
        const TopCreatorsScreen = ({ featuredContentSlots, handleVideoPress, setActiveScreen, currentUser, showMessage }) => {
    if (!featuredContentSlots) {
        return (
            <div className="screenContainer" style={{ textAlign: 'center', paddingTop: '50px' }}>
                <p className="heading">Loading Top Creators...</p>
            </div>
        );
    }

    const slots = [
        featuredContentSlots.slot_1,
        featuredContentSlots.slot_2,
        featuredContentSlots.slot_3
    ];

    return (
        <div className="screenContainer">
            <p className="heading">Top Creators</p>
            <p className="subHeading">The most engaging content from our top creators this week.</p>
            
            <div className="allCampaignsList">
                {slots.map((slot, index) => {
                    if (!slot || !slot.content) {
                        return (
                            <div key={index} className="allCampaignsListItem" style={{justifyContent: 'center', alignItems: 'center', minHeight: '120px'}}>
                                <p className="dashboardItem">Slot #{index + 1} is currently empty.</p>
                            </div>
                        );
                    }
                    const item = slot.content;
                    return (
                        <div key={item.id} className="allCampaignsListItem" onClick={() => handleVideoPress(item.embedUrl || item.mainUrl, item)} style={{borderLeft: '5px solid #FFD700', position: 'relative'}}>
                            <div style={{position: 'absolute', top: '-1px', left: '-1px', backgroundColor: '#FFD700', color: '#0A0A0A', padding: '5px 10px', borderTopLeftRadius: '8px', borderBottomRightRadius: '8px', fontWeight: 'bold'}}>
                                #{index + 1}
                            </div>
                            <img src={item.customThumbnailUrl} alt={item.title} className="creator-campaign-thumbnail" style={{width: '120px', height: '70px'}}/>
                            <div className="campaignListContent">
                                <p className="campaignListTitle" style={{color: '#FFF'}}>{item.title}</p>
                                <div className="campaignListCreator">
                                    <img src={item.creatorProfilePictureUrl || 'https://placehold.co/24x24/555/FFF?text=P'} alt={item.creatorName} className="campaignListCreatorProfilePic"/>
                                    <span>by {item.creatorName}</span>
                                </div>
                                <div className="campaignListStats">
                                    <span>Views: <span className="campaignListRaised">{item.viewCount || 0}</span></span>
                                    <span>Likes: <span className="campaignListGoal">{item.likeCount || 0}</span></span>
                                </div>
                            </div>
                        </div>
                    );
                })}
            </div>
            
            <button className="button" onClick={() => setActiveScreen('Home')} style={{ backgroundColor: '#3A3A3A', color: '#FFF', marginTop: '30px' }}>
                <span className="buttonText">Back to Home</span>
            </button>
        </div>
    );
};
// ======================================================================

        // --- NEW: My Follows Screen ---
        const MyFollowsScreen = ({ currentUser, setActiveScreen, setSelectedUserId, showMessage }) => {
    const [followedCreators, setFollowedCreators] = useState([]);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        if (!currentUser) {
            setActiveScreen('Login');
            return;
        }

        const fetchFollowedCreators = async () => {
            setLoading(true);
            try {
                // 1. Get the list of IDs from the user's "following" subcollection
                const followingRef = collection(db, "creators", currentUser.uid, "following");
                const followingSnapshot = await getDocs(followingRef);
                const followedIds = followingSnapshot.docs.map(doc => doc.id);

                if (followedIds.length > 0) {
                    // 2. Fetch the full profile for each ID
                    const creatorsRef = collection(db, "creators");
                    const q = query(creatorsRef, where("__name__", "in", followedIds));
                    const creatorsSnapshot = await getDocs(q);
                    const creatorsData = creatorsSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    setFollowedCreators(creatorsData);
                } else {
                    setFollowedCreators([]);
                }

            } catch (error) {
                console.error("Error fetching followed creators:", error);
                showMessage("Failed to load your followed creators list.");
            } finally {
                setLoading(false);
            }
        };

        fetchFollowedCreators();
    }, [currentUser]);

    const viewProfile = (userId) => {
        setSelectedUserId(userId);
        setActiveScreen('UserProfile');
    };

    if (loading) {
        return <div className="screenContainer"><p className="heading">Loading Followed Creators...</p></div>;
    }

    return (
        <div className="screenContainer">
            <p className="heading">Creators You Follow</p>
            <p className="subHeading">Here is a list of all the creators you are currently following.</p>

            <div className="user-search-list">
                {followedCreators.length === 0 ? (
                    <p className="dashboardItem" style={{textAlign: 'center'}}>You are not following any creators yet.</p>
                ) : (
                    followedCreators.map(user => (
                        <div key={user.id} className="user-search-item" style={{cursor: 'pointer'}} onClick={() => viewProfile(user.id)}>
                            <img src={user.profilePictureUrl || 'https://placehold.co/100x100/555/FFF?text=P'} alt={user.creatorName} className="user-search-pfp"/>
                            <div className="user-search-info">
                                <p className="user-search-name">{user.creatorName}</p>
                                <p className="user-search-role">Role: {user.role}</p>
                            </div>
                        </div>
                    ))
                )}
            </div>

            <button className="button" onClick={() => setActiveScreen('CreatorDashboard')} style={{ backgroundColor: '#3A3A3A', color: '#FFF', marginTop: '30px' }}>
                <span className="buttonText">Back to Dashboard</span>
            </button>
        </div>
    );
};

const FollowersScreen = ({ currentUser, setActiveScreen, setSelectedUserId, showMessage }) => {
    const [followers, setFollowers] = useState([]);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        if (!currentUser) {
            setActiveScreen('Login');
            return;
        }

        const fetchFollowers = async () => {
            setLoading(true);
            try {
                // Fetch from the 'followers' subcollection instead of 'following'
                const followersRef = collection(db, "creators", currentUser.uid, "followers");
                const followersSnapshot = await getDocs(followersRef);
                const followerIds = followersSnapshot.docs.map(doc => doc.id);

                if (followerIds.length > 0) {
                    const creatorsRef = collection(db, "creators");
                    const q = query(creatorsRef, where("__name__", "in", followerIds));
                    const creatorsSnapshot = await getDocs(q);
                    const followersData = creatorsSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    setFollowers(followersData);
                } else {
                    setFollowers([]);
                }

            } catch (error) {
                console.error("Error fetching followers:", error);
                showMessage("Failed to load your followers list.");
            } finally {
                setLoading(false);
            }
        };

        fetchFollowers();
    }, [currentUser]);

    const viewProfile = (userId) => {
        setSelectedUserId(userId);
        setActiveScreen('UserProfile');
    };

    if (loading) {
        return <div className="screenContainer"><p className="heading">Loading Your Followers...</p></div>;
    }

    return (
        <div className="screenContainer">
            <p className="heading">Your Followers</p>
            <p className="subHeading">This is a list of all the creators and users following you.</p>

            <div className="user-search-list">
                {followers.length === 0 ? (
                    <p className="dashboardItem" style={{textAlign: 'center'}}>You don't have any followers yet.</p>
                ) : (
                    followers.map(user => (
                        <div key={user.id} className="user-search-item" style={{cursor: 'pointer'}} onClick={() => viewProfile(user.id)}>
                            <img src={user.profilePictureUrl || 'https://placehold.co/100x100/555/FFF?text=P'} alt={user.creatorName} className="user-search-pfp"/>
                            <div className="user-search-info">
                                <p className="user-search-name">{user.creatorName}</p>
                                <p className="user-search-role">Role: {user.role}</p>
                            </div>
                        </div>
                    ))
                )}
            </div>

            <button className="button" onClick={() => setActiveScreen('CreatorDashboard')} style={{ backgroundColor: '#3A3A3A', color: '#FFF', marginTop: '30px' }}>
                <span className="buttonText">Back to Dashboard</span>
            </button>
        </div>
    );
};

// ===================== START: FULL COMPONENT REPLACEMENT =====================
const PremiumMembersScreen = ({ setActiveScreen, setSelectedUserId, showMessage }) => {
    const [allPremiumUsers, setAllPremiumUsers] = useState([]);
    const [searchTerm, setSearchTerm] = useState('');
    const [loading, setLoading] = useState(true);

    // This useEffect now runs once on load to get ALL premium users.
    useEffect(() => {
        const fetchPremiumUsers = async () => {
            setLoading(true);
            try {
                const creatorsRef = collection(db, "creators");
                const q = query(
                    creatorsRef,
                    where('premiumExpiresAt', '>', new Date()),
                    orderBy('premiumExpiresAt', 'desc')
                );

                const querySnapshot = await getDocs(q);
                const usersData = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                setAllPremiumUsers(usersData); // Store the full list

            } catch (error) {
                console.error("Error fetching premium members:", error);
                showMessage("Failed to load premium members list.");
            } finally {
                setLoading(false);
            }
        };

        fetchPremiumUsers();
    }, []);

    const viewProfile = (userId) => {
        setSelectedUserId(userId);
        setActiveScreen('UserProfile');
    };

    // This is NOT state. It's a derived value calculated on every render.
    // It filters the full list based on the current searchTerm state.
    const filteredUsers = allPremiumUsers.filter(user =>
        user.creatorName.toLowerCase().includes(searchTerm.toLowerCase())
    );

    if (loading) {
        return <div className="screenContainer"><p className="heading">Loading Premium Members...</p></div>;
    }

    return (
        <div className="screenContainer">
            <p className="heading">Premium Members</p>
            <p className="subHeading">A list of all users currently supporting the platform.</p>

            {/* This is the new real-time search/filter input */}
            <div className="formGroup" style={{ marginTop: '10px', marginBottom: '20px' }}>
                <input
                    type="text"
                    className="formInput"
                    placeholder="Filter by name..."
                    value={searchTerm}
                    onChange={(e) => setSearchTerm(e.target.value)}
                />
            </div>

            <div className="user-search-list">
                {allPremiumUsers.length === 0 ? (
                     <p className="dashboardItem" style={{textAlign: 'center'}}>There are currently no active premium members.</p>
                ) : filteredUsers.length === 0 ? (
                    <p className="dashboardItem" style={{textAlign: 'center'}}>No premium members match your filter "{searchTerm}".</p>
                ) : (
                    filteredUsers.map(user => (
                        <div key={user.id} className="user-search-item" style={{cursor: 'pointer'}} onClick={() => viewProfile(user.id)}>
                            <img src={user.profilePictureUrl || 'https://placehold.co/100x100/555/FFF?text=P'} alt={user.creatorName} className="user-search-pfp"/>
                            <div className="user-search-info">
                                <p className="user-search-name" style={{display: 'flex', alignItems: 'center'}}>
                                    {user.creatorName}
                                    <span style={{marginLeft: '10px', fontSize: '14px'}}></span>
                                </p>
                                <p className="user-search-role">
                                    Premium Expires: {new Date(user.premiumExpiresAt.toDate()).toLocaleDateString()}
                                </p>
                            </div>
                        </div>
                    ))
                )}
            </div>

            <button className="button" onClick={() => setActiveScreen('AdminDashboard')} style={{ backgroundColor: '#3A3A3A', color: '#FFF', marginTop: '30px' }}>
                <span className="buttonText">Back to Admin Dashboard</span>
            </button>
        </div>
    );
};


// --- UPDATED ANALYTICS DASHBOARD ---
        const AnalyticsDashboardScreen = ({ showMessage, setActiveScreen }) => {
    const [creators, setCreators] = useState([]);
    const [loading, setLoading] = useState(true);
    const [timeframe, setTimeframe] = useState('weekly'); // 'daily', 'weekly', 'lifetime'
    const [sortBy, setSortBy] = useState('views'); // 'views', 'likes'

    useEffect(() => {
        // Use a real-time listener to keep the dashboard live
        const creatorsQuery = query(collection(db, "creators"));
        const unsubscribe = onSnapshot(creatorsQuery, (snapshot) => {
            const creatorsData = snapshot.docs.map(d => ({ id: d.id, ...d.data() }));
            setCreators(creatorsData);
            setLoading(false);
        }, (error) => {
            console.error("Error fetching creator analytics:", error);
            showMessage("Failed to load analytics data.");
            setLoading(false);
        });
        return () => unsubscribe(); // Cleanup listener on component unmount
    }, []);

    const getMetric = (creator, metric) => {
        const field = `${timeframe}${metric.charAt(0).toUpperCase() + metric.slice(1)}`;
        return creator[field] || 0;
    };

    const sortedCreators = [...creators].sort((a, b) => {
        const metricA = getMetric(a, sortBy);
        const metricB = getMetric(b, sortBy);
        return metricB - metricA;
    });

    const renderMetricHeader = (metric) => (
        <th onClick={() => setSortBy(metric)} style={{cursor: 'pointer', textAlign: 'right'}}>
            {metric.charAt(0).toUpperCase() + metric.slice(1)} {sortBy === metric ? '' : ''}
        </th>
    );
    
    return (
        <div className="screenContainer">
            <p className="heading">Creator Analytics</p>
            <p className="subHeading">Real-time engagement metrics for all creators.</p>

            <div className="leaderboard-tabs" style={{justifyContent: 'space-between', marginBottom: '25px'}}>
                <div style={{display: 'flex', gap: '10px'}}>
                    <p style={{alignSelf: 'center', color: '#AAA'}}>Timeframe:</p>
                    <button className="button" onClick={() => setTimeframe('daily')} style={{backgroundColor: timeframe === 'daily' ? '#FFD700' : '#3A3A3A', color: timeframe === 'daily' ? '#0A0A0A' : '#FFF'}}>Daily</button>
                    <button className="button" onClick={() => setTimeframe('weekly')} style={{backgroundColor: timeframe === 'weekly' ? '#FFD700' : '#3A3A3A', color: timeframe === 'weekly' ? '#0A0A0A' : '#FFF'}}>Weekly</button>
                    <button className="button" onClick={() => setTimeframe('lifetime')} style={{backgroundColor: timeframe === 'lifetime' ? '#FFD700' : '#3A3A3A', color: timeframe === 'lifetime' ? '#0A0A0A' : '#FFF'}}>Lifetime</button>
                </div>
                 <button className="button" onClick={() => setActiveScreen('AdminDashboard')} style={{margin: 0, backgroundColor: '#555'}}>
                    <span className="buttonText">Back to Admin</span>
                </button>
            </div>

            <div className="dashboardSection">
                <p className="dashboardSectionTitle">Performance ({timeframe.charAt(0).toUpperCase() + timeframe.slice(1)})</p>
                {loading ? <p>Loading analytics...</p> : (
                    <table style={{width: '100%', borderCollapse: 'collapse'}}>
                        <thead>
                            <tr style={{borderBottom: '1px solid #FFD700'}}>
                                <th style={{textAlign: 'left', paddingBottom: '10px'}}>Creator</th>
                                {renderMetricHeader('views')}
                                {renderMetricHeader('likes')}
                            </tr>
                        </thead>
                        <tbody>
                            {sortedCreators.map(creator => (
                                <tr key={creator.id} style={{borderBottom: '1px solid #3A3A3A'}}>
                                    <td style={{padding: '10px 0', display: 'flex', alignItems: 'center', gap: '10px'}}>
                                        <img src={creator.profilePictureUrl || 'https://placehold.co/40x40/555/FFF?text=P'} alt={creator.creatorName} style={{width: '40px', height: '40px', borderRadius: '50%', objectFit: 'cover'}} />
                                        <span style={{fontWeight: 'bold'}}>{creator.creatorName}</span>
                                    </td>
                                    <td style={{textAlign: 'right', fontSize: '16px', fontWeight: 'bold', color: sortBy === 'views' ? '#FFD700' : '#FFF'}}>{getMetric(creator, 'views').toLocaleString()}</td>
                                    <td style={{textAlign: 'right', fontSize: '16px', fontWeight: 'bold', color: sortBy === 'likes' ? '#FFD700' : '#FFF'}}>{getMetric(creator, 'likes').toLocaleString()}</td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                )}
            </div>
        </div>
    );
};
        // REPLACE THE ENTIRE FollowingFeedScreen COMPONENT

const FollowingFeedScreen = ({ currentUser, setActiveScreen, showMessage, handleVideoPress }) => {
    const [loading, setLoading] = useState(true);
    const [feedItems, setFeedItems] = useState([]);

    useEffect(() => {
        if (!currentUser) return;
        const feedRef = collection(db, "creators", currentUser.uid, "feed");
        const q = query(feedRef, orderBy("createdAt", "desc"), limit(50));
        const unsubscribeFeed = onSnapshot(q, (feedSnapshot) => {
            const rawFeedItems = feedSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            const followingRef = collection(db, "creators", currentUser.uid, "following");
            getDocs(followingRef).then(followingSnapshot => {
                const followedIds = new Set(followingSnapshot.docs.map(doc => doc.id));
                // ALSO include the user's own ID in the set so they see their own posts.
                followedIds.add(currentUser.uid);
                const filteredItems = rawFeedItems.filter(item => followedIds.has(item.creatorId));
                setFeedItems(filteredItems);
                setLoading(false);
            });
        }, (error) => {
            console.error("Error fetching following feed: ", error);
            showMessage("Could not load your feed. Please try again.");
            setLoading(false);
        });
        return () => unsubscribeFeed();
    }, [currentUser]);

    if (loading) { return <div className="screenContainer" style={{ textAlign: 'center', paddingTop: '50px' }}><p className="heading">Loading Your Feed...</p></div>; }
    
    if (feedItems.length === 0) { return ( <div className="screenContainer" style={{ textAlign: 'center', paddingTop: '50px' }}><p className="heading">Your Feed is Empty</p><p className="subHeading">Follow creators to see their latest content here.</p><button className="button" onClick={() => setActiveScreen('DiscoverUsers')}><span className="buttonText">Discover Creators</span></button></div> ); }

    return (
        <div className="screenContainer">
            <p className="heading">Following</p>
            <div className="vertical-carousel-container" style={{ height: 'auto', maxHeight: 'calc(100vh - 250px)', overflowY: 'auto', scrollSnapType: 'none' }}>
                {feedItems.map((item) => (
                    // --- THIS IS THE FIX: Changed from <button> to <div> ---
                    <div key={item.id} className="vertical-carousel-item" style={{position: 'relative', cursor: 'pointer'}} onClick={() => handleVideoPress(item.embedUrl, item)}>
                        <img src={item.customThumbnailUrl} alt={item.title} className="liveFeedThumbnail" />
                        <div className="liveFeedContent">
                            <p className="liveFeedTitle">{item.title}</p>
                            <p className="liveFeedCreator">by {item.creatorName}</p>
                        </div>
                        {currentUser && <LikeButton contentItem={item} currentUser={currentUser} showMessage={showMessage} />}
                    </div>
                ))}
            </div>
        </div>
    );
};
// --- END OF NEW COMPONENT DEFINITIONS ---


        // ADD THIS ENTI-RE NEW COMPONENT DEFINITION

    const ContactScreen = ({ setActiveScreen, showMessage, currentUser }) => {
    const [socialLinks, setSocialLinks] = useState([]);
    const [isLoading, setIsLoading] = useState(true);
    const [mmgNumber, setMmgNumber] = useState('');
    const [userName, setUserName] = useState('');
    const [userEmail, setUserEmail] = useState('');
    const [queryType, setQueryType] = useState('General Question');
    const [message, setMessage] = useState('');
    const [isSubmitting, setIsSubmitting] = useState(false);

    useEffect(() => {
        if (currentUser) {
            // Note: displayName is not a field in the 'creators' collection, so we use creatorName
            // We need to fetch the profile to get the most accurate name.
            const userDocRef = doc(db, "creators", currentUser.uid);
            getDoc(userDocRef).then(docSnap => {
                if (docSnap.exists()) {
                    setUserName(docSnap.data().creatorName || currentUser.email.split('@')[0]);
                } else {
                    setUserName(currentUser.email.split('@')[0]);
                }
            });
            setUserEmail(currentUser.email);
        }

        const socialLinksDocRef = doc(db, "settings", "socialLinks");
        getDoc(socialLinksDocRef).then(docSnap => {
            if (docSnap.exists()) {
                const data = docSnap.data();
                  setMmgNumber(data.mmgNumber || '');
                if (data && Array.isArray(data.links)) {
                    const enabledLinks = data.links.filter(link => link.isEnabled === true);
                    setSocialLinks(enabledLinks);
                }
            }
            setIsLoading(false);
        }).catch(error => { setIsLoading(false); });
    }, [currentUser]);

    const handleSubmit = async (e) => {
        e.preventDefault();
        if (!userName || !userEmail || !message) {
            showMessage("Please fill in all required fields.");
            return;
        }
        if (!currentUser) {
            showMessage("You must be logged in to send a message.");
            setActiveScreen('Login');
            return;
        }
        
        setIsSubmitting(true);

        try {
            // Step 1: Check the user's last submission timestamp from their profile
            const userDocRef = doc(db, "creators", currentUser.uid);
            const userDocSnap = await getDoc(userDocRef);

            if (userDocSnap.exists()) {
                const userData = userDocSnap.data();
                if (userData.lastSubmissionTimestamp) {
                    const lastSubmitTime = userData.lastSubmissionTimestamp.toDate();
                    const twentyFourHoursAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);

                    // If the last submission was within the last 24 hours, block it.
                    if (lastSubmitTime > twentyFourHoursAgo) {
                        showMessage("You can only send one message every 24 hours. Please try again later.");
                        setIsSubmitting(false);
                        return;
                    }
                }
            }

            // Step 2: If the check passes, proceed with submitting the message
            showMessage("Submitting your message...");
            await addDoc(collection(db, "contactSubmissions"), {
                userName: userName,
                userEmail: userEmail,
                queryType: queryType,
                message: message,
                submittedAt: new Date().toISOString(),
                status: 'New',
                userId: currentUser.uid
            });

            // Step 3: After successful submission, update the user's timestamp on their profile
            await updateDoc(userDocRef, {
                lastSubmissionTimestamp: new Date()
            });

            showMessage("Your message has been sent successfully!");
            // Reset form for future use
            setMessage('');
            setQueryType('General Question');
        } catch (error) {
            console.error("Error submitting contact form:", error);
            showMessage(`An error occurred: ${error.message}`);
        } finally {
            setIsSubmitting(false);
        }
    };

    const SocialIcon = ({ url, svgPath, name }) => (
        <a href={url} target="_blank" rel="noopener noreferrer" title={name} style={{ color: '#FFD700' }}>
            <svg viewBox="0 0 24 24" style={{ width: '40px', height: '40px', fill: 'currentColor' }}>
                <path d={svgPath}></path>
            </svg>
        </a>
    );

    return (
        <div className="screenContainer">
            <p className="heading">Get In Touch</p>
            <p className="subHeading">Connect with us on social media or send us a message below.</p>

            <div className="dashboardSection">
                <p className="dashboardSectionTitle" style={{ textAlign: 'center' }}>Follow Us</p>
                {isLoading ? ( <p style={{ textAlign: 'center' }}>Loading social links...</p> ) : (
                    <div style={{ display: 'flex', justifyContent: 'center', gap: '20px', flexWrap: 'wrap', marginTop: '20px' }}>
                        {socialLinks.map(link => (
                            <SocialIcon key={link.name} url={link.url} svgPath={link.iconSvgPath} name={link.name} />
                        ))}
                    </div>
                )}
            </div>

            <div className="dashboardSection" style={{ marginTop: '20px' }}>
                <p className="dashboardSectionTitle">Send a Message</p>
                <form onSubmit={handleSubmit}>
                    <div className="formGroup">
                        <label htmlFor="contactName" className="formLabel">Your Name:</label>
                        <input type="text" id="contactName" className="formInput" value={userName} onChange={(e) => setUserName(e.target.value)} required />
                    </div>
                    <div className="formGroup">
                        <label htmlFor="contactEmail" className="formLabel">Your Email:</label>
                        <input type="email" id="contactEmail" className="formInput" value={userEmail} onChange={(e) => setUserEmail(e.target.value)} required />
                    </div>
                    <div className="formGroup">
                        <label htmlFor="contactQueryType" className="formLabel">Reason for Contact:</label>
                        <select id="contactQueryType" className="formInput" value={queryType} onChange={(e) => setQueryType(e.target.value)}>
                            <option>General Question</option>
                            <option>Bug Report</option>
                            <option>Partnership Inquiry</option>
                            <option>Feedback & Suggestions</option>
                        </select>
                    </div>
                    <div className="formGroup">
                        <label htmlFor="contactMessage" className="formLabel">Message:</label>
                        <textarea id="contactMessage" className="formTextarea" value={message} onChange={(e) => setMessage(e.target.value)} required></textarea>
                    </div>
                    <button type="submit" className="button" disabled={isSubmitting}>
                        <span className="buttonText">{isSubmitting ? 'Sending...' : 'Send Message'}</span>
                    </button>
                </form>
            </div>
        </div>
    );
};

const VerificationScreen = ({ currentUser, showMessage, handleLogout, setActiveScreen }) => {
    const [isSending, setIsSending] = useState(false);
    const [isChecking, setIsChecking] = useState(false);
    const handleResend = async () => {
        if (!currentUser) return;
        setIsSending(true);
        showMessage("Resending verification email...");
        try {
            await sendEmailVerification(currentUser);
            showMessage("A new verification email has been sent.");
        } catch (error) {
            console.error("Error resending verification email:", error);
            showMessage("Failed to resend email. Please try again in a few moments.");
        } finally { setIsSending(false); }
    };
    const handleCheckVerification = async () => {
        if (!currentUser) return;
        setIsChecking(true);
        await currentUser.reload();
        if (auth.currentUser.emailVerified) {
            showMessage("Thank you for verifying! Redirecting...");
            setActiveScreen('CreatorDashboard');
        } else {
            showMessage("Email has not been verified yet. Please click the link in your email.");
        }
        setIsChecking(false);
    };
    return (
        <div className="screenContainer" style={{textAlign: 'center', paddingTop: '50px'}}>
            <p className="heading">Please Verify Your Email</p>
            <p className="subHeading">A verification link has been sent to: <br/><strong style={{color: '#FFD700'}}>{currentUser?.email}</strong></p>
            <p className="paragraph">Please check your inbox (and spam folder) and click the link to activate your account.</p>
            <button className="button" onClick={handleCheckVerification} disabled={isChecking}><span className="buttonText">{isChecking ? 'Checking...' : 'I Have Verified My Email'}</span></button>
            <p className="smallText" style={{marginTop: '20px'}}>Didn't receive an email?</p>
            <button className="button" onClick={handleResend} disabled={isSending} style={{backgroundColor: '#3A3A3A'}}><span className="buttonText">{isSending ? 'Sending...' : 'Resend Verification Email'}</span></button>
            <button className="button" onClick={handleLogout} style={{backgroundColor: '#555', marginTop: '40px'}}><span className="buttonText">Logout</span></button>
        </div>
    );
};
            
// ======================================================================
// --- Your App component should start on the very next line ---
// ======================================================================
        

        function App() {

// =========== START REPLACEMENT ===========
            const [currentUser, setCurrentUser] = useState(null);
            // NOTE: Replace this placeholder URL with the actual URL of your hosted notification sound file.
            const notificationSoundRef = useRef(new Audio('https://firebasestorage.googleapis.com/v0/b/nvanetworkapp.firebasestorage.app/o/Notification%202.mp3?alt=media&token=0befabd3-3c9d-4aa4-a990-5681591d201a'));
            const [activeScreen, setActiveScreen] = useState('Home');
            const [pledgeContext, setPledgeContext] = useState(null);
            const [pledgeIdForConfirmation, setPledgeIdForConfirmation] = useState(null);
            const [canExit, setCanExit] = useState(false);
            const exitTimer = useRef(null);
            const [showMoreMenu, setShowMoreMenu] = useState(false);
            
            // ======================= START: NEW CODE =======================
            // Call our new hook to get a live list of notifications
            const { notifications: unreadNotifications, isLoading: notificationsLoading, dismissNotification, markBroadcastAsSeen, markNotificationAsRead } = 
            useNotifications(currentUser);
            // ======================== END: NEW CODE ========================
            
              // ======================= START: NEW TOAST STATE AND LOGIC =======================
            const [toastQueue, setToastQueue] = useState([]);
            const [currentToast, setCurrentToast] = useState(null);
            const processedToastIds = useRef(new Set());

            useEffect(() => {
                // This effect now correctly filters for notifications that are NOT marked as read.
                const newNotifications = unreadNotifications.filter(n => !processedToastIds.current.has(n.id) && n.isRead === false);
                if (newNotifications.length > 0) {
                    setToastQueue(prev => [...prev, ...newNotifications]);
                    newNotifications.forEach(n => processedToastIds.current.add(n.id));
                }
            }, [unreadNotifications]);

            useEffect(() => {
                // Process the toast queue
                if (!currentToast && toastQueue.length > 0) {
                    const nextToast = toastQueue[0];
                    setCurrentToast(nextToast);
                    setToastQueue(prev => prev.slice(1));
                    // Play the notification sound
                    if (notificationSoundRef.current) {
                        notificationSoundRef.current.play().catch(error => {
                            // This catch block gracefully handles the browser's autoplay policy
                            // without crashing the app. It's expected to trigger on the first notification.
                            console.log("Audio play was blocked by the browser, which is expected on first load. Sound will play on subsequent notifications after user interaction.");
                        });
                    }
                    // THE DEFINITIVE FIX:
                    // If it's a broadcast, mark it as "seen" in its own subcollection.
                    if (nextToast.isBroadcast) {
                        markBroadcastAsSeen(nextToast.id);
                    // If it's a private notification, update its document to set isRead = true.
                    } else {
                        markNotificationAsRead(nextToast.id);
                    }
                }
            }, [currentToast, toastQueue, markBroadcastAsSeen, markNotificationAsRead]);

            // This function now ONLY handles clicks, for navigation.
            const handleToastClick = () => {
                if(currentToast?.link) {
                    const screen = currentToast.link.replace('/', '');
                    setActiveScreen(screen);
                }
                setCurrentToast(null);
            };
            
            // This function handles the timeout, ONLY dismissing the toast.
            const handleToastTimeout = () => {
                setCurrentToast(null);
            };
// END of REPLACEMENT Block

            const [activeCategory, setActiveCategory] = useState('Skits');
            const [message, setMessage] = useState('');
            const [showVideoModal, setShowVideoModal] = useState(false);
            const [currentVideoUrl, setCurrentVideoUrl] = useState('');
            const isInitialLoad = useRef(true);
// =========== END REPLACEMENT ===========

             // This effect MANAGES the back button and history stack.
            useEffect(() => {
                const handlePopState = (event) => {
                    // The #1 priority is the modal. If it's open, the back button should ONLY close it.
                    if (showVideoModal) {
                        setShowVideoModal(false);
                        setCurrentVideoUrl('');
                        return;
                    }

                    // If the modal is not open, check if we are on the Home screen.
                    if (activeScreen === 'Home') {
                         if (canExit) {
                            // If they already pressed once, allow the app to close.
                            window.history.back();
                            return;
                        }

                        // First press on the Home screen: prevent exit and show message.
                        showMessage('Press back again to exit.');
                        setCanExit(true);
                        window.history.pushState({ screen: 'Home' }, ''); // Re-add 'Home' to history
                        
                        exitTimer.current = setTimeout(() => setCanExit(false), 2000); // 2-sec window
                        return;
                    }

                    // If we're on any other screen, perform normal back navigation.
                    if (event.state?.screen) {
                        clearTimeout(exitTimer.current);
                        setCanExit(false);
                        setActiveScreen(event.state.screen);
                    }
                };
                
                window.addEventListener('popstate', handlePopState);
                return () => {
                    window.removeEventListener('popstate', handlePopState);
                    clearTimeout(exitTimer.current);
                };
            }, [activeScreen, canExit, showVideoModal]); // This hook is now aware of all relevant states.

            // This effect PUSHES to the history stack when navigating FORWARD.
            useEffect(() => {
                if (window.history.state?.screen !== activeScreen) {
                    window.history.pushState({ screen: activeScreen }, '');
                }
            }, [activeScreen]);

            // This effect handles pushing a state when the video modal opens.
            useEffect(() => {
                if (showVideoModal) {
                    // Push a generic state to represent the modal being open.
                    // This allows the back button to have an entry to "pop".
                    window.history.pushState({ modal: 'video' }, '');
                }
            }, [showVideoModal]);
            // --- END: Comprehensive History, Navigation, and Modal Management Logic ---
            
            const [currentContentItem, setCurrentContentItem] = useState(null);
            const [showImageAdjustModal, setShowImageAdjustModal] = useState(false);
            const [imageFileToAdjust, setImageFileToAdjust] = useState(null);
            const [isUploadingPFP, setIsUploadingPFP] = useState(false);    
            const [creatorProfile, setCreatorProfile] = useState(null);
            const [authLoading, setAuthLoading] = useState(true);
            
            const [selectedCampaignId, setSelectedCampaignId] = useState(null);
            const [selectedUserId, setSelectedUserId] = useState(null);

            // New state for admin-selected campaign details
            const [selectedAdminCampaignId, setSelectedAdminCampaignId] = useState(null);
            const [selectedAdminSubScreen, setSelectedAdminSubScreen] = useState('Overview'); // 'Overview', 'ContentManagement'


            // New state variables for custom confirmation modal
            const [showConfirmationModal, setShowConfirmationModal] = useState(false);
            const [confirmationTitle, setConfirmationTitle] = useState('');
            const [confirmationMessage, setConfirmationMessage] = useState('');
            const [onConfirmationAction, setOnConfirmationAction] = useState(null);
            const [featuredContentSlots, setFeaturedContentSlots] = useState(null);
            // --- MOVED FROM CategoriesScreen to App (GLOBAL STATE) ---
            const [isLive, setIsLive] = useState(false);
            const [countdownText, setCountdownText] = useState('');
            const [liveThumbnail, setLiveThumbnail] = useState('');

           // --- PASTE THIS ENTIRE CORRECTED BLOCK ---

useEffect(() => {
    let unsubscribeProfile = () => {};
    const unsubscribeAuth = onAuthStateChanged(auth, (user) => {
        setAuthLoading(true);
        setCurrentUser(user);
        unsubscribeProfile();
        if (user) {
            const creatorDocRef = doc(db, "creators", user.uid);
            unsubscribeProfile = onSnapshot(creatorDocRef, async (docSnap) => {
                if (!docSnap.exists()) {
                    await setDoc(creatorDocRef, { email: user.email, creatorName: user.email.split('@')[0] || "", createdAt: new Date().toISOString(), role: 'user', banned: false, followerCount: 0, followingCount: 0 });
                } else {
                    const profileData = docSnap.data();
                    if (profileData.banned) {
                        showMessage("Your account has been banned.");
                        signOut(auth);
                    } else {
                        setCreatorProfile(profileData);
                    }
                }
                setAuthLoading(false);
            }, (error) => {
                console.error("Profile listener error:", error);
                signOut(auth);
                setAuthLoading(false);
            });
        } else {
            setCreatorProfile(null);
            setAuthLoading(false);
        }
    });
    return () => {
        unsubscribeAuth();
        unsubscribeProfile();
    };
}, []); // This empty array is correct.

            useEffect(() => {
            const slotsDocRef = doc(db, "settings", "featuredContentSlots");
            const unsubscribe = onSnapshot(slotsDocRef, (docSnap) => {
                if (docSnap.exists()) {
            setFeaturedContentSlots(docSnap.data());
                } else {
            setFeaturedContentSlots(null);
                }
                });
            return () => unsubscribe(); // Cleanup listener
            }, []);
           
            // --- NEW GLOBAL useEffect for Countdown Logic ---
            useEffect(() => {
    const categoriesRef = collection(db, "content_categories");
    const q = query(categoriesRef, where("name", "==", "Live Premieres"));
    let countdownInterval = null;

    const unsubscribe = onSnapshot(q, (snapshot) => {
    console.log('%cLive Premieres data updated in Firestore.', 'color: cyan; font-weight: bold;');
        clearInterval(countdownInterval);

        if (snapshot.empty) {
            setIsLive(false);
            setCountdownText('');
            setLiveThumbnail(''); // Clear thumbnail
            return;
        }

        const liveDocData = snapshot.docs[0].data();
        const startTime = liveDocData.liveStreamStartTime ? liveDocData.liveStreamStartTime.toDate() : null;
        const liveUrl = liveDocData.liveStreamUrl || '';
        setLiveThumbnail(liveDocData.liveStreamThumbnailUrl || ''); // Get thumbnail

        if (!startTime) {
            setIsLive(false);
            setCountdownText('');
            return;
        }

        countdownInterval = setInterval(() => {
            const now = new Date();
            const distance = startTime - now;

            if (distance < 0) {
                clearInterval(countdownInterval);
                setCountdownText('');
                setIsLive(liveUrl.trim() !== '');
            } else {
                setIsLive(false);
                const days = Math.floor(distance / (1000 * 60 * 60 * 24));
                const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((distance % (1000 * 60)) / 1000);
                
                let parts = [];
                if (days > 0) parts.push(`${days}d`);
                if (hours > 0) parts.push(`${hours}h`);
                if (minutes > 0) parts.push(`${minutes}m`);
                if (days === 0 && hours === 0 && minutes < 1) parts.push(`${seconds}s`);
                else if(days === 0 && hours === 0) parts.push(`${minutes}m`);

                setCountdownText(parts.join(' '));
            }
        }, 1000);
    });

    return () => {
        unsubscribe();
        clearInterval(countdownInterval);
    };
}, []);

            
            const originalCarouselImages = [
                'https://placehold.co/140x100/A0A0A0/000?text=Comedy+Night',
                'https://placehold.co/140x100/808080/FFF?text=New+Series',
                'https://placehold.co/140x100/606060/EEE?text=Exclusive',
                'https://placehold.co/140x100/404040/DDD?text=Behind+Scenes',
                'https://placehold.co/140x100/202020/CCC?text=Live+Event',
            ];
            const carouselImages = [...originalCarouselImages, ...originalCarouselImages, ...originalCarouselImages];

            const originalLiveFeedContent = [
                { id: 'lf1', title: 'New Comedy Skit: Dem Boys', creator: 'Street Jokes GY', thumbnail: 'https://placehold.co/80x60/808080/FFF?text=Skit1', url: 'https://www.youtube.com/embed/SKIT_LIVE_1?autoplay=1' },
                { id: 'lf2', title: 'Interview: Rising Star', creator: 'NVA Insights', thumbnail: 'https://placehold.co/80x60/A0A0A0/000?text=Int1', url: 'https://www.youtube.com/embed/INTERVIEW_LIVE_2?autoplay=1' },
                { id: 'lf3', title: 'Short Film Trailer: Lost Gold', creator: 'Guyana Films', thumbnail: 'https://placehold.co/80x60/606060/EEE?text=Film1', url: 'https://www.youtube.com/embed/FILM_LIVE_3?autoplay=1' },
                { id: 'lf4', title: 'Live Music Session: Reggae Vibes', creator: 'Riddim Makers', thumbnail: 'https://placehold.co/80x60/404040/DDD?text=Music1', url: 'https://www.youtube.com/embed/MUSIC_LIVE_4?autoplay=1' },
                { id: 'lf5', title: 'Behind The Scenes: Drama Shoot', creator: 'Creative Minds', thumbnail: 'https://placehold.co/80x60/202020/CCC?text=BTS1', url: 'https://www.youtube.com/embed/BTS_LIVE_5?autoplay=1' },
                { id: 'lf6', title: 'Daily Vlog: Life in Georgetown', creator: 'GT Vlogger', thumbnail: 'https://placehold.co/80x60/909090/111?text=Vlog1', url: 'https://www.youtube.com/embed/VLOG_LIVE_6?autoplay=1' },
            ];
            const liveFeedItems = [...originalLiveFeedContent, ...originalLiveFeedContent, ...originalLiveFeedContent];


            const showMessage = (msg) => {
                setMessage(msg);
                setTimeout(() => setMessage(''), 3000);
            };

          // --- UPDATED CLICK HANDLING LOGIC ---
            const handleVideoPress = (url, contentItem) => {
            if (!currentUser) {
            showMessage("Please sign up or log in to engage with content!");
        return;
            }
            setCurrentVideoUrl(url);
            setCurrentContentItem(contentItem); // Remember which item was clicked
            setShowVideoModal(true);
            };
            const closeVideoModal = () => {
                // If the modal is open, pressing 'X' should be the same as going "back" once in history.
                if (showVideoModal) {
                    window.history.back();
                }
                setShowVideoModal(false);
                setCurrentVideoUrl('');
            };

            const handleLogout = async () => {
                try {
                    await signOut(auth);
                    showMessage('Logged out successfully!');
                    setActiveScreen('Home');
                } catch (error) {
                    console.error("Error logging out:", error);
                    showMessage('Failed to log out. Please try again.');
                }
            };

                // REPLACE THE ENTIRE HomeScreen COMPONENT

               const HomeScreen = ({ currentUser, showMessage, handleVideoPress, handleLogout, featuredContentSlots }) => {
        const [enrichedLayout, setEnrichedLayout] = useState({ featured: [], trending: [] });
        const [displayFeatured, setDisplayFeatured] = useState([]); 
        const [displayLiveFeed, setDisplayLiveFeed] = useState([]); 
        const horizontalCarouselRef = useRef(null);
        const verticalCarouselRef = useRef(null);
        
        // Corrected loading state management
        const [isLayoutLoading, setIsLayoutLoading] = useState(true);
        const [isLiveFeedLoading, setIsLiveFeedLoading] = useState(true);
        const loading = isLayoutLoading || isLiveFeedLoading; // Overall loading is true if any part is loading

        // This is our combined data-fetching logic that now handles loading state correctly.
        useEffect(() => {
            const layoutDocRef = doc(db, "settings", "homeScreenLayout");
            const liveFeedQuery = query(collection(db, `artifacts/${appId}/public/data/content_items`), where('contentType', '==', 'Live Feed'), where('isActive', '==', true), orderBy('createdAt', 'desc'), limit(20));
            let cachedData = { layout: null, autoSlots: featuredContentSlots };

            const processManualContent = async () => {
                if (cachedData.layout === null || cachedData.autoSlots === null) return;
                const manualTrending = cachedData.layout.trendingItems || [];
                const autoSlots = [cachedData.autoSlots.slot_1, cachedData.autoSlots.slot_2, cachedData.autoSlots.slot_3]
                    .filter(slot => slot && slot.content).map(slot => ({ type: 'internal', contentId: slot.content.id, isAuto: true, orderIndex: -1 }));
                const manualTrendingIds = new Set(manualTrending.filter(i => i.type === 'internal').map(i => i.contentId));
                const uniqueAutoSlots = autoSlots.filter(slot => !manualTrendingIds.has(slot.contentId));
                const combinedTrending = [...uniqueAutoSlots, ...manualTrending];
                const allItems = { featured: cachedData.layout.featuredItems || [], trending: combinedTrending };
                const contentIds = [...new Set(Object.values(allItems).flat().filter(i => i.type === 'internal' && i.contentId).map(i => i.contentId))];
                const promises = contentIds.map(id => getDoc(doc(db, `artifacts/${appId}/public/data/content_items`, id)).catch(() => null));
                const docSnapshots = await Promise.all(promises);
                const allContentData = docSnapshots.filter(snap => snap && snap.exists()).map(snap => ({id: snap.id, ...snap.data()}));
                const contentMap = new Map(allContentData.map(c => [c.id, c]));
                const enrich = (items) => items.map(item => {
                    if (item.type === 'internal') return contentMap.has(item.contentId) ? { ...item, ...contentMap.get(item.contentId) } : null;
                    return item;
                }).filter(Boolean).sort((a,b) => (a.orderIndex || 99) - (b.orderIndex || 99));
                
                const finalLayout = { featured: enrich(allItems.featured), trending: enrich(allItems.trending) };
                setEnrichedLayout(finalLayout);

                const numFeaturedClones = 3;
                if (finalLayout.featured.length > numFeaturedClones) {
                    setDisplayFeatured([...finalLayout.featured, ...finalLayout.featured.slice(0, numFeaturedClones)]);
                } else {
                    setDisplayFeatured(finalLayout.featured);
                }
                setIsLayoutLoading(false); // Set layout loading to false
            };

            const unsubLiveFeed = onSnapshot(liveFeedQuery, (snapshot) => {
                const liveItems = snapshot.docs.map(d => ({ id: d.id, ...d.data() }));
                const numLiveFeedClones = 4;
                if (liveItems.length > numLiveFeedClones) setDisplayLiveFeed([...liveItems, ...liveItems.slice(0, numLiveFeedClones)]);
                else setDisplayLiveFeed(liveItems);
                setIsLiveFeedLoading(false); // Set live feed loading to false
            });
            
            const unsubLayout = onSnapshot(layoutDocRef, (docSnap) => {
                cachedData.layout = docSnap.exists() ? docSnap.data() : { featuredItems: [], trendingItems: [] };
                processManualContent();
            });
            
            cachedData.autoSlots = featuredContentSlots || { slot_1: null, slot_2: null, slot_3: null };
            processManualContent();
            return () => { unsubLayout(); unsubLiveFeed(); };
        }, [featuredContentSlots]);

        // This is YOUR restored, working carousel animation logic.
                // This is YOUR old, working carousel animation logic, restored.
        // This is the definitive, zoom-resilient, perpetual carousel animation logic.
        useEffect(() => {
            const horizontalCarousel = horizontalCarouselRef.current;
            const verticalCarousel = verticalCarouselRef.current;
            let horizontalInterval;
            let verticalInterval;

            const startHorizontalAutoscroll = () => {
                if (!horizontalCarousel || !horizontalCarousel.children[0] || displayFeatured.length <= 3) {
                    clearInterval(horizontalInterval);
                    return;
                }
                const itemWidth = horizontalCarousel.children[0].offsetWidth + 15;
                if (itemWidth <= 15) return;

                const originalItemCount = displayFeatured.length - 3;
                const originalContentWidth = originalItemCount * itemWidth;

                horizontalInterval = setInterval(() => {
                    // THE FIX: Subtract 1 pixel as a buffer for floating-point rounding errors.
                    // This ensures the condition passes even if the scrollLeft is 1199.99 instead of 1200.
                    if (horizontalCarousel.scrollLeft >= originalContentWidth - 1) {
                        horizontalCarousel.scrollTo({ left: 0, behavior: 'instant' });
                    } else {
                        horizontalCarousel.scrollBy({ left: itemWidth, behavior: 'smooth' });
                    }
                }, 3000);
            };

            const startVerticalAutoscroll = () => {
                if (!verticalCarousel || !verticalCarousel.children[0] || displayLiveFeed.length <= 4) {
                    clearInterval(verticalInterval);
                    return;
                }
                const itemHeight = verticalCarousel.children[0].offsetHeight + 15;
                if (itemHeight <= 15) return;

                const originalItemCount = displayLiveFeed.length - 4;
                const originalContentHeight = originalItemCount * itemHeight;

                verticalInterval = setInterval(() => {
                    // THE FIX: Applied to the vertical carousel as well for robustness.
                    if (verticalCarousel.scrollTop >= originalContentHeight - 1) {
                        verticalCarousel.scrollTo({ top: 0, behavior: 'instant' });
                    } else {
                        verticalCarousel.scrollBy({ top: itemHeight, behavior: 'smooth' });
                    }
                }, 3000);
            };

            // Clear any existing intervals before starting new ones.
            clearInterval(horizontalInterval);
            clearInterval(verticalInterval);

            // Start the animations after the component has loaded.
            if (!loading) {
                setTimeout(() => {
                    startHorizontalAutoscroll();
                    startVerticalAutoscroll();
                }, 100);
            }

            // Cleanup function to run when the component unmounts.
            return () => {
                clearInterval(horizontalInterval);
                clearInterval(verticalInterval);
            };
        }, [loading, displayFeatured, displayLiveFeed]);
        const handleHorizontalScroll = (direction) => {
            const carousel = horizontalCarouselRef.current;
            if (carousel) {
                const itemWidth = carousel.children[0]?.offsetWidth + 15;
                carousel.scrollBy({ left: direction === 'prev' ? -itemWidth : itemWidth, behavior: 'smooth' });
            }
        };
        const handleVerticalScroll = (direction) => {
            const carousel = verticalCarouselRef.current;
            if (carousel) {
                const itemHeight = carousel.children[0]?.offsetHeight + 15;
                carousel.scrollBy({ top: direction === 'up' ? -itemHeight : itemHeight, behavior: 'smooth' });
            }
        };
         const handleItemClick = (item) => {
    // This initial login check remains the same
    if (!currentUser) {
        showMessage("Please sign up or log in to engage with content!");
        return;
    }

    // This is the new, smarter logic:
    let urlToTest;
    if (item.type === 'external') {
        urlToTest = item.externalLink;
    } else {
        // This handles items from the Live Feed and any other 'internal' content
        urlToTest = item.mainUrl || item.url;
    }

    if (!urlToTest) {
        showMessage("This item has no valid link to play.");
        return;
    }

    // Now, we test the URL, regardless of its original type
    const { embedUrl } = extractVideoInfo(urlToTest);

    if (embedUrl) {
        // If we found an embeddable URL, play it in the app!
        handleVideoPress(embedUrl, item);
    } else {
        // If it's not embeddable, and it was an external link, open it externally.
        // Otherwise, show an error.
        if (item.type === 'external') {
             window.open(urlToTest, '_blank');
        } else {
             showMessage("This video cannot be played in-app. It might be from an unsupported source.");
        }
    }
};
// --- END OF FINAL handleItemClick FUNCTION
        return (
            <div className="screenContainer">
                <div style={{
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center'
                }}>
                    <p className="sectionTitle" style={{ margin: 0, fontSize: '18px', marginTop: '20px' }}>Featured Highlights</p>
                    <div className="topRightButtonContainer" style={{ position: 'static', top: 'auto', right: 'auto' }}>
                        {currentUser && (<button className="topButton" onClick={() => setActiveScreen('TopCreators')}>Top Creators</button>)}
                        <button className="topButton" onClick={() => setActiveScreen('Support')}>Support Us</button>
                        {currentUser ? (<button className="topButton" onClick={handleLogout}>Logout</button>) : (<button className="topButton" onClick={() => setActiveScreen('Login')}>Login</button>)}
                    </div>
                </div>
                <div className="carousel-wrapper">
                    {displayFeatured.length > 3 && (
                        <>
                            <button className="carousel-nav-btn prev-horizontal" onClick={() => handleHorizontalScroll('prev')}></button>
                            <button className="carousel-nav-btn next-horizontal" onClick={() => handleHorizontalScroll('next')}></button>
                        </>
                    )}
                    <div className="horizontal-carousel-container" ref={horizontalCarouselRef}>
                        {loading ? Array.from({ length: 5 }).map((_, i) => <div key={i} className="horizontal-carousel-item" style={{ backgroundColor: '#2A2A2A' }}></div>)
                        : displayFeatured.map((item, index) => (
                            <div key={`${item.id}-${index}`} className="horizontal-carousel-item" onClick={() => handleItemClick(item)} style={{cursor: 'pointer'}}>
                                <img src={item.customThumbnailUrl || item.imageUrl} alt={item.title} className="carousel-image" />
                                {currentUser && item.id && <LikeButton contentItem={item} currentUser={currentUser} showMessage={showMessage} />}
                            </div>
                        ))}
                    </div>
                </div>
                <div className="sectionHeaderWithButton">
                    <p className="sectionTitle" style={{ marginBottom: '0' }}>Trending</p>
                    {!currentUser && <div style={{display: 'flex', gap: '10px'}}><button className="sectionHeaderButton" onClick={() => setActiveScreen('UserSignUp')}>User Sign Up</button><button className="sectionHeaderButton" onClick={() => setActiveScreen('CreatorSignUp')}>Creator Sign Up</button></div>}
                </div>
                {loading ? <p>Loading trending...</p> : (
                    <div className="contentGrid">
                    {enrichedLayout.trending.map((item) => {
                        
                        // --- ADD THIS CONSOLE.LOG LINE ---
                        console.log("Rendering Trending Item:", item);

                        return ( // The return statement was implicitly there, now we make it explicit
                            <div key={item.id || item.title} className="contentCard" onClick={() => handleItemClick(item)}>
                                <div className="thumbnailPlaceholder" style={{backgroundImage: `url(${item.customThumbnailUrl || item.imageUrl})`, backgroundSize: 'cover', backgroundPosition: 'center', position: 'relative'}}>
                                    <svg className="playIcon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
                                    
                                    {currentUser && item.id && <LikeButton contentItem={item} currentUser={currentUser} showMessage={showMessage} />}
                                    
                                </div>
                                <p className="contentTitle">{item.title}</p>
                                {/* --- ADD THIS BLOCK to display view count --- */}
                                <div style={{ padding: '0 10px 10px 10px', display: 'flex', alignItems: 'center', gap: '5px', color: '#AAA', fontSize: '12px' }}>
                                <svg viewBox="0 0 24 24" style={{ width: '16px', height: '16px', fill: 'currentColor' }}><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5C21.27 7.61 17 4.5 12 4.5zm0 10c-2.48 0-4.5-2.02-4.5-4.5S9.52 5.5 12 5.5s4.5 2.02 4.5 4.5-2.02 4.5-4.5 4.5zM12 8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"></path></svg>
                                <span>{item.viewCount || 0} views</span>
                                </div>
                            </div>
                        );
                    })}
                </div>
                )}
                <div className="sectionHeaderWithButton">
                    <p className="sectionTitle" style={{ marginBottom: '0' }}>Live Feed</p>
                    {currentUser && <div style={{display: 'flex', gap: '10px'}}><button className="sectionHeaderButton" onClick={() => setActiveScreen('DiscoverUsers')}>Find Creators</button><button className="sectionHeaderButton" onClick={() => setActiveScreen('Discover')}>Discover All</button></div>}
                </div>
                <div className="carousel-wrapper">
                    {displayLiveFeed.length > 2 && ( <> <button className="carousel-nav-btn prev-vertical" onClick={() => handleVerticalScroll('up')}></button> <button className="carousel-nav-btn next-vertical" onClick={() => handleVerticalScroll('down')}></button> </> )}
                    <div className="vertical-carousel-container" ref={verticalCarouselRef}>
                        {displayLiveFeed.map((item, index) => (
                            <div key={item.id ? `${item.id}-${index}` : `${item.title}-${index}`} className="vertical-carousel-item" style={{position: 'relative', cursor: 'pointer'}} onClick={() => handleItemClick(item)}>
                                <img src={item.customThumbnailUrl || item.imageUrl} alt={item.title} className="liveFeedThumbnail" />
                                <div className="liveFeedContent">
                                    <p className="liveFeedTitle">{item.title}</p>
                                    <p className="liveFeedCreator">{item.type === 'internal' ? `by ${item.creatorName}` : 'Promotion'}</p>
                                 <div style={{ display: 'flex', alignItems: 'center', gap: '5px', color: '#AAA', fontSize: '12px', marginTop: '4px' }}>
                                <svg viewBox="0 0 24 24" style={{ width: '16px', height: '16px', fill: 'currentColor' }}><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5C21.27 7.61 17 4.5 12 4.5zm0 10c-2.48 0-4.5-2.02-4.5-4.5S9.52 5.5 12 5.5s4.5 2.02 4.5 4.5-2.02 4.5-4.5 4.5zM12 8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"></path></svg>
                                <span>{item.viewCount || 0} views</span>
                                </div>
                                </div>
                                {currentUser && item.id && <LikeButton contentItem={item} currentUser={currentUser} showMessage={showMessage} />}
                            </div>
                        ))}
                    </div>
                </div>
            </div>
        );
    };


            // =========== START REPLACEMENT ===========
            const PremiumScreen = ({ showMessage, currentUser, setActiveScreen, setPledgeContext }) => {
                const [monetizationSettings, setMonetizationSettings] = useState({
                    premiumPrice: 1.99,
                    ticketPrice: 5.00,
                    isTicketedEvent: false
                });
                const [loading, setLoading] = useState(true);

                useEffect(() => {
                    const settingsDocRef = doc(db, "settings", "socialLinks");
                    const unsubscribe = onSnapshot(settingsDocRef, (docSnap) => {
                        if (docSnap.exists()) {
                            const data = docSnap.data();
                            setMonetizationSettings({
                                premiumPrice: data.premiumPrice || 1.99,
                                ticketPrice: data.ticketPrice || 5.00,
                                isTicketedEvent: data.isTicketedEvent || false
                            });
                        }
                        setLoading(false);
                    });
                    return () => unsubscribe();
                }, []);

                const handlePledge = (type) => {
                    if (!currentUser) {
                        showMessage("Please log in or sign up to continue.");
                        setActiveScreen('Login');
                        return;
                    }
                    if (type === 'eventTicket' && !monetizationSettings.isTicketedEvent) {
                        showMessage("There is no ticketed event currently available for purchase.");
                        return;
                    }

                    const context = type === 'premium' 
                        ? { type: 'premium', amount: monetizationSettings.premiumPrice }
                        : { 
                            type: 'eventTicket',
                            amount: monetizationSettings.ticketPrice,
                            // These fields can be expanded later
                            targetEventId: 'LivePremiere_General', 
                            targetEventTitle: "Live Premiere Event"
                          };
                    
                    if (type === 'premium' || type === 'eventTicket') {
                         setPledgeContext(context);
                         setActiveScreen('SubscriptionPledge');
                    }
                };

                return (
                    <div className="screenContainer">
                        <p className="heading">NVA Network Premium Access</p>
                        <p className="subHeading">Choose how you want to experience our exclusive content.</p>

                        <div className="premiumFeatureCard" style={{border: '1px solid #FFD700'}}>
                            <p className="premiumFeatureTitle">Premium Subscription</p>
                            <p className="premiumFeatureDescription">Get access to **all** ticketed live events, enjoy ad-free viewing, and receive exclusive perks. The best value for dedicated fans.</p>
                            <button className="button" style={{marginTop: '15px'}} onClick={() => handlePledge('premium')}>
                                <span className="buttonText">Purchase Subscription</span>
                            </button>
                        </div>

                         <div className="premiumFeatureCard" style={{border: '1px solid #CCC'}}>
                             <p className="premiumFeatureTitle" style={{color: '#CCC'}}>Single Event Ticket</p>
                            {loading ? (<p className="premiumFeatureDescription">Loading...</p>) : monetizationSettings.isTicketedEvent ? (
                                <>
                                    <p className="premiumFeatureDescription">Purchase a single-use ticket for our next live premiere event.</p>
                                    {/* --- START: MODIFIED BUTTON STYLE --- */}
                                    <button 
                                        className="button" 
                                        style={{
                                            marginTop: '15px', 
                                            backgroundColor: '#0A0A0A', 
                                            border: '1px solid #FFD700'
                                        }} 
                                        onClick={() => handlePledge('eventTicket')}
                                    >
                                        <span className="buttonText" style={{color: '#FFD700'}}>Buy Ticket</span>
                                    </button>
                                    {/* --- END: MODIFIED BUTTON STYLE --- */}
                                </>
                            ) : (<p className="premiumFeatureDescription">There are no new ticketed events scheduled at this time. Please check back later!</p>)}
                        </div>
                    </div>
                );
            };
// =========== END REPLACEMENT ===========

            const AboutContactScreen = () => (
                <div className="screenContainer">
                    <p className="heading">About NVA Network</p>
                    <p className="subHeading">The Caribbeans first mobile-first entertainment network, dedicated to bringing the best of Guyanese content to a global stage.</p>

                    <p className="paragraph">
                        NVA Network is committed to empowering local creators and connecting audiences worldwide
                        with unique and vibrant stories from Guyana. Our mission is to provide a platform for Guyanese
                        comedians, filmmakers, interviewers, and live event organizers to showcase their talent,
                        reach new audiences, and build sustainable careers.
                    </p>

                    <p className="sectionTitle">Contact Us</p>
                    <p className="paragraph">
                        Have questions, feedback, or want to partner with us? Reach out!
                    </p>
                    <p className="contactInfo">Email: contact@nvanetwork.gy</p>
                    <p className="contactInfo">Phone: +592-555-NVA (Placeholder)</p>
                    <p className="contactInfo">Follow us on social media!</p>
                </div>
            );

            const CrowdfundingScreen = ({ showMessage, setActiveScreen }) => {
                const PLATFORM_FEE_PERCENTAGE = 0.07;
                return (
                    <div className="screenContainer">
                        <p className="heading">Support Guyanese Creators!</p>
                        <p className="subHeading">Help bring more authentic Guyanese content to life.</p>
                        <p className="paragraph">
                            International crowdfunding platforms often don't support direct bank accounts in Guyana,
                            making it difficult for our talented creators to receive global support.
                            At NVA Network, we're committed to finding direct ways for you to contribute!
                        </p>
                        <div className="premiumFeatureCard">
                            <p className="premiumFeatureTitle">Why Your Support Matters:</p>
                            <p className="premiumFeatureDescription">
                                Your contributions directly fund new skits, short films, interviews, and live event coverage.
                                Every dollar helps cover production costs, equipment, and fair compensation for our artists.
                            </p>
                        </div>
                        <p className="sectionTitle">How You Can Contribute Directly:</p>
                        <p className="paragraph">
                            We are setting up direct support channels that are accessible within Guyana and for our diaspora.
                            Please contact us for details on how to send your support via:
                        </p>
                        <p className="listItem"> Direct Bank Transfer (Local & International options)</p>
                        <p className="listItem"> Mobile Money Services (e.g., MMG - Mobile Money Guyana)</p>
                        <p className="listItem"> Other Local Payment Methods</p>
                        <button
                            className="button"
                            onClick={() => setActiveScreen('AllCampaigns')}
                        >
                            <span className="buttonText">Browse Creator Campaigns</span>
                        </button>
                        <p className="smallText">(Discover campaigns and support your favorite creators!)</p>
                        <p className="paragraph" style={{ marginTop: '20px' }}>
                            Your generosity empowers Guyanese voices and helps us build a stronger, more vibrant content ecosystem.
                            Thank you for being a part of the NVA Network family!
                        </p>
                        <p className="smallText" style={{ marginTop: '20px', color: '#888' }}>
                            A small platform fee (e.g., {(PLATFORM_FEE_PERCENTAGE * 100).toFixed(0)}%) helps NVA Network cover operational costs and continue supporting our creators.
                        </p>
                    </div>
                );
            };


// --- REPLACE THE ENTIRE LoginScreen COMPONENT ---

const LoginScreen = ({ showMessage, setActiveScreen }) => {
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const handleSubmit = async (e) => {
        e.preventDefault();
        try {
            await signInWithEmailAndPassword(auth, email, password);
            showMessage(`Logged in as ${email}!`);
            setActiveScreen('CreatorDashboard'); 
        } catch (error) {
            console.error("Error logging in:", error);
            let errorMessage = "Login failed. Please check your credentials.";
            if (error.code === 'auth/user-not-found' || error.code === 'auth/wrong-password') {
                errorMessage = "Incorrect email or password. Please try again.";
            }
            showMessage(errorMessage);
        }
    };
    return (
        <div className="screenContainer">
            <p className="heading">Creator Login</p>
            <p className="subHeading">Access your dashboard to manage your content and campaigns.</p>
            <form onSubmit={handleSubmit} className="loginForm"><div className="formGroup"><label htmlFor="loginEmail" className="formLabel">Email:</label><input type="email" id="loginEmail" className="formInput" value={email} onChange={(e) => setEmail(e.target.value)} required /></div><div className="formGroup"><label htmlFor="loginPassword" className="formLabel">Password:</label><input type="password" id="loginPassword" className="formInput" value={password} onChange={(e) => setPassword(e.target.value)} required /></div><button type="submit" className="button"><span className="buttonText">Login</span></button></form>
            <p className="smallText" style={{ marginTop: '20px' }}>Don't have an account?{' '}<a href="#" className="termsLink" onClick={(e) => { e.preventDefault(); setActiveScreen('CreatorSignUp'); }}>Sign Up Here</a></p>
        <button className="button" onClick={() => setActiveScreen('Home')} style={{ backgroundColor: '#3A3A3A', marginTop: '30px' }}><span className="buttonText light">Back to Home</span></button>
        </div>
    );
};


const UserSignUpScreen = ({ showMessage, setActiveScreen }) => {
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const [agreedToTerms, setAgreedToTerms] = useState(false);

    const handleSubmit = async (e) => {
        e.preventDefault();
        if (!agreedToTerms) {
            showMessage('Please agree to the Terms & Conditions to sign up.');
            return;
        }

        if (password.length < 8) {
            showMessage('Password must be at least 8 characters long.');
            return;
        }
        if (!/\d/.test(password)) {
            showMessage('Password must include at least one number.');
            return;
        }
        if (!/[A-Z]/.test(password)) {
            showMessage('Password must include at least one capital letter.');
            return;
        }

        try {
            const userCredential = await createUserWithEmailAndPassword(auth, email, password);
            const user = userCredential.user;

            // This is the new, required step
            await sendEmailVerification(user);

            const creatorRef = doc(db, "creators", user.uid);
            // This is the full data structure from your original, working component
            await setDoc(creatorRef, {
                email: user.email,
                creatorName: user.email.split('@')[0] || "",
                bio: "",
                categories: [],
                existingWorkLink: "",
                profilePictureUrl: '',
                uploadedVideos: { youtube: null, facebook: null, tiktok: null },
                createdAt: new Date().toISOString(),
                role: 'user',
                banned: false
            });

            showMessage(`Account created successfully for ${email}! Please check your inbox to verify your account.`);
            setActiveScreen('VerifyEmail'); // Redirect to the verification screen
        }
        catch (error) {
            console.error("Error signing up user:", error);
            let errorMessage = "Failed to sign up. Please try again.";
            if (error.code === 'auth/email-already-in-use') {
                errorMessage = "This email is already in use. Please use a different email or sign in.";
            } else if (error.code === 'auth/invalid-email') {
                errorMessage = "Invalid email address format.";
            } else if (error.code === 'auth/weak-password') {
                errorMessage = "Password is too weak. Please choose a stronger password.";
            }
            showMessage(errorMessage);
        }
    };

    return (
        <div className="screenContainer">
            <p className="heading">Create Your Account</p>
            <p className="subHeading">Sign up to access exclusive content and support creators!</p>

            <form onSubmit={handleSubmit}>
                <div className="formGroup">
                    <label htmlFor="userEmail" className="formLabel">Email:</label>
                    <input
                        type="email"
                        id="userEmail"
                        className="formInput"
                        value={email}
                        onChange={(e) => setEmail(e.target.value)}
                        required
                    />
                </div>

                <div className="formGroup">
                    <label htmlFor="userPassword" className="formLabel">Password:</label>
                    <input
                        type="password"
                        id="userPassword"
                        className="formInput"
                        value={password}
                        onChange={(e) => setPassword(e.target.value)}
                        required
                    />
                    <p className="smallText" style={{ textAlign: 'left', color: '#FFD700', marginTop: '5px' }}>
                        Password must be at least 8 characters long, include at least one number and one capital letter.
                    </p>
                </div>

                <div className="formGroup">
                    <div className="checkboxItem">
                        <input
                            type="checkbox"
                            id="agreeUserTerms"
                            checked={agreedToTerms}
                            onChange={(e) => setAgreedToTerms(e.target.checked)}
                            required
                        />
                        <label htmlFor="agreeUserTerms">
                            I agree to the <a href="#" className="termsLink" onClick={(e) => { e.preventDefault(); showMessage('Simulating opening User Terms & Conditions...'); }}>Terms & Conditions</a>.
                        </label>
                    </div>
                </div>

                <button type="submit" className="button">
                    <span className="buttonText">Sign Up</span>
                </button>
            </form>

            <p className="smallText" style={{ marginTop: '20px' }}>
                Already have an account?{' '}
                <a href="#" className="termsLink" onClick={(e) => { e.preventDefault(); setActiveScreen('Login'); }}>Login Here</a>
            </p>

            <button
                className="button"
                onClick={() => setActiveScreen('Home')}
                style={{ backgroundColor: '#3A3A3A', color: '#FFF', marginTop: '30px' }}
            >
                <span className="buttonText">Back to Home</span>
            </button>
        </div>
    );
};

// --- REPLACE CreatorSignUpScreen WITH THIS COMPLETE VERSION ---
const CreatorSignUpScreen = ({ showMessage, setActiveScreen }) => {
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const [creatorName, setCreatorName] = useState('');
    const [bio, setBio] = useState('');
    const [selectedCategories, setSelectedCategories] = useState([]);
    const [existingWorkLink, setExistingWorkLink] = useState('');
    const [agreedToTerms, setAgreedToTerms] = useState(false);
    const availableCategories = ['Skits', 'Short Films', 'Interviews', 'Live Premieres', 'Music', 'Documentary', 'Other'];

    const handleCategoryChange = (e) => { const { value, checked } = e.target; setSelectedCategories(prev => checked ? [...prev, value] : prev.filter(cat => cat !== value)); };

    const handleSubmit = async (e) => {
        e.preventDefault();
        if (!agreedToTerms) { showMessage('Please agree to the Creator Terms & Conditions to sign up.'); return; }
        if (password.length < 8 || !/\d/.test(password) || !/[A-Z]/.test(password)) { showMessage('Password must be at least 8 characters, with a number and a capital letter.'); return; }

        try {
            const userCredential = await createUserWithEmailAndPassword(auth, email, password);
            const user = userCredential.user;
            await sendEmailVerification(user);
            const creatorRef = doc(db, "creators", user.uid);
            await setDoc(creatorRef, { email: user.email, creatorName: creatorName, bio: bio, categories: selectedCategories, existingWorkLink: existingWorkLink, profilePictureUrl: '', createdAt: new Date().toISOString(), role: 'creator', banned: false });
            showMessage(`Creator "${creatorName}" signed up! Please check your inbox to verify your account.`);
            setActiveScreen('VerifyEmail');
        } catch (error) {
            console.error("Error signing up creator:", error);
            let errorMessage = "Failed to sign up. Please try again.";
            if (error.code === 'auth/email-already-in-use') { errorMessage = "This email is already in use."; }
            showMessage(errorMessage);
        }
    };

    return (
        <div className="screenContainer">
            <p className="heading">Join NVA Network as a Creator!</p>
            <form onSubmit={handleSubmit}>
                <div className="formGroup"><label htmlFor="email" className="formLabel">Email:</label><input type="email" id="email" className="formInput" value={email} onChange={(e) => setEmail(e.target.value)} required /></div>
                <div className="formGroup"><label htmlFor="password" className="formLabel">Password:</label><input type="password" id="password" className="formInput" value={password} onChange={(e) => setPassword(e.target.value)} required /></div>
                <div className="formGroup"><label htmlFor="creatorName" className="formLabel">Creator Name (Public):</label><input type="text" id="creatorName" className="formInput" value={creatorName} onChange={(e) => setCreatorName(e.target.value)} required /></div>
                <div className="formGroup"><label htmlFor="bio" className="formLabel">Brief Bio/Description:</label><textarea id="bio" className="formTextarea" value={bio} onChange={(e) => setBio(e.target.value)} placeholder="Tell us about yourself!" required ></textarea></div>
                <div className="checkboxGroup"><p className="checkboxLabel">Content Categories:</p>{availableCategories.map((cat) => (<div key={cat} className="checkboxItem"><input type="checkbox" id={`cat-${cat}`} value={cat} checked={selectedCategories.includes(cat)} onChange={handleCategoryChange} /><label htmlFor={`cat-${cat}`}>{cat}</label></div>))}</div>
                <div className="formGroup"><label htmlFor="existingWork" className="formLabel">Link to Existing Work (Optional):</label><input type="url" id="existingWork" className="formInput" value={existingWorkLink} onChange={(e) => setExistingWorkLink(e.target.value)} placeholder="e.g., YouTube channel" /></div>
                <div className="formGroup"><div className="checkboxItem"><input type="checkbox" id="agreeTerms" checked={agreedToTerms} onChange={(e) => setAgreedToTerms(e.target.checked)} required /><label htmlFor="agreeTerms">I agree to the <a href="#" className="termsLink" onClick={(e) => { e.preventDefault(); showMessage('Simulating opening Creator Terms...'); }}>Creator Terms & Conditions</a>.</label></div></div>
                <button type="submit" className="button"><span className="buttonText">Sign Up as Creator</span></button>
            </form>
        </div>
    );
};


const CreatorDashboardScreen = ({
    showMessage,
    setActiveScreen,
    currentUser,
    creatorProfile,
    setCreatorProfile,
    setSelectedCampaignId,
    setShowConfirmationModal,
    setConfirmationTitle,
    setConfirmationMessage,
    setOnConfirmationAction
}) => {
    const [creatorCampaigns, setCreatorCampaigns] = useState([]);
    const [isEditingProfile, setIsEditingProfile] = useState(false);
    const [editCreatorName, setEditCreatorName] = useState('');
    const [editBio, setEditBio] = useState('');
    const [editCategories, setEditCategories] = useState([]);
    const [editExistingWorkLink, setEditExistingWorkLink] = useState('');
    const availableCategories = ['Skits', 'Short Films', 'Interviews', 'Live Premieres', 'Music', 'Documentary', 'Other'];
    const [videoLinkInput, setVideoLinkInput] = useState('');
    const [customThumbnailFile, setCustomThumbnailFile] = useState(null);
    const [customThumbnailPreview, setCustomThumbnailPreview] = useState('');
    const [autoThumbnailPreview, setAutoThumbnailPreview] = useState('');
    const [isPublishing, setIsPublishing] = useState(false);
    const thumbnailFileInputRef = useRef(null);
    const profilePictureInputRef = useRef(null);
    const [showImageAdjustModal, setShowImageAdjustModal] = useState(false);
    const [imageFileToAdjust, setImageFileToAdjust] = useState(null);
    const [isUploadingPFP, setIsUploadingPFP] = useState(false);

    useEffect(() => {
        let unsubscribe = () => {};
        if (currentUser) {
            const campaignsCollectionRef = collection(db, `artifacts/${appId}/public/data/campaigns`);
            const q = query(campaignsCollectionRef, where('creatorId', '==', currentUser.uid), orderBy('createdAt', 'desc'));
            unsubscribe = onSnapshot(q, (snapshot) => {
                setCreatorCampaigns(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
            });
        } else {
            setCreatorCampaigns([]);
        }
        return () => unsubscribe();
    }, [currentUser]);

    useEffect(() => {
        if (creatorProfile) {
            setEditCreatorName(creatorProfile.creatorName || '');
            setEditBio(creatorProfile.bio || '');
            setEditCategories(creatorProfile.categories || []);
            setEditExistingWorkLink(creatorProfile.existingWorkLink || '');
            setVideoLinkInput(creatorProfile.featuredVideoLink?.url || '');
        }
    }, [creatorProfile]);

    useEffect(() => {
        setAutoThumbnailPreview('');
        if (!videoLinkInput || (creatorProfile.featuredVideoLink && videoLinkInput === creatorProfile.featuredVideoLink.url)) return;
        const handler = setTimeout(() => {
            const { thumbnailUrl } = extractVideoInfo(videoLinkInput);
            if (thumbnailUrl) setAutoThumbnailPreview(thumbnailUrl);
        }, 600);
        return () => clearTimeout(handler);
    }, [videoLinkInput]);

    const handleSaveProfile = async () => { if (!editCreatorName) { showMessage("Creator name cannot be empty."); return; } try { const creatorRef = doc(db, "creators", currentUser.uid); await updateDoc(creatorRef, { creatorName: editCreatorName, bio: editBio, categories: editCategories, existingWorkLink: editExistingWorkLink, updatedAt: new Date().toISOString() }); setCreatorProfile(prev => ({ ...prev, creatorName: editCreatorName, bio: editBio, categories: editCategories, existingWorkLink: editExistingWorkLink })); setIsEditingProfile(false); showMessage('Profile updated successfully!'); } catch (error) { showMessage(`Failed to update profile: ${error.message}`); } };
    const handleCancelEdit = () => { if (creatorProfile) { setEditCreatorName(creatorProfile.creatorName || ''); setEditBio(creatorProfile.bio || ''); setEditCategories(creatorProfile.categories || []); setEditExistingWorkLink(creatorProfile.existingWorkLink || ''); } setIsEditingProfile(false); };
    const handleProfileCategoryChange = (e) => { const { value, checked } = e.target; setEditCategories(prev => checked ? [...prev, value] : prev.filter(cat => cat !== value)); };
    const triggerProfilePictureUpload = (e) => { const file = e.target.files[0]; if (file) { setImageFileToAdjust(file); setShowImageAdjustModal(true); } };
    const handleSaveAdjustedProfilePicture = async (adjustedBlob) => { if (!currentUser || !adjustedBlob) return; setIsUploadingPFP(true); showMessage("Uploading new profile picture..."); try { const filePath = `profile_pictures/${currentUser.uid}/profile_${Date.now()}.png`; const storageRefPath = ref(storage, filePath); const snapshot = await uploadBytes(storageRefPath, adjustedBlob); const downloadURL = await getDownloadURL(snapshot.ref); const creatorRef = doc(db, "creators", currentUser.uid); await updateDoc(creatorRef, { profilePictureUrl: downloadURL }); setCreatorProfile(prev => ({ ...prev, profilePictureUrl: downloadURL })); setShowImageAdjustModal(false); showMessage("Profile picture updated successfully!"); } catch (error) { console.error("Error updating profile picture:", error); showMessage(`Failed to update profile picture: ${error.message}`); } finally { if (profilePictureInputRef.current) { profilePictureInputRef.current.value = null; } setIsUploadingPFP(false); } };
    const handleCancelAdjust = () => { setImageFileToAdjust(null); setShowImageAdjustModal(false); };
    const handleCancelCampaign = async (campaignId, campaignTitle) => { try { const campaignRef = doc(db, `artifacts/${appId}/public/data/campaigns`, campaignId); await updateDoc(campaignRef, { status: 'cancelled', updatedAt: new Date().toISOString(), statusChangedAt: new Date().toISOString() }); showMessage(`Campaign "${campaignTitle}" has been cancelled.`); } catch (error) { showMessage(`Failed to cancel campaign: ${error.message}`); } };
    const confirmCancelCampaign = (campaignId, campaignTitle) => { setConfirmationTitle("Cancel Campaign?"); setConfirmationMessage(`Are you sure you want to cancel your campaign "${campaignTitle}"? This cannot be undone.`); setOnConfirmationAction(() => () => handleCancelCampaign(campaignId, campaignTitle)); setShowConfirmationModal(true); };
    const handleAddOrUpdateVideo = async () => { if (!videoLinkInput) { showMessage('Please paste a URL first.'); return; } setIsPublishing(true); const { videoId, thumbnailUrl: autoThumbnailUrl, embedUrl, platform } = extractVideoInfo(videoLinkInput); if (!videoId) { showMessage('Invalid or unsupported URL.'); setIsPublishing(false); return; } let finalThumbnailUrl = autoThumbnailUrl; if (customThumbnailFile) { showMessage('Uploading custom thumbnail...'); try { const fileName = `thumb_${currentUser.uid}_${Date.now()}`; const storageRefPath = ref(storage, `creator_uploads/${currentUser.uid}/${fileName}`); await uploadBytes(storageRefPath, customThumbnailFile); finalThumbnailUrl = await getDownloadURL(storageRefPath); showMessage('Custom thumbnail uploaded successfully!'); } catch (error) { showMessage(`Thumbnail upload failed: ${error.message}`); setIsPublishing(false); return; } } let newContentRef; try { const contentCollectionRef = collection(db, `artifacts/${appId}/public/data/content_items`); newContentRef = await addDoc(contentCollectionRef, { title: `New from ${creatorProfile.creatorName}`, description: `Check out the latest from ${creatorProfile.creatorName}.`, mainUrl: videoLinkInput, customThumbnailUrl: finalThumbnailUrl, embedUrl, videoPlatform: platform, creatorId: currentUser.uid, creatorName: creatorProfile.creatorName, contentType: 'Live Feed', orderIndex: Date.now(), isActive: true, createdAt: new Date().toISOString(), createdBy: currentUser.uid, viewCount: 0, likeCount: 0 }); showMessage('Published to the Live Feed!'); } catch (error) { showMessage(`Failed to publish to Live Feed: ${error.message}`); setIsPublishing(false); return; } const videoData = { url: videoLinkInput, thumbnailUrl: finalThumbnailUrl, embedUrl, platform, liveFeedContentId: newContentRef.id }; try { const creatorRef = doc(db, "creators", currentUser.uid); await updateDoc(creatorRef, { featuredVideoLink: videoData, updatedAt: new Date().toISOString() }); setCreatorProfile(prev => ({ ...prev, featuredVideoLink: videoData })); showMessage('Your featured link has been set!'); } catch (error) { showMessage(`Failed to update your profile: ${error.message}`); } finally { setIsPublishing(false); } };
    const handleRemoveVideo = () => { const videoToRemove = creatorProfile.featuredVideoLink; if (!videoToRemove) return; const deletionLogic = async () => { setIsPublishing(true); if (videoToRemove.liveFeedContentId) { try { const contentDocRef = doc(db, `artifacts/${appId}/public/data/content_items`, videoToRemove.liveFeedContentId); await deleteDoc(contentDocRef); showMessage('Post removed from Live Feed.'); } catch (error) { console.error("Error deleting from live feed:", error); showMessage(`Could not remove from feed: ${error.message}`); } } try { const creatorRef = doc(db, "creators", currentUser.uid); await updateDoc(creatorRef, { featuredVideoLink: null, updatedAt: new Date().toISOString() }); setCreatorProfile(prev => ({ ...prev, featuredVideoLink: null })); setVideoLinkInput(''); setCustomThumbnailFile(null); setCustomThumbnailPreview(''); setAutoThumbnailPreview(''); showMessage('Featured link removed from your profile.'); } catch (error) { console.error("Error removing featured video:", error); showMessage(`Failed to remove link: ${error.message}`); } finally { setIsPublishing(false); } }; setShowConfirmationModal(true); setConfirmationTitle("Remove Featured Link?"); setConfirmationMessage("Are you sure? This will remove the link and delete the post from the public Live Feed."); setOnConfirmationAction(() => deletionLogic); };

    if (!creatorProfile) { return (<div className="screenContainer" style={{ textAlign: 'center', paddingTop: '50px' }}><p className="heading">Loading Your Dashboard...</p></div>); }
    const hasActiveOrPendingCampaign = creatorCampaigns.some(c => c.status === 'active' || c.status === 'pending');
    const currentThumbnail = customThumbnailPreview || (creatorProfile.featuredVideoLink?.thumbnailUrl) || autoThumbnailPreview;

    return (
        <>
            <div className="screenContainer">
                <p className="heading">Dashboard</p>
                <p className="subHeading">Welcome, {creatorProfile.creatorName || currentUser.email}!</p>
                
                <div className="dashboardSection">
                    <div className="flex justify-between items-center">
                        <p className="dashboardSectionTitle" style={{marginBottom: 0}}>Your Profile</p>
                        {!isEditingProfile ? (<button className="dashboardButton" onClick={() => setIsEditingProfile(true)}>Edit Profile</button>) : (<div><button className="dashboardButton" onClick={handleSaveProfile} style={{backgroundColor: '#008000'}}>Save</button><button className="dashboardButton" onClick={handleCancelEdit} style={{backgroundColor: '#555', color: '#FFF'}}>Cancel</button></div>)}
                    </div>
                    <div className="pt-4 border-t border-gray-200 mt-4" style={{borderColor: '#3A3A3A'}}>
                        {isEditingProfile ? (<>
                            <div className="formGroup"><label htmlFor="editCreatorName" className="formLabel">Creator Name (Public):</label><input type="text" id="editCreatorName" className="formInput" value={editCreatorName} onChange={(e) => setEditCreatorName(e.target.value)} required /></div>
                            <div className="formGroup"><label htmlFor="editBio" className="formLabel">Bio/Description:</label><textarea id="editBio" className="formTextarea" value={editBio} onChange={(e) => setEditBio(e.target.value)} placeholder="Tell us about yourself!"></textarea></div>
                            <div className="checkboxGroup"><p className="checkboxLabel">Content Categories:</p>{availableCategories.map((cat) => (<div key={cat} className="checkboxItem"><input type="checkbox" id={`edit-cat-${cat}`} value={cat} checked={editCategories.includes(cat)} onChange={handleProfileCategoryChange} /><label htmlFor={`edit-cat-${cat}`}>{cat}</label></div>))}</div>
                            <div className="formGroup"><label htmlFor="editExistingWork" className="formLabel">External Link (Optional):</label><input type="url" id="editExistingWork" className="formInput" value={editExistingWorkLink} onChange={(e) => setEditExistingWorkLink(e.target.value)} placeholder="e.g., YouTube channel, Instagram" /></div>
                        </>) : (<>
                            <div className="flex items-center mb-4">
                                <div className="relative">
                                    <img src={creatorProfile.profilePictureUrl || 'https://placehold.co/100x100/555/FFF?text=P'} alt="Profile" style={{width: '100px', height: '100px', borderRadius: '50%', border: '2px solid #FFD700', objectFit: 'cover'}} />
                                    <input type="file" ref={profilePictureInputRef} onChange={triggerProfilePictureUpload} accept="image/*" style={{ display: 'none' }} />
                                    <button onClick={() => profilePictureInputRef.current.click()} style={{backgroundColor: '#FFD700', color: '#0A0A0A', width: '30px', height: '30px', borderRadius: '50%', border: 'none', cursor: 'pointer', position: 'absolute', bottom: 0, right: 0, display: 'flex', alignItems: 'center', justifyContent: 'center'}}></button>
                                </div>
                                <div style={{marginLeft: '1rem'}}>
                                    <p className="dashboardItem" style={{fontSize: '18px', fontWeight: 'bold', color: '#FFF'}}>{creatorProfile.creatorName}</p>
                                    <p className="dashboardItem" style={{fontSize: '12px', color: '#AAA', display: 'flex', alignItems: 'center'}}>
                                        Role: {creatorProfile.role}
                                        {creatorProfile.premiumExpiresAt && new Date(creatorProfile.premiumExpiresAt.toDate()) > new Date() && (
                                            <>
                                                <span style={{marginLeft: '10px', fontSize: '14px'}}></span>
                                                <span style={{
                                                    marginLeft: '4px', backgroundColor: '#FFD700', color: '#0A0A0A', padding: '3px 8px', borderRadius: '10px', fontSize: '10px', fontWeight: 'bold'}}>Premium Member</span>
                                            </>
                                        )}
                                    </p>
                                    <div style={{display: 'flex', gap: '15px', marginTop: '10px'}}>
                                        <div className="dashboardItem termsLink" style={{cursor: 'pointer'}} onClick={() => setActiveScreen('Followers')}><strong>{creatorProfile.followerCount || 0}</strong> Followers</div>
                                        <div className="dashboardItem termsLink" style={{cursor: 'pointer'}} onClick={() => setActiveScreen('MyFollows')}><strong>{creatorProfile.followingCount || 0}</strong> Following</div>
                                    </div>
                                </div>
                            </div>
                            <p className="dashboardItem"><strong>Bio:</strong> {creatorProfile.bio || "No bio set."}</p>
                            <p className="dashboardItem"><strong>Categories:</strong> {creatorProfile.categories?.length > 0 ? creatorProfile.categories.join(', ') : "No categories set."}</p>
                            <p className="dashboardItem"><strong>External Link:</strong> {creatorProfile.existingWorkLink ? <a href={creatorProfile.existingWorkLink} target="_blank" rel="noopener noreferrer" className="termsLink">{creatorProfile.existingWorkLink}</a> : "No link set."}</p>
                        </>)}
                    </div>
                </div>

                {creatorProfile.role !== 'user' && (
                    <div className="dashboardSection">
                        <div className="flex justify-between items-center">
                            <p className="dashboardSectionTitle" style={{marginBottom: 0}}>My Crowdfunding Campaigns</p>
                            <button className="dashboardButton" onClick={() => setActiveScreen('CreateCampaign')} disabled={hasActiveOrPendingCampaign} style={hasActiveOrPendingCampaign ? {cursor: 'not-allowed', backgroundColor: '#555', color: '#999'} : {}}>Create New</button>
                        </div>
                        <div className="pt-4 border-t border-gray-200 mt-4" style={{borderColor: '#3A3A3A'}}>
                            {creatorCampaigns.length === 0 ? (
                                <p className="dashboardItem">You have not created any campaigns yet.</p>
                            ) : (
                                creatorCampaigns.map(campaign => (
                                    <div
                                        key={campaign.id}
                                        className="creator-campaign-list-item"
                                        onClick={() => {
                                            setSelectedCampaignId(campaign.id);
                                            setActiveScreen('CampaignDetails');
                                        }}
                                        style={{
                                            cursor: 'pointer',
                                            flexDirection: 'column',
                                            alignItems: 'stretch'
                                        }}
                                    >
                                        <div style={{ display: 'flex', alignItems: 'center', width: '100%' }}>
                                            <img src={campaign.imageUrl || 'https://placehold.co/80x50/3A3A3A/FFF?text=NVA'} alt={campaign.title} className="creator-campaign-thumbnail" onError={(e) => { e.target.src = 'https://placehold.co/80x50/3A3A3A/FFF?text=Error'; }}/>
                                            <div className="creator-campaign-info">
                                                <p className="creator-campaign-title">{campaign.title}</p>
                                                <p className={`creator-campaign-status status-${campaign.status}`}>Status: {campaign.status.charAt(0).toUpperCase() + campaign.status.slice(1)}</p>
                                            </div>
                                        </div>
                                        
                                        <div style={{width: '100%', marginTop: '10px'}}>
                                            <div className="campaignProgressContainer" style={{ height: '8px' }}>
                                                <div
                                                    className="campaignProgressBar"
                                                    style={{ width: `${(campaign.raised / campaign.goal) * 100}%` }}
                                                ></div>
                                            </div>
                                            <div className="campaignListStats" style={{marginTop: '4px'}}>
                                                <span>Raised: <span className="campaignListRaised">${campaign.raised || 0}</span></span>
                                                <span>Goal: <span className="campaignListGoal">${campaign.goal}</span></span>
                                            </div>
                                        </div>

                                        {campaign.status !== 'cancelled' && campaign.status !== 'ended' && (
                                            <button 
                                                className="actionButton" 
                                                style={{backgroundColor: '#DC3545', alignSelf: 'flex-end', marginTop: '10px'}} 
                                                onClick={(e) => {
                                                    e.stopPropagation(); // Prevents navigating when clicking the cancel button
                                                    confirmCancelCampaign(campaign.id, campaign.title);
                                                }}
                                            >
                                                Cancel
                                            </button>
                                        )}
                                    </div>
                                ))
                            )}
                            {hasActiveOrPendingCampaign && (<p className="smallText" style={{textAlign: 'center', color: '#FFD700', marginTop: '15px'}}>You must cancel or wait for your current campaign to finish before creating a new one.</p>)}
                        </div>
                    </div>
                )}

                {creatorProfile.role !== 'user' && (
                    <div className="dashboardSection">
                        <p className="dashboardSectionTitle">My Featured Link</p>
                        <p className="dashboardItem" style={{color: '#AAA', lineHeight: 1.4, marginBottom: '15px'}}>Post a link to your latest video. This will be featured on your profile and posted to the Live Feed.</p>
                        <div className="videoLinkSection">
                            <label htmlFor="featuredVideoLink" className="formLabel">URL:</label>
                            <div className="videoInputContainer"><input type="url" id="featuredVideoLink" className="formInput" value={videoLinkInput} onChange={(e) => setVideoLinkInput(e.target.value)} placeholder="Paste your link here" /></div>
                            {!creatorProfile.featuredVideoLink && (<div className="formGroup" style={{marginTop: '15px'}}><label htmlFor="customThumbnailFile" className="formLabel">Custom Thumbnail (Optional):</label><input type="file" id="customThumbnailFile" ref={thumbnailFileInputRef} className="formInput" onChange={(e) => { const file = e.target.files[0]; setCustomThumbnailFile(file); if (file) { setCustomThumbnailPreview(URL.createObjectURL(file)); } else { setCustomThumbnailPreview(''); }}} accept="image/*" style={{padding: '10px 0', border: 'none', backgroundColor: 'transparent'}} /></div>)}
                            {currentThumbnail && ( <div style={{marginTop: '10px'}}><p className="formLabel" style={{marginBottom: '5px'}}>Thumbnail Preview:</p><img src={currentThumbnail} alt="Thumbnail Preview" style={{ maxWidth: '200px', borderRadius: '8px', border: '2px solid #FFD700' }} onError={(e) => { e.target.style.display = 'none'; }} /></div> )}
                            <div className="videoActions" style={{marginTop: '20px', justifyContent: 'flex-start'}}>
                                {!creatorProfile.featuredVideoLink ? ( <button className="adminActionButton approve" onClick={handleAddOrUpdateVideo} disabled={isPublishing} style={{padding: '10px 20px', fontSize: '14px', cursor: isPublishing ? 'not-allowed' : 'pointer', opacity: isPublishing ? 0.6 : 1}}>{isPublishing ? 'Publishing...' : 'Publish URL'}</button> ) : ( <button className="adminActionButton reject" onClick={handleRemoveVideo} disabled={isPublishing} style={{padding: '10px 20px', fontSize: '14px', cursor: isPublishing ? 'not-allowed' : 'pointer', opacity: isPublishing ? 0.6 : 1}}>{isPublishing ? 'Removing...' : 'Remove Link'}</button> )}
                            </div>
                        </div>
                    </div>
                )}
                                
                <button className="button" onClick={() => setActiveScreen('Home')} style={{ backgroundColor: '#3A3A3A', marginTop: '30px' }}><span className="buttonText light">Back to Home</span></button>
            </div>
            {showImageAdjustModal && imageFileToAdjust && (<ProfilePictureAdjustModal isUploading={isUploadingPFP} imageUrl={URL.createObjectURL(imageFileToAdjust)} onSave={handleSaveAdjustedProfilePicture} onCancel={handleCancelAdjust} showMessage={showMessage} />)}
        </>
    );
};
// ====================== END: REPLACEMENT BLOCK ======================
       
// =========== START REPLACEMENT ===========
              const memoizedScreen = React.useMemo(() => {
            if (currentUser && !currentUser.emailVerified) {
                return <VerificationScreen 
                    currentUser={currentUser} 
                    showMessage={showMessage} 
                    handleLogout={handleLogout} 
                    setActiveScreen={setActiveScreen}
                />;
            }
            
            switch (activeScreen) {
                case 'Home':
                    return <HomeScreen currentUser={currentUser} showMessage={showMessage} handleVideoPress={handleVideoPress} handleLogout={handleLogout} creatorProfile={creatorProfile} featuredContentSlots={featuredContentSlots}/>;
                case 'FollowingFeed':
                    return <FollowingFeedScreen currentUser={currentUser} setActiveScreen={setActiveScreen} showMessage={showMessage} handleVideoPress={handleVideoPress}/>;
                case 'Contact':
                    return <ContactScreen setActiveScreen={setActiveScreen} showMessage={showMessage} currentUser={currentUser}/>;
                case 'DiscoverUsers':
                    return <DiscoverUsersScreen showMessage={showMessage} setActiveScreen={setActiveScreen} setSelectedCampaignId={setSelectedCampaignId} creatorProfile={creatorProfile} setSelectedUserId={setSelectedUserId}/>;
                case 'UserProfile':
                    return <UserProfileScreen selectedUserId={selectedUserId} setActiveScreen={setActiveScreen} setSelectedCampaignId={setSelectedCampaignId} showMessage={showMessage} currentUser={currentUser}/>;
                case 'MyFollows':
                    return <MyFollowsScreen currentUser={currentUser} showMessage={showMessage} setActiveScreen={setActiveScreen} setSelectedUserId={setSelectedUserId}/>;
                case 'Followers':
                    return <FollowersScreen currentUser={currentUser} showMessage={showMessage} setActiveScreen={setActiveScreen} setSelectedUserId={setSelectedUserId}/>;
                case 'Login':
                    return <LoginScreen showMessage={showMessage} setActiveScreen={setActiveScreen}/>;
                case 'UserSignUp':
                    return <UserSignUpScreen showMessage={showMessage} setActiveScreen={setActiveScreen}/>;
                case 'CreatorSignUp':
                    return <CreatorSignUpScreen showMessage={showMessage} setActiveScreen={setActiveScreen}/>;
                case 'Premium':
                    return <PremiumScreen showMessage={showMessage} currentUser={currentUser} setActiveScreen={setActiveScreen} setPledgeContext={setPledgeContext} />;
                case 'Support':
                    return <CrowdfundingScreen showMessage={showMessage} setActiveScreen={setActiveScreen}/>;
                case 'AllCampaigns':
                    return <AllCampaignsScreen showMessage={showMessage} setActiveScreen={setActiveScreen} setSelectedCampaignId={setSelectedCampaignId}/>;
                case 'CampaignDetails':
                    return <CampaignDetailsScreen showMessage={showMessage} setActiveScreen={setActiveScreen} selectedCampaignId={selectedCampaignId} currentUser={currentUser} setPledgeContext={setPledgeContext} />;
                case 'DonationPledge':
                    return <DonationPledgeScreen showMessage={showMessage} setActiveScreen={setActiveScreen} currentUser={currentUser} creatorProfile={creatorProfile} pledgeContext={pledgeContext} setPledgeIdForConfirmation={setPledgeIdForConfirmation} />;
                case 'SubscriptionPledge':
                    return <SubscriptionPledgeScreen showMessage={showMessage} setActiveScreen={setActiveScreen} currentUser={currentUser} creatorProfile={creatorProfile} pledgeContext={pledgeContext} setPledgeIdForConfirmation={setPledgeIdForConfirmation} />;
                case 'PendingConfirmation':
                    if (!pledgeIdForConfirmation) {
                        return (
                            <div className="screenContainer" style={{textAlign: 'center', paddingTop: '50px'}}>
                                <p className="heading">Initializing Secure Session...</p>
                            </div>
                        );
                    }
                    return <PendingConfirmationScreen showMessage={showMessage} setActiveScreen={setActiveScreen} pledgeId={pledgeIdForConfirmation} currentUser={currentUser} />;
                case 'CreatorDashboard':
                    return <CreatorDashboardScreen showMessage={showMessage} setActiveScreen={setActiveScreen} currentUser={currentUser} creatorProfile={creatorProfile} setCreatorProfile={setCreatorProfile} setSelectedCampaignId={setSelectedCampaignId} setShowConfirmationModal={setShowConfirmationModal} setConfirmationTitle={setConfirmationTitle} setConfirmationMessage={setConfirmationMessage} setOnConfirmationAction={setOnConfirmationAction}/>;
                case 'CreateCampaign':
                    return <CreateCampaignScreen showMessage={showMessage} setActiveScreen={setActiveScreen} currentUser={currentUser} creatorProfile={creatorProfile}/>;
                case 'AdminDashboard':
                    return <AdminDashboardScreen showMessage={showMessage} featuredContentSlots={featuredContentSlots} setActiveScreen={setActiveScreen} currentUser={currentUser} setSelectedAdminCampaignId={setSelectedAdminCampaignId} creatorProfile={creatorProfile} selectedAdminSubScreen={selectedAdminSubScreen} setSelectedAdminSubScreen={setSelectedAdminSubScreen} setShowConfirmationModal={setShowConfirmationModal} setConfirmationTitle={setConfirmationTitle} setConfirmationMessage={setConfirmationMessage} setOnConfirmationAction={setOnConfirmationAction}/>;
                case 'AdminCampaignDetails':
                    return <AdminCampaignDetailsScreen showMessage={showMessage} setActiveScreen={setActiveScreen} currentUser={currentUser} selectedAdminCampaignId={selectedAdminCampaignId} setShowConfirmationModal={setShowConfirmationModal} setConfirmationTitle={setConfirmationTitle} setConfirmationMessage={setConfirmationMessage} setOnConfirmationAction={setOnConfirmationAction} creatorProfile={creatorProfile}/>;
                case 'TopCreators':
                    return <TopCreatorsScreen featuredContentSlots={featuredContentSlots} handleVideoPress={handleVideoPress} setActiveScreen={setActiveScreen} currentUser={currentUser} showMessage={showMessage}/>;
                case 'AnalyticsDashboard':
                    return <AnalyticsDashboardScreen showMessage={showMessage} setActiveScreen={setActiveScreen}/>;
                case 'PremiumMembersScreen':
                    return <PremiumMembersScreen setActiveScreen={setActiveScreen} setSelectedUserId={setSelectedUserId} showMessage={showMessage} />;
                case 'NotificationInbox':
                        return <NotificationInboxScreen notifications={unreadNotifications} setActiveScreen={setActiveScreen} dismissNotification={dismissNotification} />;
                default:
                    return <HomeScreen currentUser={currentUser} showMessage={showMessage} handleVideoPress={handleVideoPress} handleLogout={handleLogout} creatorProfile={creatorProfile} featuredContentSlots={featuredContentSlots}/>;
            }
        }, [activeScreen, currentUser, creatorProfile, featuredContentSlots, selectedAdminSubScreen, pledgeIdForConfirmation]);

        const renderScreen = () => {
            if (activeScreen === 'Discover') {
                // Render this screen fresh every time, as it needs the live countdown
                return <CategoriesScreen showMessage={showMessage} isLive={isLive} countdownText={countdownText} liveThumbnail={liveThumbnail} currentUser={currentUser} handleVideoPress={handleVideoPress}/>;
            }
            // For all other screens, return the stable, memoized version
            return memoizedScreen;
        };
// =========== END REPLACEMENT ===========


                        if (authLoading) {
                return (
                    <div className="container" style={{ display: 'flex', justifyContent: 'center', alignItems: 'center' }}>
                        <p className="heading">Loading NVA Network...</p>
                    </div>
                );
            }
            // --- PASTE THIS ENTIRE NEW BLOCK HERE ---
            // After initial auth is done, if we have a user but are still waiting for their Firestore profile, show a loading screen.
            // This prevents the race condition after email verification.
            
// --- END OF THE NEW BLOCK 
          
            return (
                <div className="container">
                <div className="header">
    <div className="header-content-left">
        {/* Item 1: Tagline (Top) */}
        <p className="tagline">Guyanese Content to a Global Stage.</p>
        
        {/* Item 2: Title (Middle) */}
        <p className="headerTitle">NVA Network</p>
        
        {/* Item 3: Button (Bottom) */}
        <HeaderLiveButton 
            isLive={isLive} 
            countdownText={countdownText} 
            onClick={() => setActiveScreen('Discover')}
        />
    </div>
    <img
        src="https://nva-network-app.netlify.app/NVA%20Network%20LOGO%20FX.png"
        alt="NVA Network Logo"
        className="headerLogo"
        onError={(e) => { e.target.onerror = null; e.target.src='https://placehold.co/450x150/1A1A1A/FFD700?text=Logo+Error'; }}
    />
</div>

                    {renderScreen()}

                    <div className="navigationBar" style={{ position: 'relative' }}>
    <button className="navButton" onClick={() => setActiveScreen('Home')}>
        <span className={`navButtonText ${activeScreen === 'Home' ? 'activeNavButtonText' : ''}`}>Home</span>
    </button>
    
    {/* ======================= START: NEW NOTIFICATION BELL ======================= */}
    {currentUser && (
        <NotificationBell count={unreadNotifications.filter(n => n.isRead === false).length} onClick={() => setActiveScreen('NotificationInbox')} />
    )}
    {/* ======================== END: NEW NOTIFICATION BELL ======================== */}

    {currentUser && (
        <button className="navButton" onClick={() => setActiveScreen('FollowingFeed')} style={{ backgroundColor: '#0A0A0A', border: '1px solid #FFD700' }}>
            <span className="navButtonText" style={{ color: '#FFD700' }}>Following</span>
        </button>
    )}

    {currentUser && (
        <button className="navButton" onClick={() => setActiveScreen('CreatorDashboard')}>
            <span className={`navButtonText ${activeScreen === 'CreatorDashboard' ? 'activeNavButtonText' : ''}`}>Dashboard</span>
        </button>
    )}
    
    {currentUser && creatorProfile && (creatorProfile.role === 'admin' || creatorProfile.role === 'authority') && (
        <button className="navButton" onClick={() => setActiveScreen('AdminDashboard')}>
            <span className={`navButtonText ${activeScreen === 'AdminDashboard' ? 'activeNavButtonText' : ''}`}>Admin</span>
        </button>
    )}

    <button className="navButton" onClick={() => setShowMoreMenu(!showMoreMenu)}>
        <span className="navButtonText">More</span>
    </button>

    {showMoreMenu && (
        <div style={{
            position: 'absolute',
            bottom: '60px',
            right: '15px',
            backgroundColor: '#1A1A1A',
            borderRadius: '10px',
            boxShadow: '0 -2px 10px rgba(0,0,0,0.5)',
            border: '1px solid #333',
            zIndex: 1100,
            display: 'flex',
            flexDirection: 'column',
            gap: '5px',
            padding: '10px'
        }}>
            {currentUser && (
                <button className="navButton" style={{width: '100%'}} onClick={() => { setActiveScreen('Premium'); setShowMoreMenu(false); }}>
                    <span className="navButtonText">Premium</span>
                </button>
            )}
            <button className="navButton" style={{width: '100%'}} onClick={() => { setActiveScreen('About'); setShowMoreMenu(false); }}>
                <span className="navButtonText">About</span>
            </button>
            <button className="navButton" style={{width: '100%'}} onClick={() => { setActiveScreen('Contact'); setShowMoreMenu(false); }}>
                <span className="navButtonText">Contact</span>
            </button>
        </div>
    )}
</div>

                    <>
                        {message && (
                            <div className="messageBox">
                                <p className="messageText">{message}</p>
                            </div>
                        )}

                        {/* ======================= START: REPURPOSED TOAST COMPONENT ======================= */}
                        <NotificationToast notification={currentToast} onClick={handleToastClick} onTimeout={handleToastTimeout} />
                        {/* ======================== END: REPURPOSED TOAST COMPONENT ======================== */}

                        {showVideoModal && (
                        <VideoPlayerModal
                            videoUrl={currentVideoUrl}
                            onClose={closeVideoModal}
                            contentItem={currentContentItem}
                            currentUser={currentUser}
                            showMessage={showMessage}
                        />
                    )}
                            
                        {showConfirmationModal && (
                            <ConfirmationModal
                                title={confirmationTitle}
                                message={confirmationMessage}
                                onConfirm={onConfirmationAction}
                                onCancel={() => setShowConfirmationModal(false)}
                            />
                        )}
                    </>
                  </div>
                );
            } // <--- PASTE THE MISSING CLOSING BRACE HERE

                // --- END OF CORRECTED BLOCK ---

                window.onload = function() {
            if (
                typeof window.firebaseAuth === 'undefined' ||
                typeof window.onAuthStateChanged === 'undefined' ||
                typeof window.firebaseDb === 'undefined' ||
                typeof window.firebaseStorage === 'undefined' ||
                typeof ReactDOM === 'undefined'
            ) {
                console.error("Firebase or ReactDOM not fully initialized. Retrying render...");
                setTimeout(window.onload, 100);
                return;
            }

            const root = ReactDOM.createRoot(document.getElementById('root'));
            root.render(<App />);
        };
    </script>
</body>
</html>
