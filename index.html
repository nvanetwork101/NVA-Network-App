<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NVA Network</title>
    <!-- React and ReactDOM CDNs - Added 'defer' attribute -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js" defer></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" defer></script>
    <!-- Babel for JSX transformation in browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Firebase SDKs -->
    <script type="module" defer>
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, updateDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getStorage, ref, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-storage.js";
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-analytics.js";

        // Global Firebase variables (provided by Canvas environment)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Your web app's Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyDUGp5pjqrushhUDPa9RLLp2xmttnKqU9Q",
            authDomain: "nvanetworkapp.firebaseapp.com",
            projectId: "nvanetworkapp",
            storageBucket: "nvanetworkapp.firebasestorage.app",
            messagingSenderId: "122220543439",
            appId: "1:122220543439:web:e36cced435463b7939a6ba",
            measurementId: "G-6RNS6DH3G0"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const storage = getStorage(app); // Initialize Storage
        const analytics = getAnalytics(app);

        // Export for use in React component
        window.firebaseApp = app;
        window.firebaseAuth = auth;
        window.firebaseDb = db;
        window.firebaseStorage = storage; // Export Storage
        window.initialAuthToken = initialAuthToken; // Export corrected initialAuthToken
        window.createUserWithEmailAndPassword = createUserWithEmailAndPassword; // Expose the function itself
        window.signInWithEmailAndPassword = signInWithEmailAndPassword; // Expose sign-in function
        window.signOut = signOut; // Expose sign-out function
        window.onAuthStateChanged = onAuthStateChanged; // Expose auth state listener
        window.doc = doc; // Expose Firestore doc
        window.setDoc = setDoc; // Expose Firestore setDoc
        window.getDoc = getDoc; // Expose Firestore getDoc
        window.updateDoc = updateDoc; // Expose Firestore updateDoc
        window.ref = ref; // Expose Storage ref
        window.uploadBytes = uploadBytes; // Storage uploadBytes function
        window.getDownloadURL = getDownloadURL; // Storage getDownloadURL function
    </script>

    <!-- Google Fonts - Bebas Neue for title, Inter for body -->
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Inter:wght@400;600;700&display=swap" rel="stylesheet">

    <!-- PWA Enhancements START -->
    <!-- Link to your web app manifest file -->
    <link rel="manifest" href="/manifest.json">
    <!-- Apple Touch Icon for iOS home screen -->
    <link rel="apple-touch-icon" href="/icon-192x192.png">
    <!-- Theme color for browser UI (e.g., status bar on Android) -->
    <meta name="theme-color" content="#0A0A0A">
    <!-- PWA Enhancements END -->

    <style>
        html, body {
            height: 100%; /* Ensure html and body take full height */
            margin: 0;
            padding: 0;
        }
        body {
            font-family: 'Inter', sans-serif; /* Using Inter font as per instructions */
            background-color: #0A0A0A;
            color: #FFF;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to top to allow scrolling from the top */
            min-height: 100vh; /* Ensure body is at least viewport height */
            overflow-y: auto; /* Allow vertical scrolling for the entire body */
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
        }
        #root {
            width: 100%;
            max-width: 450px; /* Typical mobile width constraint */
            /* Removed height: 100vh; to allow it to expand with content */
            background-color: #0A0A0A;
            display: flex;
            flex-direction: column;
            border-radius: 15px; /* Rounded corners for the main app container */
            /* Removed overflow: hidden; to allow content to push height */
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            min-height: 100vh; /* Ensure #root is at least viewport height */
        }
        .container {
            flex: 1;
            background-color: #0A0A0A; /* Dark background */
            display: flex;
            flex-direction: column;
        }
        .header {
            position: relative; /* For absolute positioning of children and pseudo-element */
            height: 150px; /* Header height */
            padding: 0; /* No padding */
            background-color: #1A1A1A;
            border-bottom: 1px solid #333;
            border-radius: 15px 15px 0 0; /* Rounded top corners */
            overflow: hidden; /* Ensure content stays within bounds */
            z-index: 0; /* Establish a stacking context for its children */
        }
        /* Abstract grey art background for header, behind text */
        /* Removed .header::before rule */
        .headerTitle {
            position: absolute;
            top: 15px;
            left: 15px;
            font-size: 28px;
            font-weight: bold;
            color: #FFD700; /* Gold color for branding */
            z-index: 3; /* Ensure it's above the abstract art */
            text-shadow: 1px 1px 3px rgba(0,0,0,0.7); /* Add subtle shadow for readability */
            font-family: 'Bebas Neue', sans-serif; /* Applied new font */
            font-size: 38px; /* Slightly larger for impact */
        }
        .headerLogo {
            position: absolute; /* Position absolutely to cover the header */
            top: 0;
            left: 0;
            width: 100%; /* Make it cover the full width */
            height: 100%;
            object-fit: cover; /* Ensures the image covers the entire area, cropping if necessary */
            z-index: 1; /* Place at the bottom layer of header content */
            /* Fallback styles for placeholder/error */
            background-color: #333; /* Fallback background for logo area */
            color: #FFF;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 14px;
            text-align: center;
        }
        .tagline {
            position: absolute;
            bottom: 15px; /* Position at the bottom left */
            left: 15px; /* Position at the bottom left */
            font-size: 14px;
            color: #AAA; /* Original color */
            font-weight: normal; /* Original font weight */
            text-align: left; /* Align text to the left */
            z-index: 3; /* Ensure it's above the abstract art */
            text-shadow: 1px 1px 3px rgba(0,0,0,0.7); /* Add subtle shadow for readability */
        }
        .navigationBar {
            display: flex;
            justify-content: space-around;
            padding: 10px 0;
            background-color: #1A1A1A;
            border-top: 1px solid #333;
            border-radius: 0 0 15px 15px; /* Rounded bottom corners */
            /* Removed flex-wrap and gap as Support Us is moved */
        }
        .navButton {
            padding: 8px 15px;
            border-radius: 25px; /* Adjusted for consistency with other buttons */
            cursor: pointer;
            transition: background-color 0.3s ease;
            background-color: #FFD700; /* Changed to gold for visibility */
            box-shadow: 0 4px 5px rgba(0, 0, 0, 0.3); /* Added shadow for consistency */
            border: none; /* Removed border */
        }
        .navButton:hover {
            background-color: #FFC400;
        }
        .navButtonText {
            color: #0A0A0A; /* Changed to black for visibility */
            font-size: 14px;
            font-weight: 600;
        }
        .activeNavButtonText {
            color: #0A0A0A; /* Changed to black for visibility on gold background */
        }
        .screenContainer {
            flex: 1;
            padding: 15px;
            /* Removed overflow-y: auto; here as body will handle overall scrolling */
            position: relative; /* Added for positioning the new support button */
        }
        .sectionTitle {
            font-size: 20px;
            font-weight: bold;
            color: #FFF;
            margin-bottom: 15px;
            margin-top: 20px;
        }
        .contentGrid {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
        }
        .contentCard {
            width: calc(50% - 7.5px); /* Roughly half width for two columns with spacing */
            margin-bottom: 15px;
            background-color: #2A2A2A;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.8);
            cursor: pointer;
            transition: transform 0.2s ease;
        }
        .contentCard:hover {
            transform: translateY(-3px);
        }
        .thumbnailPlaceholder {
            width: 100%;
            height: 100px;
            background-color: #444;
            display: flex;
            flex-direction: column; /* To stack text and icon */
            justify-content: center;
            align-items: center;
            position: relative; /* For play icon positioning */
        }
        .thumbnailText {
            color: #FFF;
            font-size: 12px;
            margin-bottom: 5px; /* Space between text and icon */
        }
        .playIcon {
            width: 30px;
            height: 30px;
            fill: #FFD700; /* Gold color for play icon */
            opacity: 0.8;
        }
        .contentTitle {
            font-size: 14px;
            font-weight: bold;
            color: #FFF;
            padding: 10px;
        }
        .categoryTabs {
            margin-bottom: 15px;
            height: 40px;
            display: flex;
            overflow-x: auto; /* Enable horizontal scrolling for tabs */
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
            padding-bottom: 5px; /* Space for scrollbar */
        }
        .categoryTab {
            padding: 8px 15px;
            border-radius: 20px;
            background-color: #3A3A3A;
            margin-right: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 0; /* Prevent tabs from shrinking */
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .categoryTab:hover {
            background-color: #4A4A4A;
        }
        .activeCategoryTab {
            background-color: #FFD700; /* Gold highlight for active category */
        }
        .categoryTabText {
            color: #FFF;
            font-weight: 600;
            white-space: nowrap; /* Prevent text wrapping */
        }
        .activeCategoryTabText {
            color: #0A0A0A; /* Dark text on gold background */
        }
        .categoryContent {
            flex: 1;
            /* Removed overflow-y: auto; here as body will handle overall scrolling */
        }
        /* Horizontal Carousel Styles (Featured Highlights) */
        .horizontal-carousel-container {
            width: 100%;
            overflow-x: hidden; /* Hide scrollbar, manage scrolling with JS */
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
            scroll-snap-type: x mandatory; /* Snap to items */
            scroll-behavior: smooth; /* Smooth scrolling animation */
            display: flex; /* Arrange items in a row */
            padding-bottom: 10px; /* Space for scrollbar */
            margin-bottom: 20px; /* Space below carousel */
        }

        .horizontal-carousel-item {
            flex: 0 0 calc(33.33% - 10px); /* Show 3 items, account for margin */
            margin-right: 15px; /* Spacing between items */
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.8);
            scroll-snap-align: start; /* Snap to the start of each item */
            background-color: #2A2A2A; /* Placeholder background */
            display: flex;
            justify-content: center;
            align-items: center;
            color: #FFF;
            font-size: 12px;
            height: 100px; /* Fixed height for carousel images */
        }
        .horizontal-carousel-item:last-child {
            margin-right: 0; /* No margin on the last item */
        }
        .carousel-image {
            width: 100%;
            height: 100%;
            object-fit: cover; /* Cover the item area */
            border-radius: 10px; /* Inherit border-radius */
        }

        /* Vertical Carousel Styles (Live Feed) */
        .vertical-carousel-container {
            width: 100%;
            height: 250px; /* Fixed height for vertical carousel to show ~2 items */
            overflow-y: hidden; /* Hide scrollbar, manage scrolling with JS */
            -webkit-overflow-scrolling: touch; /* Enable touch scrolling */
            scroll-snap-type: y mandatory; /* Snap to items */
            scroll-behavior: smooth; /* Smooth scrolling animation */
            display: flex;
            flex-direction: column; /* Arrange items in a column */
            margin-bottom: 20px;
            background-color: #1A1A1A; /* Background for the carousel area */
            border-radius: 10px;
            padding: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.8);
        }

        .vertical-carousel-item {
            flex: 0 0 calc(50% - 10px); /* Show 2 items per view, with a gap */
            margin-bottom: 15px; /* Space between items */
            background-color: #2A2A2A;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
            scroll-snap-align: start; /* Snap to the start of each item */
            display: flex;
            align-items: center;
            padding: 10px;
        }

        .vertical-carousel-item:last-child {
            margin-bottom: 0;
        }

        .liveFeedThumbnail {
            width: 80px; /* Fixed width for live feed thumbnails */
            height: 60px; /* Fixed height for live feed thumbnails (16:9 aspect ratio) */
            object-fit: cover;
            border-radius: 8px;
            margin-right: 10px;
        }

        .liveFeedContent {
            flex-grow: 1;
        }

        .liveFeedTitle {
            font-size: 14px;
            font-weight: bold;
            color: #FFF;
            margin-bottom: 5px;
        }

        .liveFeedCreator {
            font-size: 12px;
            color: #AAA;
        }

        .heading {
            font-size: 24px;
            font-weight: bold;
            color: #FFD700;
            margin-bottom: 10px;
            text-align: center;
        }
        .subHeading {
            font-size: 16px;
            color: #FFF;
            margin-bottom: 20px;
            text-align: center;
        }
        .paragraph {
            font-size: 14px;
            color: #CCC;
            margin-bottom: 10px;
            line-height: 20px;
        }
        .button {
            background-color: #FFD700;
            padding: 12px 25px;
            border-radius: 25px;
            align-self: center;
            margin-top: 20px;
            margin-bottom: 10px;
            box-shadow: 0 4px 5px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            border: none;
            transition: background-color 0.3s ease;
        }
        .button:hover {
            background-color: #FFC400;
        }
        .buttonText {
            color: #0A0A0A;
            font-size: 16px;
            font-weight: bold;
            text-align: center;
        }
        .smallText {
            font-size: 12px;
            color: #888;
            text-align: center;
            margin-bottom: 10px;
        }
        .listItem {
            font-size: 14px;
            color: #CCC;
            margin-left: 15px;
            margin-bottom: 5px;
        }
        .premiumFeatureCard {
            background-color: #2A2A2A;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
        }
        .premiumFeatureTitle {
            font-size: 18px;
            font-weight: bold;
            color: #FFD700;
            margin-bottom: 5px;
        }
        .premiumFeatureDescription {
            font-size: 14px;
            color: #CCC;
            line-height: 20px;
        }
        .pricingTable {
            background-color: #2A2A2A;
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
        }
        .pricingRow {
            display: flex;
            justify-content: space-between;
            padding-top: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid #333;
        }
        .pricingRow:last-child {
            border-bottom: none; /* No border for the last row */
        }
        .pricingTier {
            font-size: 16px;
            font-weight: bold;
            color: #FFD700;
            flex: 1;
        }
        .pricingFeatures {
            font-size: 14px;
            color: #CCC;
            flex: 2;
            text-align: left;
            margin-left: 10px;
        }
        .pricingPrice {
            font-size: 16px;
            font-weight: bold;
            color: #FFF;
            flex: 1;
            text-align: right;
        }
        .contactInfo {
            font-size: 14px;
            color: #CCC;
            margin-bottom: 5px;
        }
        .messageBox {
            position: fixed; /* Use fixed for overlay */
            bottom: 100px; /* Above navigation bar */
            left: 50%;
            transform: translateX(-50%); /* Center horizontally */
            background-color: rgba(0, 0, 0, 0.8);
            padding: 12px 20px;
            border-radius: 8px;
            z-index: 1000;
            opacity: 1;
            transition: opacity 0.3s ease-in-out;
            pointer-events: none; /* Allow clicks to pass through */
            max-width: 90%;
        }
        .messageBox.hidden {
            opacity: 0;
        }
        .messageText {
            color: #FFF;
            text-align: center;
            font-size: 14px;
        }
        /* Video Modal Styles */
        .videoModalOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .videoModalContent {
            background-color: #1A1A1A;
            border-radius: 10px;
            width: 95vw; /* Make it take 95% of viewport width */
            height: 95vh; /* Make it take 95% of viewport height */
            max-width: 1200px; /* Cap maximum width for very large screens */
            max-height: 800px; /* Cap maximum height for very large screens to maintain aspect ratio */
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
            position: relative;
            display: flex; /* Enable flex for vertical centering of iframe */
            flex-direction: column;
            justify-content: center; /* Center content vertically */
            align-items: center; /* Center content horizontally */
        }
        .videoIframeContainer {
            position: relative;
            width: 100%;
            padding-bottom: 56.25%; /* 16:9 Aspect Ratio (height relative to width) */
            height: 0; /* Important for padding-bottom trick */
            overflow: hidden;
        }
        .videoIframeContainer iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
        }
        .closeButton {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(255, 255, 255, 0.2);
            color: #FFF;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 10; /* Ensure it's above the iframe */
        }

        /* Styles for buttons at the top of the Home screen */
        .topRightButtonContainer {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            gap: 10px; /* Space between buttons */
            z-index: 10;
        }

        .topButton {
            background-color: #FFD700; /* Gold color */
            color: #0A0A0A; /* Dark text */
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px; /* Smaller font for a compact button */
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            border: none;
            transition: background-color 0.3s ease;
        }
        .topButton:hover {
            background-color: #FFC400;
        }


        /* Styles for Creator Campaign Cards */
        .campaignCard {
            background-color: #2A2A2A;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
        }
        .campaignTitle {
            font-size: 18px;
            font-weight: bold;
            color: #FFD700;
            margin-bottom: 5px;
        }
        .campaignCreator {
            font-size: 14px;
            color: #CCC;
            margin-bottom: 10px;
        }
        .campaignDescription {
            font-size: 14px;
            color: #AAA;
            line-height: 1.5;
            margin-bottom: 10px;
        }
        .campaignProgressContainer {
            width: 100%;
            background-color: #444;
            border-radius: 5px;
            height: 10px;
            margin-bottom: 5px;
            overflow: hidden; /* Ensure progress bar stays within bounds */
        }
        .campaignProgressBar {
            height: 100%;
            background-color: #FFD700;
            border-radius: 5px;
            transition: width 0.5s ease-in-out;
        }
        .campaignStats {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #CCC;
            margin-bottom: 15px;
        }
        .campaignGoal, .campaignRaised {
            font-weight: bold;
            color: #FFF;
        }
        .campaignButton {
            background-color: #FFD700;
            padding: 10px 15px;
            border-radius: 20px;
            color: #0A0A0A;
            font-weight: bold;
            text-align: center;
            cursor: pointer;
            border: none;
            transition: background-color 0.3s ease;
        }
        .campaignButton:hover {
            background-color: #FFC400;
        }

        /* Styles for Creator Sign Up Form */
        .formGroup {
            margin-bottom: 15px;
        }
        .formLabel {
            display: block;
            font-size: 14px;
            color: #FFF;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .formInput, .formTextarea {
            width: calc(100% - 20px); /* Account for padding */
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #555;
            background-color: #333;
            color: #FFF;
            font-size: 14px;
        }
        .formTextarea {
            resize: vertical; /* Allow vertical resizing */
            min-height: 80px;
        }
        .checkboxGroup {
            margin-bottom: 15px;
        }
        .checkboxLabel {
            display: block;
            font-size: 14px;
            color: #FFF;
            margin-bottom: 8px;
            font-weight: bold;
        }
        .checkboxItem {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .checkboxItem input[type="checkbox"] {
            margin-right: 8px;
            width: 18px; /* Larger checkbox for touch */
            height: 18px;
            accent-color: #FFD700; /* Highlight checkbox */
        }
        .termsText {
            font-size: 12px;
            color: #AAA;
            margin-top: 10px;
            line-height: 1.4;
        }
        .termsLink {
            color: #FFD700;
            text-decoration: none;
            font-weight: bold;
        }
        .termsLink:hover {
            text-decoration: underline;
        }

        /* Styles for Creator Dashboard */
        .dashboardSection {
            background-color: #2A2A2A;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
        }
        .dashboardSectionTitle {
            font-size: 18px;
            font-weight: bold;
            color: #FFD700;
            margin-bottom: 10px;
        }
        .dashboardItem {
            font-size: 14px;
            color: #CCC;
            margin-bottom: 8px;
            line-height: 1.4;
        }
        .dashboardButton {
            background-color: #FFD700;
            padding: 8px 15px;
            border-radius: 20px;
            color: #0A0A0A;
            font-weight: bold;
            cursor: pointer;
            border: none;
            transition: background-color 0.3s ease;
            margin-top: 10px;
            margin-right: 10px;
        }
        .dashboardButton:hover {
            background-color: #FFC400;
        }
        .dashboardContentList {
            margin-top: 10px;
            padding-left: 0; /* Remove default ul padding */
            list-style: none; /* Remove bullet points */
        }
        .dashboardContentListItem {
            background-color: #3A3A3A;
            padding: 8px 12px;
            border-radius: 8px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
            color: #FFF;
        }
        .dashboardContentListItem span {
            flex-grow: 1;
        }
        .dashboardContentListItem .actionButton {
            background-color: #555;
            color: #FFF;
            border: none;
            padding: 5px 10px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 12px;
            margin-left: 10px;
            transition: background-color 0.2s ease;
        }
        .dashboardContentListItem .actionButton:hover {
            background-color: #777;
        }

        /* New styles for video link sections in dashboard */
        .videoLinkSection {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #333;
        }
        .videoLinkSection:last-child {
            border-bottom: none;
            padding-bottom: 0;
        }
        .videoLinkSection .formLabel {
            margin-bottom: 10px;
            font-size: 16px;
            color: #FFD700;
        }
        .videoInputContainer {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        .videoInputContainer .formInput {
            flex-grow: 1;
        }
        .videoThumbnailContainer {
            position: relative;
            width: 100%;
            height: 150px; /* Fixed height for thumbnails */
            background-color: #444;
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 10px;
            cursor: pointer; /* Indicate clickable */
        }
        .videoThumbnail {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .videoThumbnailOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.4);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .thumbnailPlayIcon {
            width: 40px;
            height: 40px;
            fill: #FFF;
            opacity: 0.9;
        }
        .videoActions {
            display: flex;
            justify-content: flex-end; /* Align buttons to the right */
            gap: 10px;
        }
        .videoActions .actionButton {
            background-color: #FFD700;
            color: #0A0A0A;
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: bold;
            cursor: pointer;
            border: none;
            transition: background-color 0.3s ease;
        }
        .videoActions .actionButton.remove {
            background-color: #DC3545; /* Red for remove */
            color: #FFF;
        }
        .videoActions .actionButton:hover {
            background-color: #FFC400;
        }
        .videoActions .actionButton.remove:hover {
            background-color: #C82333;
        }
        /* New styles for login form */
        .loginForm {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .loginForm .button {
            width: 100%;
        }
        /* New styling for section title with aligned button */
        .sectionHeaderWithButton {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px; /* Space below the header container */
            margin-top: 20px;
        }
        .sectionHeaderWithButton .sectionTitle {
            margin: 0; /* Remove default margins from p tag when in flex container */
        }
        /* Adjust .topButton styles for this context if needed, or create a new class */
        .sectionHeaderButton {
            background-color: #FFD700; /* Gold color */
            color: #0A0A0A; /* Dark text */
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px; /* Smaller font for a compact button */
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            border: none;
            transition: background-color 0.3s ease;
        }
        .sectionHeaderButton:hover {
            background-color: #FFC400;
        }

        /* Profile Picture Adjustment Modal Styles */
        .imageAdjustModalOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95); /* More opaque */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000; /* Higher z-index than video modal */
            flex-direction: column;
            gap: 20px;
        }

        .imageAdjustModalContent {
            background-color: #1A1A1A;
            border-radius: 15px;
            padding: 20px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .canvasContainer {
            position: relative;
            width: 200px; /* Fixed size for the canvas view */
            height: 200px;
            border-radius: 50%; /* Circular clipping for the preview */
            overflow: hidden;
            border: 2px solid #FFD700; /* Gold border for the circle */
            background-color: #333; /* Fallback background */
            margin-bottom: 20px;
            cursor: grab; /* Indicate draggable */
        }

        .canvasContainer.dragging {
            cursor: grabbing;
        }

        canvas {
            display: block; /* Remove extra space below canvas */
            touch-action: none; /* Prevent default touch actions like scrolling/zooming by OS */
        }

        .modalButtons {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }

        .modalButton {
            background-color: #FFD700;
            color: #0A0A0A;
            padding: 10px 20px;
            border-radius: 25px;
            font-weight: bold;
            cursor: pointer;
            border: none;
            transition: background-color 0.3s ease;
        }

        .modalButton:hover {
            background-color: #FFC400;
        }

        .modalButton.cancel {
            background-color: #555;
            color: #FFF;
        }

        .modalButton.cancel:hover {
            background-color: #777;
        }

        /* Styles for Zoom Controls */
        .zoomControls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            align-items: center;
        }
        .zoomButton {
            background-color: #3A3A3A;
            color: #FFD700;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 1px solid #FFD700;
            font-size: 24px;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .zoomButton:hover {
            background-color: #4A4A4A;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        const auth = window.firebaseAuth;
        const db = window.firebaseDb;
        const storage = window.firebaseStorage; // Get Storage instance
        const createUserWithEmailAndPassword = window.createUserWithEmailAndPassword;
        const signInWithEmailAndPassword = window.signInWithEmailAndPassword;
        const signOut = window.signOut;
        const onAuthStateChanged = window.onAuthStateChanged;
        const doc = window.doc; // Firestore doc function
        const setDoc = window.setDoc; // Firestore setDoc function
        const getDoc = window.getDoc; // Firestore getDoc function
        const updateDoc = window.updateDoc; // Firestore updateDoc function
        const ref = window.ref; // Expose Storage ref
        const uploadBytes = window.uploadBytes; // Storage uploadBytes function
        const getDownloadURL = window.getDownloadURL; // Storage getDownloadURL function


        // --- Placeholder Data ---
        const featuredContent = [
            { id: '1', title: 'Guyanese Comedy Special', type: 'skit', url: 'https://www.youtube.com/embed/dQw4w9WgXcQ?autoplay=1', creator: 'Comedy Crew' },
            { id: '2', title: 'Top Guyanese Skits: Best of 2024', type: 'skit', url: 'https://www.youtube.com/embed/oHg5SJYRHA0?autoplay=1', creator: 'Laugh Central' },
            { id: '3', title: 'Indie Film: "Georgetown Dreams"', type: 'short-film', url: 'https://www.youtube.com/embed/34Na4j8AVgA?autoplay=1', creator: 'Indie Films GY' },
            { id: '4', title: 'Live Concert Replay: Mashramani', type: 'live-premiere', url: 'https://www.youtube.com/embed/example4?autoplay=1', creator: 'Vibes Ent.' },
            { id: '5', title: 'Creator Interview: Rise of Talent', type: 'interview', url: 'https://www.youtube.com/embed/example5?autoplay=1', creator: 'NVA Insights' },
            { id: '6', title: 'Short Film: "The Golden Arrowhead"', type: 'short-film', url: 'https://www.youtube.com/embed/example6?autoplay=1', creator: 'Heritage Films' },
            { id: '7', title: 'New Skit Series: "Life in GT"', type: 'skit', url: 'https://www.youtube.com/embed/skit7?autoplay=1', creator: 'GT Daily' },
            { id: '8', title: 'Cooking Show: Guyanese Delights', type: 'skit', url: 'https://www.youtube.com/embed/skit8?autoplay=1', creator: 'Chef Roti' },
            { id: '9', title: 'Poetry Slam Live: Best of Season', type: 'live-premiere', url: 'https://www.youtube.com/embed/live9?autoplay=1', creator: 'Wordsmiths GY' },
            { id: '10', title: 'Wildlife Doc: Amazonian Secrets', type: 'documentary', url: 'https://www.youtube.com/embed/doc1?autoplay=1', creator: 'Nature Watch' },
            { id: '11', title: 'Guyanese Music Spotlight', type: 'music', url: 'https://www.youtube.com/embed/music1?autoplay=1', creator: 'Riddim Connect' },
            { id: '12', title: 'Interview: Young Entrepreneurs', type: 'interview', url: 'https://www.youtube.com/embed/int1?autoplay=1', creator: 'Business Buzz GY' },
        ];


        const categories = {
            Skits: [
                { id: 's1', title: 'Laugh Out Loud: Best Skits Vol. 1', url: 'https://www.youtube.com/embed/skit1?autoplay=1' },
                { id: 's2', title: 'Daily Dose of Guyanese Humor', url: 'https://www.youtube.com/embed/skit2?autoplay=1' },
                { id: 's3', title: 'Guyana Vibes: Street Comedy', url: 'https://www.youtube.com/embed/skit3?autoplay=1' },
                { id: 's4', title: 'Caribbean Laughs: Episode 1', url: 'https://www.youtube.com/embed/skit4?autoplay=1' },
                { id: 's5', title: 'Funny Moments: Local Edition', url: 'https://www.youtube.com/embed/skit5?autoplay=1' },
                { id: 's6', title: 'The Best of Guyanese Skits', url: 'https://www.youtube.com/embed/skit6?autoplay=1' },
                { id: 's7', title: 'New Skit Series: "Life in GT"', url: 'https://www.youtube.com/embed/skit7?autoplay=1' },
                { id: 's8', title: 'Weekend Comedy Mashup', url: 'https://www.youtube.com/embed/skit8?autoplay=1' },
            ],
            'Short Films': [
                { id: 'sf1', title: 'The Golden Arrowhead: A Short Film', url: 'https://www.youtube.com/embed/shortfilm1?autoplay=1' },
                { id: 'sf2', title: 'Tales from the Coast: Episode 1', url: 'https://www.youtube.com/embed/shortfilm2?autoplay=1' },
                { id: 'sf3', title: 'Lost in the Jungle: A Drama', url: 'https://www.youtube.com/embed/shortfilm3?autoplay=1' },
                { id: 'sf4', title: 'The Cane Field Mystery', url: 'https://www.youtube.com/embed/shortfilm4?autoplay=1' },
                { id: 'sf5', title: 'A Day in the Market', url: 'https://www.youtube.com/embed/shortfilm5?autoplay=1' },
                { id: 'sf6', title: 'The Hidden Falls', url: 'https://www.youtube.com/embed/shortfilm6?autoplay=1' },
                { id: 'sf7', title: 'City Lights, Country Dreams', url: 'https://www.youtube.com/embed/shortfilm7?autoplay=1' },
                { id: 'sf8', title: 'Echoes of the Past', url: 'https://www.youtube.com/embed/shortfilm8?autoplay=1' },
            ],
            Interviews: [
                { id: 'i1', title: 'Creator Spotlight: Interview with Mark X', url: 'https://www.youtube.com/embed/interview1?autoplay=1' },
                { id: 'i2', title: 'Behind the Scenes: NVA Network', url: 'https://www.youtube.com/embed/interview2?autoplay=1' },
                { id: 'i3', title: 'Guyanese Icons: A Conversation', url: 'https://www.youtube.com/embed/interview3?autoplay=1' },
                { id: 'i4', title: 'The Future of Guyanese Art', url: 'https://www.youtube.com/embed/interview4?autoplay=1' },
                { id: 'i5', title: 'In-Depth with Local Artists', url: 'https://www.youtube.com/embed/interview5?autoplay=1' },
                { id: 'i6', title: 'Entrepreneurial Journeys in Guyana', url: 'https://www.youtube.com/embed/interview6?autoplay=1' },
                { id: 'i7', title: 'Community Leaders Speak Out', url: 'https://www.youtube.com/embed/interview7?autoplay=1' },
                { id: 'i8', title: 'The Making of a Guyanese Star', url: 'https://www.youtube.com/embed/interview8?autoplay=1' },
            ],
            'Live Premieres': [
                { id: 'lp1', title: 'Upcoming: Guyanese Music Festival Live', url: 'https://www.youtube.com/embed/live1?autoplay=1' },
                { id: 'lp2', title: 'Replay: NVA Network Launch Event', url: 'https://www.youtube.com/embed/live2?autoplay=1' },
                { id: 'lp3', title: 'Live Comedy Night: Best of Guyana', url: 'https://www.youtube.com/embed/live3?autoplay=1' },
                { id: 'lp4', title: 'Red Carpet Gala: NVA Awards', url: 'https://www.youtube.com/embed/live4?autoplay=1' },
                { id: 'lp5', title: 'Exclusive: Talk Show Live', url: 'https://www.youtube.com/embed/live5?autoplay=1' },
                { id: 'lp6', title: 'Poetry Slam Live: Guyana Edition', url: 'https://www.youtube.com/embed/live6?autoplay=1' },
                { id: 'lp7', title: 'Cultural Dance Showcase', url: 'https://www.youtube.com/embed/live7?autoplay=1' },
                { id: 'lp8', title: 'Q&A with Your Favorite Creators', url: 'https://www.youtube.com/embed/live8?autoplay=1' },
            ],
        };

        // --- Placeholder Creator Campaign Data ---
        const creatorCampaigns = [
            {
                id: 'cc1',
                title: 'Fund "The Golden Mango" Short Film',
                creator: 'Guyana Film Collective',
                description: 'Help us produce a heartwarming short film about Guyanese traditions and family values.',
                goal: 5000,
                raised: 3200,
                imageUrl: 'https://placehold.co/150x100/FFD700/0A0A0A?text=Film+Project'
            },
            {
                id: 'cc2',
                title: 'New Comedy Series: "Life in GT"',
                creator: 'Laugh Out Loud Crew',
                description: 'Support our new web series bringing everyday Guyanese humor to your screens!',
                goal: 3000,
                raised: 1800,
                imageUrl: 'https://placehold.co/150x100/FF6347/FFF?text=Comedy+Series'
            },
            {
                id: 'cc3',
                title: 'Music Video Production for Local Artist',
                creator: 'Vibes Music Studio',
                description: 'Help us create a high-quality music video for an emerging Guyanese artist.',
                goal: 2500,
                raised: 250,
                imageUrl: 'https://placehold.co/150x100/4682B4/FFF?text=Music+Video'
            },
            {
                id: 'cc4',
                title: 'Documentary: "Faces of the Interior"',
                creator: 'Guyana Stories Docu',
                description: 'Support our journey to capture the untold stories of communities in Guyana\'s interior.',
                goal: 8000,
                raised: 6000,
                imageUrl: 'https://placehold.co/150x100/6A5ACD/FFF?text=Documentary'
            },
        ];

        // Helper function to extract YouTube video ID and format for embed URL
        const getYouTubeEmbedUrl = (youtubeUrl) => {
            const videoIdMatch = youtubeUrl.match(/(?:youtu\.be\/|youtube\.com\/(?:watch\?v=|embed\/||shorts\/))([^&?#]+)/);
            if (videoIdMatch && videoIdMatch[1]) {
                return `https://www.youtube.com/embed/${videoIdMatch[1]}?autoplay=1&rel=0`; // autoplay and no related videos
            }
            return youtubeUrl; // Return original if not a standard YouTube URL
        };

        // --- Video Player Modal Component ---
        const VideoPlayerModal = ({ videoUrl, onClose }) => {
            if (!videoUrl) return null;

            // Ensure the URL is in embed format
            const embedUrl = getYouTubeEmbedUrl(videoUrl);

            return (
                <div className="videoModalOverlay">
                    <div className="videoModalContent">
                        <button className="closeButton" onClick={onClose}>&times;</button>
                        <div className="videoIframeContainer">
                            <iframe
                                src={embedUrl}
                                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
                                allowFullScreen
                                title="Embedded YouTube video"
                            ></iframe>
                        </div>
                    </div>
                </div>
            );
        };

        // --- Profile Picture Adjustment Modal Component ---
        const ProfilePictureAdjustModal = ({ imageUrl, onSave, onCancel, showMessage }) => {
            const canvasRef = useRef(null);
            const imageRef = useRef(new Image());
            const [scale, setScale] = useState(1);
            const [position, setPosition] = useState({ x: 0, y: 0 }); // Relative to canvas center, in image pixels
            const [isDragging, setIsDragging] = useState(false);
            const [dragStart, setDragStart] = useState({ x: 0, y: 0 }); // Mouse/touch start position

            const canvasSize = 200; // Size of the square canvas (e.g., 200x200 for a 100px diameter circle)
            const devicePixelRatio = window.devicePixelRatio || 1; // For high-DPI displays
            const adjustedCanvasSize = canvasSize * devicePixelRatio; // Adjusted size for high-DPI displays
            const profilePicSize = 300; // Increased output size for profile picture (300x300px)

            // Helper function to constrain position within boundaries
            const constrainPosition = (pos) => {
                const img = imageRef.current;
                if (!img || !img.complete) return pos;
                
                const scaledWidth = img.naturalWidth * scale;
                const scaledHeight = img.naturalHeight * scale;
                
                // Calculate the minimum position to keep at least 25% of the image visible
                const minX = canvasSize - scaledWidth * 0.75;
                const maxX = scaledWidth * 0.75 - canvasSize;
                const minY = canvasSize - scaledHeight * 0.75;
                const maxY = scaledHeight * 0.75 - canvasSize;
                
                return {
                    x: Math.min(maxX, Math.max(minX, pos.x)),
                    y: Math.min(maxY, Math.max(minY, pos.y))
                };
            };

            // Helper function to get relative coordinates
            const getRelativeCoordinates = (clientX, clientY) => {
                const canvas = canvasRef.current;
                if (!canvas) return { x: 0, y: 0 };
                
                const rect = canvas.getBoundingClientRect();
                return {
                    x: clientX - rect.left,
                    y: clientY - rect.top
                };
            };

            // Function to draw image on canvas
            const drawImage = useCallback(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                const img = imageRef.current;

                if (!img.complete || img.naturalWidth === 0) {
                    // Image not loaded yet or invalid, clear canvas and wait
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    return;
                }

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.save(); // Save the current canvas state

                // Apply circular clipping path for preview
                ctx.beginPath();
                ctx.arc(canvasSize / 2, canvasSize / 2, canvasSize / 2, 0, Math.PI * 2, true);
                ctx.closePath();
                ctx.clip();

                // Calculate scaled image dimensions
                const scaledWidth = img.naturalWidth * scale;
                const scaledHeight = img.naturalHeight * scale;

                // Calculate image drawing position to center and apply pan
                const drawX = (canvasSize / 2) - (scaledWidth / 2) + position.x;
                const drawY = (canvasSize / 2) - (scaledHeight / 2) + position.y;

                ctx.drawImage(img, drawX, drawY, scaledWidth, scaledHeight);

                ctx.restore(); // Restore canvas state to remove clipping path for next draw
            }, [scale, position]);


            // Set up canvas for high-DPI displays
            useEffect(() => {
                const canvas = canvasRef.current;
                if (canvas) {
                    // Set the canvas dimensions accounting for device pixel ratio
                    canvas.width = adjustedCanvasSize;
                    canvas.height = adjustedCanvasSize;
                    canvas.style.width = `${canvasSize}px`;
                    canvas.style.height = `${canvasSize}px`;
                    
                    // Scale the context to account for the pixel ratio
                    const ctx = canvas.getContext('2d');
                    ctx.scale(devicePixelRatio, devicePixelRatio);
                }
            }, [adjustedCanvasSize, canvasSize, devicePixelRatio]);

            useEffect(() => {
                const img = imageRef.current;
                img.crossOrigin = 'anonymous'; // Required for manipulating image data from other origins
                img.src = imageUrl;

                img.onload = () => {
                    // Calculate initial scale to ensure the image covers the circular area
                    // while minimizing unnecessary cropping
                    const initialScale = Math.max(canvasSize / img.naturalWidth, canvasSize / img.naturalHeight);
                    
                    // Add a small buffer to ensure the image fully covers the circle
                    const scaledWidth = img.naturalWidth * initialScale;
                    const scaledHeight = img.naturalHeight * initialScale;
                    
                    // If the scaled image is too small in either dimension, increase the scale
                    if (scaledWidth < canvasSize || scaledHeight < canvasSize) {
                        const additionalScale = Math.max(
                            canvasSize / scaledWidth,
                            canvasSize / scaledHeight
                        );
                        setScale(initialScale * additionalScale * 1.05); // Add 5% extra to ensure coverage
                    } else {
                        setScale(initialScale);
                    }
                    
                    setPosition({ x: 0, y: 0 }); // Reset position
                    drawImage();
                };

                img.onerror = () => {
                    showMessage("Failed to load image for adjustment. Please check the image URL.");
                    console.error("Image failed to load for adjustment:", imageUrl);
                };
            }, [imageUrl, drawImage, showMessage, canvasSize]);


            useEffect(() => {
                // console.log('Scale or Position useEffect triggered. Scale:', scale, 'Position:', position); // Debug Log
                drawImage();
            }, [scale, position, drawImage]);

            // --- Mouse / Touch Event Handlers for Panning ---
            const handleMouseDown = (e) => {
                setIsDragging(true);
                const { x, y } = getRelativeCoordinates(e.clientX, e.clientY);
                setDragStart({ x, y });
            };

            const handleMouseMove = (e) => {
                if (!isDragging) return;
                
                const { x, y } = getRelativeCoordinates(e.clientX, e.clientY);
                const dx = x - dragStart.x;
                const dy = y - dragStart.y;
                
                setPosition(prev => {
                    const newPos = { x: prev.x + dx, y: prev.y + dy };
                    return constrainPosition(newPos); // Apply boundary constraints
                });
                
                setDragStart({ x, y });
            };

            const handleMouseUp = () => {
                setIsDragging(false);
            };

            const handleMouseLeave = () => { // Important for when mouse leaves canvas while dragging
                setIsDragging(false);
            };

            // --- Touch Handlers (Pan and Pinch-Zoom) ---
            const lastTouch = useRef([]); // To store multiple touch points for pinch-zoom

            const handleTouchStart = (e) => {
                if (e.touches.length === 1) { // Single touch for pan
                    setIsDragging(true);
                    const { x, y } = getRelativeCoordinates(e.touches[0].clientX, e.touches[0].clientY);
                    setDragStart({ x, y });
                } else if (e.touches.length === 2) { // Two touches for pinch-zoom
                    setIsDragging(false); // Disable panning
                    lastTouch.current = [
                        { x: e.touches[0].clientX, y: e.touches[0].clientY },
                        { x: e.touches[1].clientX, y: e.touches[1].clientY }
                    ];
                }
            };

            const handleTouchMove = (e) => {
                e.preventDefault(); // Prevent page scrolling/zooming

                const canvas = canvasRef.current;
                if (!canvas || !imageRef.current.complete) return;

                if (e.touches.length === 1 && isDragging) { // Pan
                    const { x, y } = getRelativeCoordinates(e.touches[0].clientX, e.touches[0].clientY);
                    const dx = x - dragStart.x;
                    const dy = y - dragStart.y;
                    
                    setPosition(prev => {
                        const newPos = { x: prev.x + dx, y: prev.y + dy };
                        return constrainPosition(newPos); // Apply boundary constraints
                    });
                    
                    setDragStart({ x, y });
                } else if (e.touches.length === 2 && lastTouch.current.length === 2) { // Pinch-zoom
                    const touch1 = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    const touch2 = { x: e.touches[1].clientX, y: e.touches[1].clientY };

                    // Calculate the center point between the two touches
                    const centerX = (touch1.x + touch2.x) / 2;
                    const centerY = (touch1.y + touch2.y) / 2;
                    const centerPoint = getRelativeCoordinates(centerX, centerY);
                    
                    // Calculate distances for zoom
                    const prevDistance = Math.hypot(
                        lastTouch.current[1].x - lastTouch.current[0].x,
                        lastTouch.current[1].y - lastTouch.current[0].y
                    );
                    const currentDistance = Math.hypot(touch2.x - touch1.x, touch2.y - touch1.y);
                    
                    // Calculate zoom factor
                    const zoomFactor = currentDistance / prevDistance;
                    
                    // Update scale and position to zoom toward the center point
                    setScale(prevScale => {
                        const newScale = Math.max(0.1, Math.min(prevScale * zoomFactor, 10));
                        
                        // Adjust position to keep the zoom centered at the touch midpoint
                        setPosition(prevPos => {
                            // Calculate the vector from center to the point under the center
                            const vectorX = centerPoint.x - canvasSize / 2;
                            const vectorY = centerPoint.y - canvasSize / 2;
                            
                            // Adjust the position based on the scale change
                            const newPos = {
                                x: prevPos.x - vectorX * (zoomFactor - 1),
                                y: prevPos.y - vectorY * (zoomFactor - 1)
                            };
                            
                            return constrainPosition(newPos); // Apply boundary constraints
                        });
                        
                        return newScale;
                    });
                    
                    lastTouch.current = [touch1, touch2];
                }
            };

            const handleTouchEnd = () => {
                setIsDragging(false);
                lastTouch.current = [];
            };

            // --- Mouse Wheel Zoom ---
            const handleWheel = (e) => {
                e.preventDefault(); // Prevent page scrolling
                const zoomAmount = 0.1; // How much to zoom per scroll tick
                const newScale = e.deltaY < 0 ? scale + zoomAmount : scale - zoomAmount;
                setScale(s => {
                    const finalScale = Math.max(0.1, Math.min(newScale, 10));
                    // console.log('Wheel - New Scale:', finalScale); // Debug Log
                    return finalScale;
                });
            };

            // --- Save Cropped Image ---
            const saveCroppedImage = () => {
                const img = imageRef.current;
                if (!img.complete || img.naturalWidth === 0) {
                    showMessage("Image not loaded for saving. Please try again.");
                    return;
                }

                const outputCanvas = document.createElement('canvas');
                outputCanvas.width = profilePicSize;
                outputCanvas.height = profilePicSize;
                const ctx = outputCanvas.getContext('2d');

                // Apply circular clipping path to output canvas
                ctx.beginPath();
                ctx.arc(profilePicSize / 2, profilePicSize / 2, profilePicSize / 2, 0, Math.PI * 2, true);
                ctx.closePath();
                ctx.clip();

                // Optional: Add a white background to ensure transparent areas are filled
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, profilePicSize, profilePicSize);

                // Calculate the portion of the source image to draw into the target profile pic size
                const scaledWidth = img.naturalWidth * scale;
                const scaledHeight = img.naturalHeight * scale;

                // Calculate the center of the visible area in the original image coordinates
                const visibleCenterX = (scaledWidth / 2 - position.x) / scale;
                const visibleCenterY = (scaledHeight / 2 - position.y) / scale;

                // Calculate the visible area dimensions in the original image coordinates
                const visibleWidth = canvasSize / scale;
                const visibleHeight = canvasSize / scale;

                // Calculate the top-left corner of the visible area
                const sourceX = visibleCenterX - visibleWidth / 2;
                const sourceY = visibleCenterY - visibleHeight / 2;
                const sourceWidth = visibleWidth;
                const sourceHeight = visibleHeight;

                ctx.drawImage(
                    img,
                    sourceX, // Source X
                    sourceY, // Source Y
                    sourceWidth, // Source Width (from img, based on scale of original to canvas circle)
                    sourceHeight, // Source Height (from img, based on scale of original to canvas circle)
                    0, // Destination X on output canvas
                    0, // Destination Y on output canvas
                    profilePicSize, // Destination Width on output canvas
                    profilePicSize // Destination Height on output canvas
                );

                // Convert canvas to Blob (PNG for transparent backgrounds or JPEG for solid)
                outputCanvas.toBlob((blob) => {
                    if (blob) {
                        onSave(blob); // Pass the Blob to the parent's upload handler
                    } else {
                        showMessage("Failed to create image file. Please try again.");
                    }
                }, 'image/png', 0.9); // Use PNG for potential transparency, quality 0.9
            };

            return (
                <div className="imageAdjustModalOverlay">
                    <div className="imageAdjustModalContent">
                        <p className="heading" style={{fontSize: '20px', marginBottom: '10px'}}>Adjust Profile Picture</p>
                        <p className="subHeading" style={{fontSize: '14px', marginBottom: '15px', color: '#CCC'}}>Drag to pan, scroll/pinch to zoom.</p>
                        <div
                            className={`canvasContainer ${isDragging ? 'dragging' : ''}`}
                            onMouseDown={handleMouseDown}
                            onMouseMove={handleMouseMove}
                            onMouseUp={handleMouseUp}
                            onMouseLeave={handleMouseLeave}
                            onWheel={handleWheel}
                            onTouchStart={handleTouchStart}
                            onTouchMove={handleTouchMove}
                            onTouchEnd={handleTouchEnd}
                        >
                            <canvas
                                ref={canvasRef}
                                width={canvasSize}
                                height={canvasSize}
                            ></canvas>
                        </div>
                        <div className="zoomControls">
                            <button className="zoomButton" onClick={() => setScale(s => Math.max(0.1, s - 0.1))}>-</button>
                            <span style={{color: '#FFF', fontSize: '16px'}}>Zoom: {Math.round(scale * 100)}%</span>
                            <button className="zoomButton" onClick={() => setScale(s => Math.min(10, s + 0.1))}>+</button>
                        </div>
                        <button
                            className="modalButton"
                            onClick={() => {
                                // Reset to initial position and scale
                                const img = imageRef.current;
                                if (img && img.complete) {
                                    const initialScale = Math.max(canvasSize / img.naturalWidth, canvasSize / img.naturalHeight);
                                    const scaledWidth = img.naturalWidth * initialScale;
                                    const scaledHeight = img.naturalHeight * initialScale;
                                    
                                    if (scaledWidth < canvasSize || scaledHeight < canvasSize) {
                                        const additionalScale = Math.max(
                                            canvasSize / scaledWidth,
                                            canvasSize / scaledHeight
                                        );
                                        setScale(initialScale * additionalScale * 1.05);
                                    } else {
                                        setScale(initialScale);
                                    }
                                    setPosition({ x: 0, y: 0 });
                                }
                            }}
                            style={{marginTop: '10px', backgroundColor: '#555', color: '#FFF'}}
                        >
                            Reset Image
                        </button>
                        <div className="modalButtons">
                            <button className="modalButton" onClick={saveCroppedImage}>Save</button>
                            <button className="modalButton cancel" onClick={onCancel}>Cancel</button>
                        </div>
                    </div>
                </div>
            );
        };


        // --- Main App Component ---
        function App() {
            const [currentUser, setCurrentUser] = useState(null);
            const [activeScreen, setActiveScreen] = useState('Home');

            const [activeCategory, setActiveCategory] = useState('Skits');
            const [message, setMessage] = useState('');
            const [showVideoModal, setShowVideoModal] = useState(false);
            const [currentVideoUrl, setCurrentVideoUrl] = useState('');

            // State for profile picture adjustment modal
            const [showImageAdjustModal, setShowImageAdjustModal] = useState(false);
            const [imageFileToAdjust, setImageFileToAdjust] = useState(null); // File object passed to the modal

            useEffect(() => {
                const unsubscribe = onAuthStateChanged(auth, (user) => {
                    setCurrentUser(user);
                });
                return () => unsubscribe();
            }, []);

            // Placeholder images for the carousel - Duplicated for continuous loop
            const originalCarouselImages = [
                'https://placehold.co/140x100/A0A0A0/000?text=Comedy+Night',
                'https://placehold.co/140x100/808080/FFF?text=New+Series',
                'https://placehold.co/140x100/606060/EEE?text=Exclusive',
                'https://placehold.co/140x100/404040/DDD?text=Behind+Scenes',
                'https://placehold.co/140x100/202020/CCC?text=Live+Event',
            ];
            const carouselImages = [...originalCarouselImages, ...originalCarouselImages, ...originalCarouselImages];

            // Placeholder data for the Live Feed Vertical Carousel
            const originalLiveFeedContent = [
                { id: 'lf1', title: 'New Comedy Skit: Dem Boys', creator: 'Street Jokes GY', thumbnail: 'https://placehold.co/80x60/808080/FFF?text=Skit1', url: 'https://www.youtube.com/embed/SKIT_LIVE_1?autoplay=1' },
                { id: 'lf2', title: 'Interview: Rising Star', creator: 'NVA Insights', thumbnail: 'https://placehold.co/80x60/A0A0A0/000?text=Int1', url: 'https://www.youtube.com/embed/INTERVIEW_LIVE_2?autoplay=1' },
                { id: 'lf3', title: 'Short Film Trailer: Lost Gold', creator: 'Guyana Films', thumbnail: 'https://placehold.co/80x60/606060/EEE?text=Film1', url: 'https://www.youtube.com/embed/FILM_LIVE_3?autoplay=1' },
                { id: 'lf4', title: 'Live Music Session: Reggae Vibes', creator: 'Riddim Makers', thumbnail: 'https://placehold.co/80x60/404040/DDD?text=Music1', url: 'https://www.youtube.com/embed/MUSIC_LIVE_4?autoplay=1' },
                { id: 'lf5', title: 'Behind The Scenes: Drama Shoot', creator: 'Creative Minds', thumbnail: 'https://placehold.co/80x60/202020/CCC?text=BTS1', url: 'https://www.youtube.com/embed/BTS_LIVE_5?autoplay=1' },
                { id: 'lf6', title: 'Daily Vlog: Life in Georgetown', creator: 'GT Vlogger', thumbnail: 'https://placehold.co/80x60/909090/111?text=Vlog1', url: 'https://www.youtube.com/embed/VLOG_LIVE_6?autoplay=1' },
            ];
            const liveFeedItems = [...originalLiveFeedContent, ...originalLiveFeedContent, ...originalLiveFeedContent];


            const showMessage = (msg) => {
                setMessage(msg);
                setTimeout(() => setMessage(''), 3000);
            };

            const handleVideoPress = (url) => {
                setCurrentVideoUrl(url);
                setShowVideoModal(true);
            };

            const closeVideoModal = () => {
                setShowVideoModal(false);
                setCurrentVideoUrl('');
            };

            const handleLogout = async () => {
                try {
                    await signOut(auth);
                    showMessage('Logged out successfully!');
                    setActiveScreen('Home');
                } catch (error) {
                    console.error("Error logging out:", error);
                    showMessage('Failed to log out. Please try again.');
                }
            };

            // --- Screens ---

            const HomeScreen = () => {
                const horizontalCarouselRef = useRef(null);
                const horizontalScrollIntervalRef = useRef(null);
                const [isHorizontalDragging, setIsHorizontalDragging] = useState(false);
                const [horizontalStartX, setHorizontalStartX] = useState(0);
                const [horizontalScrollLeft, setHorizontalScrollLeft] = useState(0);

                const verticalCarouselRef = useRef(null);
                const verticalScrollIntervalRef = useRef(null);
                const [isVerticalDragging, setIsVerticalDragging] = useState(false);
                const [verticalStartY, setVerticalStartY] = useState(0);
                const [verticalScrollTop, setVerticalScrollTop] = useState(0);

                const startHorizontalAutoScroll = () => {
                    if (horizontalScrollIntervalRef.current) clearInterval(horizontalScrollIntervalRef.current);
                    const carousel = horizontalCarouselRef.current;
                    if (!carousel) return;

                    let scrollAmountPerItem = 0;
                    const firstItem = carousel.querySelector('.horizontal-carousel-item');
                    if (firstItem) {
                        const itemWidth = firstItem.offsetWidth;
                        const itemMarginRight = parseFloat(window.getComputedStyle(firstItem).marginRight);
                        scrollAmountPerItem = itemWidth + itemMarginRight;
                    } else {
                        scrollAmountPerItem = (carousel.offsetWidth / 3) + 15;
                    }
                    const originalContentWidth = originalCarouselImages.length * scrollAmountPerItem;

                    horizontalScrollIntervalRef.current = setInterval(() => {
                        if (isHorizontalDragging) return;
                        if (carousel.scrollLeft >= originalContentWidth - (scrollAmountPerItem / 2)) {
                            carousel.scrollLeft = 0;
                        }
                        carousel.scrollBy({ left: scrollAmountPerItem, behavior: 'smooth' });
                    }, 3000);
                };

                const stopHorizontalAutoScroll = () => {
                    if (horizontalScrollIntervalRef.current) clearInterval(horizontalScrollIntervalRef.current);
                    horizontalScrollIntervalRef.current = null;
                };

                useEffect(() => {
                    startHorizontalAutoScroll();
                    const carousel = horizontalCarouselRef.current;
                    if (!carousel) return;
                    carousel.addEventListener('mouseenter', stopHorizontalAutoScroll);
                    carousel.addEventListener('mouseleave', startHorizontalAutoScroll);
                    return () => {
                        stopHorizontalAutoScroll();
                        carousel.removeEventListener('mouseenter', stopHorizontalAutoScroll);
                        carousel.removeEventListener('mouseleave', startHorizontalAutoScroll);
                    };
                }, [isHorizontalDragging]);

                const handleHorizontalTouchStart = (e) => {
                    stopHorizontalAutoScroll();
                    setIsHorizontalDragging(true);
                    setHorizontalStartX(e.touches[0].pageX - horizontalCarouselRef.current.offsetLeft);
                    setHorizontalScrollLeft(horizontalCarouselRef.current.scrollLeft);
                };

                const handleHorizontalTouchMove = (e) => {
                    if (!isHorizontalDragging) return;
                    e.preventDefault();
                    const x = e.touches[0].pageX - horizontalCarouselRef.current.offsetLeft;
                    const walk = (x - horizontalStartX) * 1.5;
                    horizontalCarouselRef.current.scrollLeft = horizontalScrollLeft - walk;
                };

                const handleHorizontalTouchEnd = () => {
                    setIsHorizontalDragging(false);
                    setTimeout(startHorizontalAutoScroll, 1500);
                };

                const startVerticalAutoScroll = () => {
                    if (verticalScrollIntervalRef.current) clearInterval(verticalScrollIntervalRef.current);
                    const carousel = verticalCarouselRef.current;
                    if (!carousel) return;

                    let scrollAmountPerItem = 0;
                    const firstItem = carousel.querySelector('.vertical-carousel-item');
                    if (firstItem) {
                        const itemHeight = firstItem.offsetHeight;
                        const itemMarginBottom = parseFloat(window.getComputedStyle(firstItem).marginBottom);
                        scrollAmountPerItem = itemHeight + itemMarginBottom;
                    } else {
                        scrollAmountPerItem = (carousel.offsetHeight / 2);
                    }

                    const originalContentHeight = originalLiveFeedContent.length * scrollAmountPerItem;

                    verticalScrollIntervalRef.current = setInterval(() => {
                        if (isVerticalDragging) return;

                        if (carousel.scrollTop >= originalContentHeight - (scrollAmountPerItem / 2)) {
                             carousel.scrollTop = 0;
                        }
                        carousel.scrollBy({ top: scrollAmountPerItem, behavior: 'smooth' });
                    }, 3000);
                };

                const stopVerticalAutoScroll = () => {
                    if (verticalScrollIntervalRef.current) clearInterval(verticalScrollIntervalRef.current);
                    verticalScrollIntervalRef.current = null;
                };

                 useEffect(() => {
                    startVerticalAutoScroll();

                    const carousel = verticalCarouselRef.current;
                    if (!carousel) return;

                    carousel.addEventListener('mouseenter', stopVerticalAutoScroll);
                    carousel.addEventListener('mouseleave', startVerticalAutoScroll);

                    return () => {
                        stopVerticalAutoScroll();
                        carousel.removeEventListener('mouseenter', stopVerticalAutoScroll);
                        carousel.removeEventListener('mouseleave', startVerticalAutoScroll);
                    };
                }, [isVerticalDragging]);

                const handleVerticalTouchStart = (e) => {
                    stopVerticalAutoScroll();
                    setIsVerticalDragging(true);
                    setVerticalStartY(e.touches[0].pageY - verticalCarouselRef.current.offsetTop);
                    setVerticalScrollTop(verticalCarouselRef.current.scrollTop);
                };

                const handleVerticalTouchMove = (e) => {
                    if (!isVerticalDragging) return;
                    e.preventDefault();
                    const y = e.touches[0].pageY - verticalCarouselRef.current.offsetTop;
                    const walk = (y - verticalStartY) * 1.5;
                    verticalCarouselRef.current.scrollTop = verticalScrollTop - walk;
                };

                const handleVerticalTouchEnd = () => {
                    setIsVerticalDragging(false);
                    setTimeout(startVerticalAutoScroll, 1500);
                };


                return (
                    <div className="screenContainer">
                        {/* Container for top-right buttons */}
                        <div className="topRightButtonContainer">
                            {currentUser ? (
                                <button
                                    className="topButton"
                                    onClick={handleLogout}
                                >
                                    Logout
                                </button>
                            ) : (
                                <button
                                    className="topButton"
                                    onClick={() => setActiveScreen('Login')}
                                >
                                    Login
                                </button>
                            )}
                            <button
                                className="topButton"
                                onClick={() => setActiveScreen('Support')}
                            >
                                Support Us
                            </button>
                        </div>

                        {/* Horizontal Image Carousel Section - Featured Highlights */}
                        <p className="sectionTitle">Featured Highlights</p>
                        <div
                            className="horizontal-carousel-container"
                            ref={horizontalCarouselRef}
                            onTouchStart={handleHorizontalTouchStart}
                            onTouchMove={handleHorizontalTouchMove}
                            onTouchEnd={handleHorizontalTouchEnd}
                        >
                            {carouselImages.map((imageUrl, index) => (
                                <div key={index} className="horizontal-carousel-item">
                                    <img src={imageUrl} alt={`Carousel Image ${index + 1}`} className="carousel-image" />
                                </div>
                            ))}
                        </div>

                        {/* "Trending" Section with Aligned Creator Sign Up Button */}
                        <div className="sectionHeaderWithButton">
                            <p className="sectionTitle" style={{ marginBottom: '0' }}>Trending</p>
                            {!currentUser && (
                                <button
                                    className="sectionHeaderButton"
                                    onClick={() => setActiveScreen('CreatorSignUp')}
                                >
                                    Creator Sign Up
                                </button>
                            )}
                        </div>
                        <div className="contentGrid">
                            {featuredContent.slice(0, 6).map((item) => (
                                <button key={item.id} className="contentCard" onClick={() => handleVideoPress(item.url)}>
                                    <div className="thumbnailPlaceholder">
                                        <p className="thumbnailText">Video Thumbnail</p>
                                        <svg className="playIcon" viewBox="0 0 24 24">
                                            <path d="M8 5v14l11-7z"/>
                                        </svg>
                                    </div>
                                    <p className="contentTitle">{item.title}</p>
                                </button>
                            ))}
                        </div>

                        {/* "Live Feed" Vertical Carousel Section */}
                        <p className="sectionTitle">Live Feed</p>
                        <div
                            className="vertical-carousel-container"
                            ref={verticalCarouselRef}
                            onTouchStart={handleVerticalTouchStart}
                            onTouchMove={handleVerticalTouchMove}
                            onTouchEnd={handleVerticalTouchEnd}
                        >
                            {liveFeedItems.map((item, index) => (
                                <button key={index} className="vertical-carousel-item" onClick={() => handleVideoPress(item.url)}>
                                    <img src={item.thumbnail} alt={item.title} className="liveFeedThumbnail" />
                                    <div className="liveFeedContent">
                                        <p className="liveFeedTitle">{item.title}</p>
                                        <p className="liveFeedCreator">by {item.creator}</p>
                                    </div>
                                </button>
                            ))}
                        </div>
                    </div>
                );
            };

            const CategoriesScreen = () => (
                <div className="screenContainer">
                    <div className="categoryTabs">
                        {Object.keys(categories).map((categoryName) => (
                            <button
                                key={categoryName}
                                className={`categoryTab ${activeCategory === categoryName ? 'activeCategoryTab' : ''}`}
                                onClick={() => setActiveCategory(categoryName)}
                            >
                                <span className={`categoryTabText ${activeCategory === categoryName ? 'activeCategoryTabText' : ''}`}>
                                    {categoryName}
                                </span>
                            </button>
                        ))}
                    </div>

                    <div className="categoryContent">
                        <p className="sectionTitle">{activeCategory} Content</p>
                        <div className="contentGrid">
                            {categories[activeCategory].map((item) => (
                                <button key={item.id} className="contentCard" onClick={() => handleVideoPress(item.url)}>
                                    <div className="thumbnailPlaceholder">
                                        <p className="thumbnailText">Video Thumbnail</p>
                                        <svg className="playIcon" viewBox="0 0 24 24">
                                            <path d="M8 5v14l11-7z"/>
                                        </svg>
                                    </div>
                                    <p className="contentTitle">{item.title}</p>
                                </button>
                            ))}
                        </div>
                    </div>
                </div>
            );

            const PremiumScreen = () => (
                <div className="screenContainer">
                    <p className="heading">Unlock NVA Network Premium!</p>
                    <p className="subHeading">Experience Guyanese content like never before.</p>

                    <div className="premiumFeatureCard">
                        <p className="premiumFeatureTitle">1. Exclusive Content Access</p>
                        <p className="premiumFeatureDescription">
                            Get early access to new shows, premium-only series, uncensored versions,
                            and exclusive live events. Example: "Watch the full uncut version of Vibes Unfiltered before anyone else!"
                        </p>
                    </div >

                    <div className="premiumFeatureCard">
                        <p className="premiumFeatureTitle">2. Ad-Free Viewing</p>
                        <p className="premiumFeatureDescription">
                            Enjoy a seamless, uninterrupted viewing experience without in-app banner ads or pre-roll ads.
                        </p>
                    </div >

                    <div className="premiumFeatureCard">
                        <p className="premiumFeatureTitle">3. Special Perks & Giveaways</p>
                        <p className="premiumFeatureDescription">
                            Participate in monthly giveaways, exclusive merch drops, coupon codes for local businesses,
                            and priority access to virtual meet & greets.
                        </p>
                    </div>

                    <div className="premiumFeatureCard">
                        <p className="premiumFeatureTitle">4. Community & Recognition</p>
                        <p className="premiumFeatureDescription">
                            Receive a "VIP badge," vote on featured content, and join private chat rooms with creators.
                        </p>
                    </div >

                    <div className="premiumFeatureCard">
                        <p className="premiumFeatureTitle">5. Downloadable/Offline Viewing (Future)</p>
                        <p className="premiumFeatureDescription">
                            (Coming Soon) Download original content to watch offline, perfect for inconsistent internet.
                        </p>
                    </div>

                    <p className="sectionTitle">Pricing:</p>
                    <div className="pricingTable">
                        <div className="pricingRow">
                            <p className="pricingTier">Free</p>
                            <p className="pricingFeatures">Public videos, live shows, ads</p>
                            <p className="pricingPrice">$0</p>
                        </div>
                        <div className="pricingRow">
                            <p className="pricingTier">Premium Monthly</p>
                            <p className="pricingFeatures">All perks above</p>
                            <p className="pricingPrice">$1.99 USD / ~$400 GYD</p>
                        </div>
                        <div className="pricingRow">
                            <p className="pricingTier">Premium Yearly</p>
                            <p className="pricingFeatures">Discounted + bonus perks</p>
                            <p className="pricingPrice">$20 USD / ~$4,000 GYD</p>
                        </div >
                    </div>
                    <p className="smallText">
                        (Note: Actual payment integration would be done here using services like Stripe/PayPal.)
                    </p>
                    <button
                        className="button"
                        onClick={() => showMessage('Simulating subscription purchase. In a real app, this would initiate payment.')}
                    >
                        <span className="buttonText">Subscribe Now!</span>
                    </button>
                </div>
            );

            const AboutContactScreen = () => (
                <div className="screenContainer">
                    <p className="heading">About NVA Network</p>
                    <p className="subHeading">The Caribbeans first mobile-first entertainment network, dedicated to bringing the best of Guyanese content to a global stage.</p>

                    <p className="paragraph">
                        NVA Network is committed to empowering local creators and connecting audiences worldwide
                        with unique and vibrant stories from Guyana. Our mission is to provide a platform for Guyanese
                        comedians, filmmakers, interviewers, and live event organizers to showcase their talent,
                        reach new audiences, and build sustainable careers.
                    </p>

                    <p className="sectionTitle">Contact Us</p>
                    <p className="paragraph">
                        Have questions, feedback, or want to partner with us? Reach out!
                    </p>
                    <p className="contactInfo">Email: contact@nvanetwork.gy</p>
                    <p className="contactInfo">Phone: +592-555-NVA (Placeholder)</p>
                    <p className="contactInfo">Follow us on social media!</p>
                    {/* Add social media links here if desired */}
                </div>
            );

            const CrowdfundingScreen = ({ showMessage, setActiveScreen }) => (
                <div className="screenContainer">
                    <p className="heading">Support Guyanese Creators!</p>
                    <p className="subHeading">Help bring more authentic Guyanese content to life.</p>

                    <p className="paragraph">
                        International crowdfunding platforms often don't support direct bank accounts in Guyana,
                        making it difficult for our talented creators to receive global support.
                        At NVA Network, we're committed to finding direct ways for you to contribute!
                    </p>

                    <div className="premiumFeatureCard">
                        <p className="premiumFeatureTitle">Why Your Support Matters:</p>
                        <p className="premiumFeatureDescription">
                            Your contributions directly fund new skits, short films, interviews, and live event coverage.
                            Every dollar helps cover production costs, equipment, and fair compensation for our artists.
                        </p>
                    </div>

                    <p className="sectionTitle">How You Can Contribute Directly:</p>
                    <p className="paragraph">
                        We are setting up direct support channels that are accessible within Guyana and for our diaspora.
                        Please contact us for details on how to send your support via:
                    </p>
                    <p className="listItem"> Direct Bank Transfer (Local & International options)</p>
                    <p className="listItem"> Mobile Money Services (e.g., MMG - Mobile Money Guyana)</p>
                    <p className="listItem"> Other Local Payment Methods</p>

                    <button
                        className="button"
                        onClick={() => setActiveScreen('CreatorCampaigns')}
                    >
                        <span className="buttonText">Browse Creator Campaigns</span>
                    </button>
                    <p className="smallText">
                        (Discover campaigns and support your favorite creators!)
                    </p>

                    <p className="paragraph" style={{ marginTop: '20px' }}>
                        Your generosity empowers Guyanese voices and helps us build a stronger, more vibrant content ecosystem.
                        Thank you for being a part of the NVA Network family!
                    </p>

                    {/* Added a small note about the platform fee for transparency with donors */}
                    <p className="smallText" style={{ marginTop: '20px', color: '#888' }}>
                        *A small platform fee (e.g., 5%) helps NVA Network cover operational costs and continue supporting our creators.
                    </p>
                </div>
            );

            // --- New Creator Campaigns Screen ---
            const CreatorCampaignsScreen = ({ showMessage, setActiveScreen }) => (
                <div className="screenContainer">
                    <p className="heading">Creator Campaigns</p>
                    <p className="subHeading">Discover and support projects by Guyanese talent!</p>

                    {creatorCampaigns.map((campaign) => (
                        <div key={campaign.id} className="campaignCard">
                            <h3 className="campaignTitle">{campaign.title}</h3>
                            <p className="campaignCreator">By: {campaign.creator}</p>
                            <p className="campaignDescription">{campaign.description}</p>
                            <div className="campaignProgressContainer">
                                <div
                                    className="campaignProgressBar"
                                    style={{ width: `${(campaign.raised / campaign.goal) * 100}%` }}
                                ></div>
                            </div>
                            <div className="campaignStats">
                                <span>Raised: <span className="campaignRaised">${campaign.raised}</span></span>
                                <span>Goal: <span className="campaignGoal">${campaign.goal}</span></span>
                            </div>
                            <button
                                className="campaignButton"
                                onClick={() => showMessage(`Simulating support for "${campaign.title}". In a real app, this would lead to payment options.`)}
                            >
                                Support This Campaign
                            </button>
                        </div>
                    ))}

                    <p className="smallText" style={{ marginTop: '20px' }}>
                        Don't see your favorite creator? Encourage them to submit their content and campaigns!
                    </p>

                    {/* Back to Support Us button */}
                    <button
                        className="button"
                        onClick={() => setActiveScreen('Support')}
                        style={{ backgroundColor: '#3A3A3A', color: '#FFF', marginTop: '30px' }}
                    >
                        <span className="buttonText">Back to Support Options</span>
                    </button>
                </div>
            );

            // --- New Creator Sign Up Screen ---
            const CreatorSignUpScreen = ({ showMessage, setActiveScreen }) => {
                const [email, setEmail] = useState('');
                const [password, setPassword] = useState('');
                const [creatorName, setCreatorName] = useState('');
                const [bio, setBio] = useState('');
                const [selectedCategories, setSelectedCategories] = useState([]);
                const [existingWorkLink, setExistingWorkLink] = useState('');
                const [agreedToTerms, setAgreedToTerms] = useState(false);

                const availableCategories = ['Skits', 'Short Films', 'Interviews', 'Live Premieres', 'Music', 'Documentary', 'Other'];

                const handleCategoryChange = (e) => {
                    const { value, checked } = e.target;
                    if (checked) {
                        setSelectedCategories((prev) => [...prev, value]);
                    } else {
                        setSelectedCategories((prev) => prev.filter((cat) => cat !== value));
                    }
                };

                const handleSubmit = async (e) => {
                    e.preventDefault();
                    if (!agreedToTerms) {
                        showMessage('Please agree to the Creator Terms & Conditions to sign up.');
                        return;
                    }

                    // --- Password Validation ---
                    if (password.length < 8) {
                        showMessage('Password must be at least 8 characters long.');
                        return;
                    }
                    if (!/\d/.test(password)) {
                        showMessage('Password must include at least one number.');
                        return;
                    }
                    if (!/[A-Z]/.test(password)) {
                        showMessage('Password must include at least one capital letter.');
                        return;
                    }
                    // --- End Password Validation ---

                    try {
                        // Create user with Firebase Authentication
                        const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                        const user = userCredential.user;

                        // Save creator profile data to Firestore
                        const creatorRef = doc(db, "creators", user.uid); // Get a document reference for the new creator
                        await setDoc(creatorRef, {
                            email: email,
                            creatorName: creatorName,
                            bio: bio,
                            categories: selectedCategories,
                            existingWorkLink: existingWorkLink,
                            profilePictureUrl: '', // Initialize with empty string
                            uploadedVideos: { youtube: null, facebook: null, tiktok: null }, // Initialize video links
                            createdAt: new Date().toISOString()
                        });

                        showMessage(`Creator "${creatorName}" signed up successfully! (User created in Firebase)`);
                        // Navigate to the Creator Dashboard after successful sign-up
                        setActiveScreen('CreatorDashboard');
                    } catch (error) {
                        console.error("Error signing up creator:", error);
                        let errorMessage = "Failed to sign up. Please try again.";
                        if (error.code === 'auth/email-already-in-use') {
                            errorMessage = "This email is already in use. Please use a different email or sign in.";
                        } else if (error.code === 'auth/invalid-email') {
                            errorMessage = "Invalid email address format.";
                        } else if (error.code === 'auth/weak-password') {
                            errorMessage = "Password is too weak. Please choose a stronger password.";
                        } else if (error.code === 'auth/network-request-failed') {
                            errorMessage = "Network error. Please check your internet connection.";
                        } else if (error.code === 'auth/operation-not-allowed') {
                            errorMessage = "Email/Password sign-in is not enabled. Please enable it in Firebase Console.";
                        } else if (error.code === 'auth/missing-or-invalid-nonce') {
                            errorMessage = "Sign-up session expired or invalid. Please refresh the page and try again.";
                        }
                        showMessage(errorMessage);
                    }
                };

                return (
                    <div className="screenContainer">
                        <p className="heading">Join NVA Network as a Creator!</p>
                        <p className="subHeading">Create your profile to share your talent and connect with your audience.</p>

                        <form onSubmit={handleSubmit}>
                            <div className="formGroup">
                                <label htmlFor="email" className="formLabel">Email:</label>
                                <input
                                    type="email"
                                    id="email"
                                    className="formInput"
                                    value={email}
                                    onChange={(e) => setEmail(e.target.value)}
                                    required
                                />
                            </div>

                            <div className="formGroup">
                                <label htmlFor="password" className="formLabel">Password:</label>
                                <input
                                    type="password"
                                    id="password"
                                    className="formInput"
                                    value={password}
                                    onChange={(e) => setPassword(e.target.value)}
                                    required
                                />
                                <p className="smallText" style={{ textAlign: 'left', color: '#FFD700', marginTop: '5px' }}>
                                    Password must be at least 8 characters long, include at least one number and one capital letter.
                                </p>
                            </div>

                            <div className="formGroup">
                                <label htmlFor="creatorName" className="formLabel">Creator Name (Public):</label>
                                <input
                                    type="text"
                                    id="creatorName"
                                    className="formInput"
                                    value={creatorName}
                                    onChange={(e) => setCreatorName(e.target.value)}
                                    required
                                />
                            </div>

                            <div className="formGroup">
                                <label htmlFor="bio" className="formLabel">Brief Bio/Description:</label>
                                <textarea
                                    id="bio"
                                    className="formTextarea"
                                    value={bio}
                                    onChange={(e) => setBio(e.target.value)}
                                    placeholder="Tell us about yourself and your content!"
                                    required
                                ></textarea>
                            </div>

                            <div className="checkboxGroup">
                                <p className="checkboxLabel">Content Categories:</p>
                                {availableCategories.map((cat) => (
                                    <div key={cat} className="checkboxItem">
                                        <input
                                            type="checkbox"
                                            id={`cat-${cat}`}
                                            value={cat}
                                            checked={selectedCategories.includes(cat)}
                                            onChange={handleCategoryChange}
                                        />
                                        <label htmlFor={`cat-${cat}`}>{cat}</label>
                                    </div>
                                ))}
                            </div>

                            <div className="formGroup">
                                <label htmlFor="existingWork" className="formLabel">Link to Existing Work (Optional):</label>
                                <input
                                    type="url"
                                    id="existingWork"
                                    className="formInput"
                                    value={existingWorkLink}
                                    onChange={(e) => setExistingWorkLink(e.target.value)}
                                    placeholder="e.g., YouTube channel, Instagram profile"
                                />
                            </div>

                            <div className="formGroup">
                                <div className="checkboxItem">
                                    <input
                                        type="checkbox"
                                        id="agreeTerms"
                                        checked={agreedToTerms}
                                        onChange={(e) => setAgreedToTerms(e.target.checked)}
                                        required
                                    />
                                    <label htmlFor="agreeTerms">
                                        I agree to the <a href="#" className="termsLink" onClick={(e) => { e.preventDefault(); showMessage('Simulating opening Creator Terms & Conditions...'); }}>Creator Terms & Conditions</a>.
                                    </label>
                                </div>
                                <p className="termsText">
                                    NVA Network retains a **5-10% platform fee** from all crowdfunding and monetization activities
                                    to support platform operations, development, and continued promotion of Guyanese content.
                                    Detailed terms are in the full agreement.
                                </p>
                            </div>

                            <button type="submit" className="button">
                                <span className="buttonText">Sign Up as Creator</span>
                            </button>
                        </form>

                        <button
                            className="button"
                            onClick={() => setActiveScreen('Home')}
                            style={{ backgroundColor: '#3A3A3A', color: '#FFF', marginTop: '30px' }}
                        >
                            <span className="buttonText">Back to Home</span>
                        </button>
                    </div>
                );
            };

            // --- Login Screen ---
            const LoginScreen = ({ showMessage, setActiveScreen }) => {
                const [email, setEmail] = useState('');
                const [password, setPassword] = useState('');

                const handleSubmit = async (e) => {
                    e.preventDefault();
                    try {
                        await signInWithEmailAndPassword(auth, email, password);
                        showMessage(`Logged in as ${email}!`);
                        setActiveScreen('CreatorDashboard'); // Redirect to dashboard on successful login
                    } catch (error) {
                        console.error("Error logging in:", error);
                        let errorMessage = "Login failed. Please check your credentials.";
                        if (error.code === 'auth/user-not-found') {
                            errorMessage = "No account found with that email. Please sign up or check your email.";
                        } else if (error.code === 'auth/wrong-password') {
                            errorMessage = "Incorrect password. Please try again.";
                        } else if (error.code === 'auth/invalid-email') {
                            errorMessage = "Invalid email address format.";
                        } else if (error.code === 'auth/network-request-failed') {
                            errorMessage = "Network error. Please check your internet connection.";
                        } else if (error.code === 'auth/too-many-requests') {
                            errorMessage = "Too many login attempts. Please try again later.";
                        }
                        showMessage(errorMessage);
                    }
                };

                return (
                    <div className="screenContainer">
                        <p className="heading">Creator Login</p>
                        <p className="subHeading">Access your dashboard to manage your content and campaigns.</p>

                        <form onSubmit={handleSubmit} className="loginForm">
                            <div className="formGroup">
                                <label htmlFor="loginEmail" className="formLabel">Email:</label>
                                <input
                                    type="email"
                                    id="loginEmail"
                                    className="formInput"
                                    value={email}
                                    onChange={(e) => setEmail(e.target.value)}
                                    required
                                />
                            </div>

                            <div className="formGroup">
                                <label htmlFor="loginPassword" className="formLabel">Password:</label>
                                <input
                                    type="password"
                                    id="loginPassword"
                                    className="formInput"
                                    value={password}
                                    onChange={(e) => setPassword(e.target.value)}
                                    required
                                />
                            </div>

                            <button type="submit" className="button">
                                <span className="buttonText">Login</span>
                            </button>
                        </form>

                        <p className="smallText" style={{ marginTop: '20px' }}>
                            Don't have an account?{' '}
                            <a href="#" className="termsLink" onClick={(e) => { e.preventDefault(); setActiveScreen('CreatorSignUp'); }}>Sign Up Here</a>
                        </p>

                        <button
                            className="button"
                            onClick={() => setActiveScreen('Home')}
                            style={{ backgroundColor: '#3A3A3A', color: '#FFF', marginTop: '30px' }}
                        >
                            <span className="buttonText">Back to Home</span>
                        </button>
                    </div>
                );
            };

            // --- Creator Dashboard Screen ---
            const CreatorDashboardScreen = ({ showMessage, setActiveScreen, currentUser }) => {
                const [creatorProfile, setCreatorProfile] = useState(null);
                const [isEditingProfile, setIsEditingProfile] = useState(false);
                const [editCreatorName, setEditCreatorName] = useState('');
                const [editBio, setEditBio] = useState('');
                const [editCategories, setEditCategories] = useState([]);
                const [editExistingWorkLink, setEditExistingWorkLink] = useState('');

                const profilePictureInputRef = useRef(null);
                const [uploadedVideos, setUploadedVideos] = useState({
                    youtube: null,
                    facebook: null,
                    tiktok: null
                });
                const [youtubeInputLink, setYoutubeInputLink] = useState('');
                const [facebookInputLink, setFacebookInputLink] = useState('');
                const [tiktokInputLink, setTiktokInputInputLink] = useState('');

                const [showImageAdjustModal, setShowImageAdjustModal] = useState(false); // State for the image adjustment modal
                const [imageFileToAdjust, setImageFileToAdjust] = useState(null); // File object passed to the modal

                // --- Profile Editing Functions ---
                const handleSaveProfile = async () => {
                    try {
                        const creatorRef = doc(db, "creators", currentUser.uid);
                        await updateDoc(creatorRef, {
                            creatorName: editCreatorName,
                            bio: editBio,
                            categories: editCategories,
                            existingWorkLink: editExistingWorkLink,
                            updatedAt: new Date().toISOString()
                        });
                        setCreatorProfile(prev => ({
                            ...prev,
                            creatorName: editCreatorName,
                            bio: editBio,
                            categories: editCategories,
                            existingWorkLink: editExistingWorkLink,
                        }));
                        setIsEditingProfile(false);
                        showMessage("Profile updated successfully!");
                    } catch (error) {
                        console.error("Error saving profile:", error);
                        showMessage("Failed to save profile. Please try again.");
                    }
                };

                const handleCancelEdit = () => {
                    setEditCreatorName(creatorProfile.creatorName || '');
                    setEditBio(creatorProfile.bio || '');
                    setEditCategories(creatorProfile.categories || []);
                    setEditExistingWorkLink(creatorProfile.existingWorkLink || '');
                    setIsEditingProfile(false);
                    showMessage("Profile editing cancelled.");
                };

                const handleProfileCategoryChange = (e) => {
                    const { value, checked } = e.target;
                    if (checked) {
                        setEditCategories((prev) => [...prev, value]);
                    } else {
                        setEditCategories((prev) => prev.filter((cat) => cat !== value));
                    }
                };

                // --- Profile Picture Upload & Adjustment ---
                const triggerProfilePictureUpload = (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        // Create a URL for the selected file to pass to the modal
                        setImageFileToAdjust(file);
                        setShowImageAdjustModal(true);
                    }
                };

                const handleSaveAdjustedProfilePicture = async (adjustedBlob) => {
                    if (!currentUser || !adjustedBlob) {
                        showMessage("Error: No user or image to save.");
                        return;
                    }

                    setShowImageAdjustModal(false); // Close modal
                    showMessage('Uploading profile picture...');

                    try {
                        // Create a unique filename for the adjusted image (e.g., using timestamp or original file name + uid)
                        const fileName = `profile_${currentUser.uid}_${Date.now()}.png`; // Always save as PNG for consistency with transparency
                        const storageRefPath = ref(storage, `profile_pictures/${currentUser.uid}/${fileName}`);

                        // Upload the adjusted image BLOB
                        await uploadBytes(storageRefPath, adjustedBlob, { contentType: 'image/png' });
                        const downloadURL = await getDownloadURL(storageRefPath);

                        // Update Firestore with the new profile picture URL
                        const creatorRef = doc(db, "creators", currentUser.uid);
                        await updateDoc(creatorRef, {
                            profilePictureUrl: downloadURL,
                            updatedAt: new Date().toISOString()
                        });
                        setCreatorProfile(prev => ({ ...prev, profilePictureUrl: downloadURL }));
                        showMessage("Profile picture uploaded successfully!");
                    } catch (error) {
                        console.error("Error uploading adjusted profile picture:", error);
                        showMessage("Failed to upload profile picture. Please try again.");
                    }
                };

                const handleCancelAdjust = () => {
                    setShowImageAdjustModal(false);
                    setImageFileToAdjust(null);
                    showMessage("Profile picture adjustment cancelled.");
                };

                // --- Video Link Management Functions (Now with Firestore Persistence) ---
                const extractYouTubeId = (url) => {
                    const match = url.match(/(?:youtu\.be\/|youtube\.com\/(?:watch\?v=|embed\/|v\/|shorts\/))([^&?#]+)/);
                    return match ? match[1] : null;
                };

                const extractFacebookId = (url) => {
                    let videoId = null;
                    let match = url.match(/(?:facebook\.com\/(?:video.php\?v=|watch\/\?v=)|fb\.watch\/|facebook\.com\/[^\/]+\/videos\/)([0-9]+)/);
                    if (match && match[1]) {
                        videoId = match[1];
                    } else {
                        match = url.match(/facebook\.com\/[a-zA-Z0-9\._-]+\/videos\/(\d+)/);
                        if(match && match[1]) {
                            videoId = match[1];
                        }
                    }
                    return videoId;
                };

                const extractTikTokId = (url) => {
                    const match = url.match(/(?:tiktok\.com\/@(?:[a-zA-Z0-9._]+)\/video\/|vm\.tiktok\.com\/|tiktok\.com\/embed\/)([0-9]+)/);
                    return match ? match[1] : null;
                };

                const getThumbnailAndEmbed = (platform, url) => {
                    let videoId = null;
                    let thumbnailUrl = '';
                    let embedUrl = '';
                    let title = '';

                    switch (platform) {
                        case 'youtube':
                            videoId = extractYouTubeId(url);
                            if (videoId) {
                                thumbnailUrl = `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`;
                                embedUrl = `https://www.youtube.com/embed/${videoId}?autoplay=1&rel=0`;
                                title = 'YouTube Video';
                            }
                            break;
                        case 'facebook':
                            videoId = extractFacebookId(url); // Attempt to extract ID for basic validation
                            if (videoId) { // If an ID is found, proceed with embedding strategy
                                // Note: Directly fetching Facebook video thumbnails is complex due to platform restrictions (CORS, Graph API requirements).
                                // A generic, branded placeholder is used as a reliable fallback for client-side apps.
                                thumbnailUrl = `https://placehold.co/150x100/4267B2/FFFFFF?text=Facebook+Video`; // Facebook blue placeholder
                                embedUrl = `https://www.facebook.com/plugins/video.php?href=${encodeURIComponent(url)}&show_text=0&width=560&autoplay=1`;
                                title = 'Facebook Video (May require public setting or open in new tab)';
                            } else {
                                thumbnailUrl = `https://placehold.co/150x100/999999/FFFFFF?text=Invalid+FB+Video`;
                                embedUrl = ''; // No valid embed URL
                                title = 'Invalid Facebook Video Link';
                            }
                            break;
                        case 'tiktok':
                            videoId = extractTikTokId(url);
                            if (videoId) {
                                // Note: Directly fetching TikTok video thumbnails is complex due to platform restrictions (CORS, API requirements).
                                // A generic, branded placeholder is used as a reliable fallback for client-side apps.
                                thumbnailUrl = `https://placehold.co/150x100/69C9D0/FFFFFF?text=TikTok+Video`; // TikTok green placeholder
                                embedUrl = `https://www.tiktok.com/embed/${videoId}`;
                                title = 'TikTok Video';
                            } else {
                                thumbnailUrl = `https://placehold.co/150x100/999999/FFFFFF?text=Invalid+TikTok+Video`;
                                embedUrl = ''; // No valid embed URL
                                title = 'Invalid TikTok Video Link';
                            }
                            break;
                        default:
                            break;
                    }
                    return { videoId, thumbnailUrl, embedUrl, title };
                };

                const handleAddOrUpdateVideo = async (platform, inputUrl) => {
                    if (!inputUrl) {
                        showMessage(`Please enter a URL for the ${platform} video.`);
                        return;
                    }
                    const { videoId, thumbnailUrl, embedUrl, title } = getThumbnailAndEmbed(platform, inputUrl);

                    if (videoId && embedUrl) {
                        const updated = { url: inputUrl, thumbnailUrl, embedUrl, title };
                        setUploadedVideos(prev => ({
                            ...prev,
                            [platform]: updated
                        }));
                        try {
                            const creatorRef = doc(db, "creators", currentUser.uid);
                            await updateDoc(creatorRef, {
                                [`uploadedVideos.${platform}`]: updated,
                                updatedAt: new Date().toISOString()
                            });
                            showMessage(`${platform} video added successfully!`);
                            if (platform === 'youtube') setYoutubeInputLink('');
                            else if (platform === 'facebook') setFacebookInputLink('');
                            else if (platform === 'tiktok') setTiktokInputInputLink('');
                        } catch (error) {
                            console.error(`Error saving ${platform} video to Firestore:`, error);
                            showMessage(`Failed to save ${platform} video. Please check your internet connection and Firestore rules.`);
                        }

                    } else {
                        showMessage(`Invalid ${platform} video URL provided. Please check the link.`);
                    }
                };

                const handleRemoveVideo = async (platform) => {
                    setUploadedVideos(prev => ({
                        ...prev,
                        [platform]: null
                    }));
                    try {
                        const creatorRef = doc(db, "creators", currentUser.uid);
                        await updateDoc(creatorRef, {
                            [`uploadedVideos.${platform}`]: null,
                            updatedAt: new Date().toISOString()
                        });
                        showMessage(`${platform} video removed successfully.`);
                    } catch (error) {
                        console.error(`Error removing ${platform} video from Firestore:`, error);
                        showMessage(`Failed to remove ${platform} video. Please check your internet connection and Firestore rules.`);
                    }
                };

                // Fetch creator profile on component mount or when user changes
                useEffect(() => {
                    const fetchCreatorProfile = async () => {
                        if (currentUser) {
                            try {
                                const creatorDocRef = doc(db, "creators", currentUser.uid);
                                const docSnap = await getDoc(creatorDocRef);
                                if (docSnap.exists()) {
                                    const data = docSnap.data();
                                    setCreatorProfile(data);
                                    setEditCreatorName(data.creatorName || '');
                                    setEditBio(data.bio || '');
                                    setEditCategories(data.categories || []);
                                    setEditExistingWorkLink(data.existingWorkLink || '');
                                    setUploadedVideos(data.uploadedVideos || { youtube: null, facebook: null, tiktok: null });
                                } else {
                                    console.log("No creator profile found for this user. Creating basic profile in Firestore.");
                                    await setDoc(creatorDocRef, {
                                        email: currentUser.email,
                                        creatorName: currentUser.email.split('@')[0] || "",
                                        bio: "",
                                        categories: [],
                                        existingWorkLink: "",
                                        profilePictureUrl: '',
                                        uploadedVideos: { youtube: null, facebook: null, tiktok: null },
                                        createdAt: new Date().toISOString()
                                    });
                                    const newDocSnap = await getDoc(creatorDocRef);
                                    if(newDocSnap.exists()) {
                                        setCreatorProfile(newDocSnap.data());
                                        setEditCreatorName(newDocSnap.data().creatorName || '');
                                        setEditBio(newDocSnap.data().bio || '');
                                        setEditCategories(newDocSnap.data().categories || []);
                                        setEditExistingWorkLink(newDocSnap.data().existingWorkLink || '');
                                        setUploadedVideos(newDocSnap.data().uploadedVideos || { youtube: null, facebook: null, tiktok: null });
                                    }
                                }
                            } catch (error) {
                                console.error("Error fetching or creating creator profile:", error);
                                showMessage("Error loading profile. Please try again.");
                            }
                        }
                    };

                    fetchCreatorProfile();
                }, [currentUser]);

                if (!currentUser) {
                    return (
                        <div className="screenContainer">
                            <p className="heading">Access Denied</p>
                            <p className="subHeading">Please login to access the Creator Dashboard.</p>
                            <button
                                className="button"
                                onClick={() => setActiveScreen('Login')}
                            >
                                <span className="buttonText">Go to Login</span>
                            </button>
                             <button
                                className="button"
                                onClick={() => setActiveScreen('Home')}
                                style={{ backgroundColor: '#3A3A3A', color: '#FFF', marginTop: '10px' }}
                            >
                                <span className="buttonText">Back to Home</span>
                            </button>
                        </div>
                    );
                }

                if (!creatorProfile) {
                    return (
                        <div className="screenContainer" style={{ textAlign: 'center', paddingTop: '50px' }}>
                            <p className="heading">Loading Creator Profile...</p>
                            <p className="subHeading" style={{ color: '#FFD700' }}>Please ensure you are logged in and have an internet connection.</p>
                            <p className="smallText" style={{ color: '#888' }}>
                                If this takes too long, check your Firebase Firestore rules or refresh the app.
                            </p>
                        </div>
                    );
                }

                return (
                    <> {/* React Fragment to return multiple top-level elements */}
                        <div className="screenContainer">
                            <p className="heading">Creator Dashboard</p>
                            <p className="subHeading">Welcome, {creatorProfile.creatorName || currentUser.email}!</p>

                            <div className="dashboardSection">
                                <p className="dashboardSectionTitle">Your Profile</p>
                                <div style={{ display: 'flex', alignItems: 'center', marginBottom: '15px' }}>
                                    <img
                                        src={creatorProfile.profilePictureUrl || 'https://placehold.co/100x100/555/FFF?text=Profile'}
                                        alt="Profile"
                                        style={{ width: '100px', height: '100px', borderRadius: '50%', objectFit: 'cover', marginRight: '15px' }}
                                    />
                                    <input
                                        type="file"
                                        ref={profilePictureInputRef}
                                        style={{ display: 'none' }}
                                        onChange={triggerProfilePictureUpload} // Now triggers the modal
                                        accept="image/*"
                                    />
                                    <button
                                        className="dashboardButton"
                                        onClick={() => profilePictureInputRef.current.click()}
                                    >
                                        Upload Profile Picture
                                    </button>
                                </div>


                                {isEditingProfile ? (
                                    <>
                                        <div className="formGroup">
                                            <label htmlFor="editCreatorName" className="formLabel">Creator Name (Public):</label>
                                            <input
                                                type="text"
                                                id="editCreatorName"
                                                className="formInput"
                                                value={editCreatorName}
                                                onChange={(e) => setEditCreatorName(e.target.value)}
                                                required
                                            />
                                        </div>
                                        <div className="formGroup">
                                            <label htmlFor="editBio" className="formLabel">Brief Bio/Description:</label>
                                            <textarea
                                                id="editBio"
                                                className="formTextarea"
                                                value={editBio}
                                                onChange={(e) => setEditBio(e.target.value)}
                                                required
                                            ></textarea>
                                        </div>
                                        <div className="checkboxGroup">
                                            <p className="checkboxLabel">Content Categories:</p>
                                            {['Skits', 'Short Films', 'Interviews', 'Live Premieres', 'Music', 'Documentary', 'Other'].map((cat) => (
                                                <div key={cat} className="checkboxItem">
                                                    <input
                                                        type="checkbox"
                                                        id={`edit-cat-${cat}`}
                                                        value={cat}
                                                        checked={editCategories.includes(cat)}
                                                        onChange={handleProfileCategoryChange}
                                                    />
                                                    <label htmlFor={`edit-cat-${cat}`}>{cat}</label>
                                                </div>
                                            ))}
                                        </div>
                                        <div className="formGroup">
                                            <label htmlFor="editExistingWork" className="formLabel">Link to Existing Work:</label>
                                            <input
                                                type="url"
                                                id="editExistingWork"
                                                className="formInput"
                                                value={editExistingWorkLink}
                                                onChange={(e) => setEditExistingWorkLink(e.target.value)}
                                                placeholder="e.g., YouTube channel, Instagram profile"
                                            />
                                        </div>
                                        <button className="dashboardButton" onClick={handleSaveProfile}>Save Changes</button>
                                        <button className="dashboardButton" onClick={handleCancelEdit} style={{ backgroundColor: '#555' }}>Cancel</button>
                                    </>
                                ) : (
                                    <>
                                        {/* Displaying raw data without labels */}
                                        <p className="dashboardItem">{creatorProfile.creatorName}</p>
                                        <p className="dashboardItem">{creatorProfile.email}</p>
                                        <p className="dashboardItem">{creatorProfile.bio || 'No bio provided.'}</p>
                                        <p className="dashboardItem">{(creatorProfile.categories && creatorProfile.categories.length > 0) ? creatorProfile.categories.join(', ') : 'No categories selected.'}</p>
                                        {creatorProfile.existingWorkLink && <p className="dashboardItem"><a href={creatorProfile.existingWorkLink} target="_blank" style={{ color: '#FFD700', textDecoration: 'none' }}>{creatorProfile.existingWorkLink}</a></p>}
                                        <button
                                            className="dashboardButton"
                                            onClick={() => setIsEditingProfile(true)}
                                        >
                                            Edit Profile
                                        </button>
                                    </>
                                )}
                            </div>

                            <div className="dashboardSection">
                                <p className="dashboardSectionTitle">My Crowdfunding Campaigns</p>
                                {creatorCampaigns.filter(c => c.creator === (creatorProfile?.creatorName || currentUser?.email)).length > 0 ? (
                                    <ul className="dashboardContentList">
                                        {creatorCampaigns.filter(c => c.creator === (creatorProfile?.creatorName || currentUser?.email)).map(campaign => (
                                            <li key={campaign.id} className="dashboardContentListItem">
                                                <span>{campaign.title} (${campaign.raised}/${campaign.goal})</span>
                                                <button className="actionButton" onClick={() => showMessage(`Viewing details for "${campaign.title}"...`)}>Details</button>
                                                <button className="actionButton" onClick={() => showMessage(`Editing "${campaign.title}"...`)}>Edit</button>
                                            </li>
                                        ))}
                                    </ul>
                                ) : (
                                    <p className="dashboardItem">You don't have any active campaigns.</p>
                                )}
                                <button
                                    className="dashboardButton"
                                    onClick={() => showMessage('New campaign creation form functionality coming soon!')}
                                >
                                    Create New Campaign
                                </button>
                            </div>

                            <div className="dashboardSection">
                                <p className="dashboardSectionTitle">My Uploaded Videos</p>
                                <div className="videoLinkSection">
                                    <label htmlFor="youtubeLink" className="formLabel">YouTube Video Link:</label>
                                    <div className="videoInputContainer">
                                        <input
                                            type="url"
                                            id="youtubeLink"
                                            className="formInput"
                                            value={youtubeInputLink}
                                            onChange={(e) => setYoutubeInputLink(e.target.value)}
                                            placeholder="e.g., https://www.youtube.com/watch?v=VIDEO_ID"
                                        />
                                        {uploadedVideos.youtube ? (
                                            <button className="actionButton remove" onClick={() => handleRemoveVideo('youtube')}>Remove</button>
                                        ) : (
                                            <button className="actionButton" onClick={() => handleAddOrUpdateVideo('youtube', youtubeInputLink)}>Add</button>
                                        )}
                                    </div>
                                    {uploadedVideos.youtube && (
                                        <div className="videoThumbnailContainer" onClick={() => handleVideoPress(uploadedVideos.youtube.embedUrl)}>
                                            <img src={uploadedVideos.youtube.thumbnailUrl} alt="YouTube Thumbnail" className="videoThumbnail" />
                                            <div className="videoThumbnailOverlay">
                                                <svg className="thumbnailPlayIcon" viewBox="0 0 24 24">
                                                    <path d="M8 5v14l11-7z"/>
                                                </svg>
                                            </div>
                                        </div>
                                    )}
                                </div>

                                <div className="videoLinkSection">
                                    <label htmlFor="facebookLink" className="formLabel">Facebook Video Link:</label>
                                    <div className="videoInputContainer">
                                        <input
                                            type="url"
                                            id="facebookLink"
                                            className="formInput"
                                            value={facebookInputLink}
                                            onChange={(e) => setFacebookInputLink(e.target.value)}
                                            placeholder="e.g., https://www.facebook.com/video.php?v=VIDEO_ID or https://fb.watch/..."
                                        />
                                        {uploadedVideos.facebook ? (
                                            <button className="actionButton remove" onClick={() => handleRemoveVideo('facebook')}>Remove</button>
                                        ) : (
                                            <button className="actionButton" onClick={() => handleAddOrUpdateVideo('facebook', facebookInputLink)}>Add</button>
                                        )}
                                    </div>
                                    {uploadedVideos.facebook && (
                                        <div className="videoThumbnailContainer" onClick={() => handleVideoPress(uploadedVideos.facebook.embedUrl)}>
                                            <img src={uploadedVideos.facebook.thumbnailUrl} alt="Facebook Thumbnail" className="videoThumbnail" />
                                            <div className="videoThumbnailOverlay">
                                                <svg className="thumbnailPlayIcon" viewBox="0 0 24 24">
                                                    <path d="M8 5v14l11-7z"/>
                                                </svg>
                                            </div>
                                        </div>
                                    )}
                                    <p className="smallText" style={{ textAlign: 'left', color: '#FFD700', marginTop: '5px' }}>
                                        Note: Facebook video embedding can be temperamental due to privacy settings. Not all links may play in-app.
                                    </p>
                                </div>

                                <div className="videoLinkSection">
                                    <label htmlFor="tiktokLink" className="formLabel">TikTok Video Link:</label>
                                    <div className="videoInputContainer">
                                        <input
                                            type="url"
                                            id="tiktokLink"
                                            className="formInput"
                                            value={tiktokInputLink}
                                            onChange={(e) => setTiktokInputInputLink(e.target.value)}
                                            placeholder="e.g., https://www.tiktok.com/@user/video/VIDEO_ID"
                                        />
                                        {uploadedVideos.tiktok ? (
                                            <button className="actionButton remove" onClick={() => handleRemoveVideo('tiktok')}>Remove</button>
                                        ) : (
                                            <button className="actionButton" onClick={() => handleAddOrUpdateVideo('tiktok', tiktokInputLink)}>Add</button>
                                        )}
                                    </div>
                                    {uploadedVideos.tiktok && (
                                        <div className="videoThumbnailContainer" onClick={() => handleVideoPress(uploadedVideos.tiktok.embedUrl)}>
                                            <img src={uploadedVideos.tiktok.thumbnailUrl} alt="TikTok Thumbnail" className="videoThumbnail" />
                                            <div className="videoThumbnailOverlay">
                                                <svg className="thumbnailPlayIcon" viewBox="0 0 24 24">
                                                    <path d="M8 5v14l11-7z"/>
                                                </svg>
                                            </div>
                                        </div>
                                    )}
                                </div>
                            </div>

                            <div className="dashboardSection">
                                <p className="dashboardSectionTitle">Analytics Overview</p>
                                <p className="dashboardItem">Total Views: 15,450 (Last 30 days)</p>
                                <p className="dashboardItem">Total Crowdfunding Raised: $3,450</p>
                                <p className="dashboardItem">Audience Engagement: High</p>
                                <button
                                    className="dashboardButton"
                                    onClick={() => showMessage('Detailed analytics report functionality coming soon!')}
                                >
                                    View Full Analytics
                                </button>
                            </div>

                            <button
                                className="button"
                                onClick={() => setActiveScreen('Home')}
                                style={{ backgroundColor: '#3A3A3A', color: '#FFF', marginTop: '30px' }}
                            >
                                <span className="buttonText">Back to Home</span>
                            </button>
                        </div>
                        {showImageAdjustModal && imageFileToAdjust && (
                            <ProfilePictureAdjustModal
                                imageUrl={URL.createObjectURL(imageFileToAdjust)}
                                onSave={handleSaveAdjustedProfilePicture}
                                onCancel={handleCancelAdjust}
                                showMessage={showMessage}
                            />
                        )}
                    </>
                );
            };


            // --- Render Current Screen ---
            const renderScreen = () => {
                // Determine which screen to render based on activeScreen state
                switch (activeScreen) {
                    case 'Home':
                        return <HomeScreen />;
                    case 'Categories':
                        return <CategoriesScreen />;
                    case 'Login':
                        return <LoginScreen showMessage={showMessage} setActiveScreen={setActiveScreen} />;
                    case 'CreatorSignUp':
                        return <CreatorSignUpScreen showMessage={showMessage} setActiveScreen={setActiveScreen} />;
                    case 'Premium':
                        return <PremiumScreen />;
                    case 'Support':
                        return <CrowdfundingScreen showMessage={showMessage} setActiveScreen={setActiveScreen} />;
                    case 'CreatorCampaigns':
                        return <CreatorCampaignsScreen showVideoModal={showVideoModal} setShowVideoModal={setShowVideoModal} currentVideoUrl={currentVideoUrl} setCurrentVideoUrl={setCurrentVideoUrl} showMessage={showMessage} setActiveScreen={setActiveScreen} />;
                    case 'CreatorDashboard':
                        return <CreatorDashboardScreen showVideoModal={showVideoModal} setShowVideoModal={setShowVideoModal} currentVideoUrl={currentVideoUrl} setCurrentVideoUrl={setCurrentVideoUrl} showMessage={showMessage} setActiveScreen={setActiveScreen} currentUser={currentUser} />;
                    case 'About':
                        return <AboutContactScreen />;
                    default:
                        return <HomeScreen />;
                }
            };

            return (
                <div className="container">
                    <div className="header">
                        {/* Logo Image as background cover */}
                        <img
                            src="https://nva-network-app.netlify.app/NVA%20Network%20LOGO%20FX.png"
                            alt="NVA Network Logo"
                            className="headerLogo"
                            onError={(e) => { e.target.onerror = null; e.target.src='https://placehold.co/450x150/1A1A1A/FFD700?text=Logo+Error'; }} /* Fallback image */
                        />
                        {/* App Name */}
                        <p className="headerTitle">NVA Network</p>
                        {/* Joined Tagline */}
                        <p className="tagline">Guyanese Content to a Global Stage.</p>
                    </div>

                    {renderScreen()}

                    <div className="navigationBar">
                        <button className="navButton" onClick={() => setActiveScreen('Home')}>
                            <span className={`navButtonText ${activeScreen === 'Home' ? 'activeNavButtonText' : ''}`}>Home</span>
                        </button>
                        <button className="navButton" onClick={() => setActiveScreen('Categories')}>
                            <span className={`navButtonText ${activeScreen === 'Categories' ? 'activeNavButtonText' : ''}`}>Categories</span>
                        </button>
                        <button className="navButton" onClick={() => setActiveScreen('Premium')}>
                            <span className={`navButtonText ${activeScreen === 'Premium' ? 'activeNavButtonText' : ''}`}>Premium</span>
                        </button>
                        <button className="navButton" onClick={() => setActiveScreen('CreatorDashboard')}>
                            <span className={`navButtonText ${activeScreen === 'CreatorDashboard' ? 'activeNavButtonText' : ''}`}>Dashboard</span>
                        </button>
                        <button className="navButton" onClick={() => setActiveScreen('About')}>
                            <span className={`navButtonText ${activeScreen === 'About' ? 'activeNavButtonText' : ''}`}>About</span>
                        </button>
                    </div>

                    {message && (
                        <div className="messageBox">
                            <p className="messageText">{message}</p>
                        </div>
                    )}

                    {/* Video Player Modal */}
                    {showVideoModal && (
                        <VideoPlayerModal videoUrl={currentVideoUrl} onClose={closeVideoModal} />
                    )}
                </div>
            );
        }

        // Render the App component into the root div after all resources are loaded
        window.onload = function() {
            // Check if Firebase instances and React/ReactDOM are available before rendering
            if (
                typeof window.firebaseAuth === 'undefined' ||
                typeof window.onAuthStateChanged === 'undefined' ||
                typeof window.firebaseDb === 'undefined' ||
                typeof window.firebaseStorage === 'undefined' ||
                typeof ReactDOM === 'undefined'
            ) {
                console.error("Firebase or ReactDOM not fully initialized. Retrying render...");
                setTimeout(window.onload, 100); // Retry after a short delay
                return;
            }

            const root = ReactDOM.createRoot(document.getElementById('root'));
            root.render(<App />);
        };
    </script>
</body>
</html>
